{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-typedlogic: Bridging Formal Logic and Typed Python","text":"<p>TypedLogic is a powerful Python package that bridges the gap between formal logic and strongly typed Python code. It allows you to leverage fast logic programming engines like Souffle while specifying your logic in mypy-validated Python code.</p> Python LogicExecutionOutput <pre><code># links.py\nfrom pydantic import BaseModel\nfrom typedlogic import FactMixin, Term\nfrom typedlogic.decorators import axiom\n\nID = str\n\nclass Link(BaseModel, FactMixin):\n    \"\"\"A link between two entities\"\"\"\n    source: ID\n    target: ID\n\nclass Path(BaseModel, FactMixin):\n    \"\"\"An N-hop path between two entities\"\"\"\n    source: ID\n    target: ID\n    hops: int\n\n@axiom\ndef path_from_link(x: ID, y: ID):\n    \"\"\"If there is a link from x to y, there is a path from x to y\"\"\"\n    assert Link(source=x, target=y) &gt;&gt; Path(source=x, target=y, hops=1)\n\n@axiom\ndef transitivity(x: ID, y: ID, z: ID, d1: int, d2: int):\n    \"\"\"Transitivity of paths, plus hop counting\"\"\"\n    assert ((Path(source=x, target=y, hops=d1) &amp; Path(source=y, target=z, hops=d2)) &gt;&gt;\n            Path(source=x, target=z, hops=d1+d2))\n</code></pre> <pre><code>from typedlogic.integrations.souffle_solver import SouffleSolver\nfrom links import Link\nimport links as links\n\nsolver = SouffleSolver()\nsolver.load(links)  ## source for definitions and axioms\n# Add data\nlinks = [Link(source='CA', target='OR'), Link(source='OR', target='WA')]\nfor link in links:\n    solver.add(link)\nmodel = solver.model()\nfor fact in model.iter_retrieve(\"Path\"):\n    print(fact)\n</code></pre> <pre><code>Path(source='CA', target='OR', hops=1)\nPath(source='OR', target='WA', hops=1)\nPath(source='CA', target='WA', hops=2)\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Write logical axioms and rules using familiar Python syntax</li> <li>Benefit from strong typing and mypy validation</li> <li>Seamless integration with logic programming engines</li> <li>Support for various solvers, including Z3 and Souffle</li> <li>Compatible with popular Python libraries like Pydantic</li> </ul>"},{"location":"#why-typedlogic","title":"Why TypedLogic?","text":"<p>TypedLogic combines the best of both worlds: the expressiveness and familiarity of Python with the power of formal logic and fast logic programming engines. This unique approach allows developers to:</p> <ol> <li>Write more maintainable and less error-prone logical rules</li> <li>Catch type-related errors early in the development process</li> <li>Seamlessly integrate logical reasoning into existing Python projects</li> <li>Leverage the performance of specialized logic engines without sacrificing the Python ecosystem</li> </ol> <p>Get started with TypedLogic and experience a new way of combining logic programming with strongly typed Python!</p>"},{"location":"#installation","title":"Installation","text":"<p>Install TypedLogic using pip:</p> <pre><code>pip install typedlogic\n</code></pre> <p>With all extras pre-installed:</p> <pre><code>pip install typedlogic[all]\n</code></pre>"},{"location":"#define-predicates-using-pythonic-idioms","title":"Define predicates using Pythonic idioms","text":"<pre><code>from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n\nID = str\n\n\nclass Link(FactBaseModel):\n    source: ID\n    target: ID\n\n\nclass Path(FactBaseModel):\n    source: ID\n    target: ID\n</code></pre> <p>These can be used in the standard way in Python:</p> <pre><code>links = [Link(source='CA', target='OR'), Link(source='OR', target='WA')]\n</code></pre>"},{"location":"#specify-logical-axioms-directly-in-python","title":"Specify logical axioms directly in Python","text":"<pre><code>from typedlogic.decorators import axiom\n\n@axiom\ndef link_implies_path(x: ID, y: ID):\n    \"\"\"\"For all x, y, if there is a link from x to y, then there is a path from x to y\"\"\"\n    if Link(source=x, target=y):\n        assert Path(source=x, target=y)\n\n@axiom\ndef transitivity(x: ID, y: ID, z: ID):\n    \"\"\"For all x, y, z, if there is a path from x to y and a path from y to z,\n       then there is a path from x to z\"\"\"\n    if Path(source=x, target=y) and Path(source=y, target=z):\n        assert Path(source=x, target=z)\n</code></pre>"},{"location":"#performing-reasoning-from-within-python","title":"Performing reasoning from within Python","text":"<p><pre><code>from typedlogic.integrations.snakelogic import SnakeSolver\n\nsolver = SnakeSolver()\nsolver.load(\"links.py\")  ## source for definitions and axioms\nfor link in links:\n    solver.add(link)\nmodel = solver.model()\nfor fact in model.iter_retrieve(\"Path\"):\n    print(fact)\n</code></pre> prints:</p> <pre><code>Path(source='CA', target='OR')\nPath(source='OR', target='WA')\nPath(source='CA', target='WA')\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Core Concepts to understand the fundamental ideas behind TypedLogic</li> <li>Check out the API Reference for detailed information on available classes and functions</li> <li>See Advanced Usage for more complex examples and techniques</li> </ul>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This section covers more advanced topics and techniques for using TypedLogic effectively.</p>"},{"location":"advanced/#working-with-multiple-solvers","title":"Working with Multiple Solvers","text":"<p>TypedLogic supports multiple solvers, allowing you to choose the best tool for your specific use case. Here's an example of using both Z3 and Souffle solvers:</p> <pre><code>from typedlogic.integrations.solvers.z3 import Z3Solver\nfrom typedlogic.integrations.solvers.souffle import SouffleSolver\n\n# Using Z3\nz3_solver = Z3Solver()\nz3_solver.add(theory)\nz3_result = z3_solver.check()\n\n# Using Souffle\nsouffle_solver = SouffleSolver()\nsouffle_solver.add(theory)\nsouffle_result = souffle_solver.check()\n</code></pre>"},{"location":"advanced/#custom-predicate-definitions","title":"Custom Predicate Definitions","text":"<p>For more complex scenarios, you can define custom predicates with specific argument types:</p> <pre><code>from typedlogic import PredicateDefinition\n\ncustom_predicate = PredicateDefinition(\n    predicate=\"ComplexRelation\",\n    arguments={\n        \"arg1\": str,\n        \"arg2\": int,\n        \"arg3\": float\n    }\n)\n\ntheory.add(custom_predicate)\n</code></pre>"},{"location":"advanced/#integrating-with-pydantic","title":"Integrating with Pydantic","text":"<p>TypedLogic seamlessly integrates with Pydantic for robust data validation:</p> <pre><code>from pydantic import BaseModel, Field\nfrom typedlogic import FactMixin\n\nclass ComplexFact(BaseModel, FactMixin):\n    name: str\n    age: int = Field(..., ge=0, le=150)\n    scores: List[float] = Field(..., min_items=1, max_items=5)\n\n# This fact will be validated according to the Pydantic rules\nvalid_fact = ComplexFact(name=\"Alice\", age=30, scores=[85.5, 92.0, 78.5])\n</code></pre>"},{"location":"advanced/#handling-negation-and-existential-quantification","title":"Handling Negation and Existential Quantification","text":"<p>TypedLogic supports negation and existential quantification in axioms:</p> <pre><code>from typedlogic import axiom, gen1, Exists\n\n@axiom\ndef unique_parent():\n    return all(\n        ~Exists([\"y\"], Parent(parent=\"y\", child=x) &amp; (y != z))\n        for x, z in gen2(str, str)\n        if Parent(parent=z, child=x)\n    )\n</code></pre> <p>These advanced techniques allow you to express complex logical relationships and constraints in your TypedLogic-based systems.</p>"},{"location":"api/","title":"api_reference.md","text":""},{"location":"api/#api-reference","title":"API Reference","text":"<p>This page provides a detailed reference for the main classes and functions in TypedLogic.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#factmixin","title":"<code>FactMixin</code>","text":"<p>Base mixin class for defining facts.</p>"},{"location":"api/#theory","title":"<code>Theory</code>","text":"<p>Represents a collection of predicate definitions, facts, and axioms.</p> <p>Attributes: - <code>name: Optional[str]</code> - <code>constants: Dict[str, Any]</code> - <code>type_definitions: Dict[str, Any]</code> - <code>predicate_definitions: List[PredicateDefinition]</code> - <code>sentence_groups: List[SentenceGroup]</code> - <code>ground_terms: List[Term]</code></p>"},{"location":"api/#predicatedefinition","title":"<code>PredicateDefinition</code>","text":"<p>Defines a predicate with its arguments and types.</p> <p>Attributes: - <code>predicate: str</code> - <code>arguments: Dict[str, Any]</code> - <code>description: Optional[str]</code> - <code>metadata: Optional[Dict[str, Any]]</code> - <code>parents: Optional[List[str]]</code></p>"},{"location":"api/#sentence","title":"<code>Sentence</code>","text":"<p>Base class for logical sentences.</p>"},{"location":"api/#term","title":"<code>Term</code>","text":"<p>Represents a logical term (predicate application).</p>"},{"location":"api/#decorators","title":"Decorators","text":""},{"location":"api/#axiom","title":"<code>@axiom</code>","text":"<p>Decorator for defining axioms as Python functions.</p>"},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#gen1type1-typet1-generatort1-none-none","title":"<code>gen1(type1: Type[T1]) -&gt; Generator[T1, None, None]</code>","text":"<p>Generate a single typed variable.</p>"},{"location":"api/#gen2type1-typet1-type2-typet2-generatortuplet1-t2-none-none","title":"<code>gen2(type1: Type[T1], type2: Type[T2]) -&gt; Generator[Tuple[T1, T2], None, None]</code>","text":"<p>Generate a pair of typed variables.</p>"},{"location":"api/#gen3type1-typet1-type2-typet2-type3-typet3-generatortuplet1-t2-t3-none-none","title":"<code>gen3(type1: Type[T1], type2: Type[T2], type3: Type[T3]) -&gt; Generator[Tuple[T1, T2, T3], None, None]</code>","text":"<p>Generate a triple of typed variables.</p>"},{"location":"api/#solvers","title":"Solvers","text":""},{"location":"api/#z3solver","title":"<code>Z3Solver</code>","text":"<p>Solver implementation using Z3.</p>"},{"location":"api/#soufflesolver","title":"<code>SouffleSolver</code>","text":"<p>Solver implementation using Souffle.</p>"},{"location":"api/#logical-operators","title":"Logical Operators","text":"<ul> <li><code>And</code>: Logical AND</li> <li><code>Or</code>: Logical OR</li> <li><code>Not</code>: Logical NOT</li> <li><code>Implies</code>: Logical implication</li> <li><code>Iff</code>: Logical equivalence</li> <li><code>Forall</code>: Universal quantification</li> <li><code>Exists</code>: Existential quantification</li> </ul> <p>This API reference provides an overview of the main components of TypedLogic. For more detailed information on each class and function, including method signatures and usage examples, please refer to the inline documentation in the source code.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides various examples to illustrate the usage of TypedLogic in different scenarios.</p>"},{"location":"examples/#basic-family-relationships","title":"Basic Family Relationships","text":"<pre><code>from typedlogic import FactMixin, axiom, gen2\nfrom pydantic import BaseModel\n\nclass Parent(BaseModel, FactMixin):\n    parent: str\n    child: str\n\nclass Ancestor(BaseModel, FactMixin):\n    ancestor: str\n    descendant: str\n\n@axiom\ndef parent_is_ancestor():\n    return all(\n        Parent(parent=x, child=y) &gt;&gt; Ancestor(ancestor=x, descendant=y)\n        for x, y in gen2(str, str)\n    )\n\n@axiom\ndef ancestor_transitivity():\n    return all(\n        (Ancestor(ancestor=x, descendant=y) &amp; Ancestor(ancestor=y, descendant=z))\n        &gt;&gt; Ancestor(ancestor=x, descendant=z)\n        for x, y, z in gen3(str, str, str)\n    )\n\n# Usage\ntheory = Theory(\n    name=\"family_relationships\",\n    predicate_definitions=[\n        PredicateDefinition(\"Parent\", {\"parent\": str, \"child\": str}),\n        PredicateDefinition(\"Ancestor\", {\"ancestor\": str, \"descendant\": str}),\n    ],\n    sentence_groups=[SentenceGroup(name=\"axioms\", sentences=[parent_is_ancestor(), ancestor_transitivity()])],\n)\n\nsolver = Z3Solver()\nsolver.add(theory)\nsolver.add_fact(Parent(parent=\"Alice\", child=\"Bob\"))\nsolver.add_fact(Parent(parent=\"Bob\", child=\"Charlie\"))\n\nresult = solver.prove(Ancestor(ancestor=\"Alice\", descendant=\"Charlie\"))\nprint(f\"Alice is an ancestor of Charlie: {result}\")\n</code></pre>"},{"location":"examples/#type-hierarchies","title":"Type Hierarchies","text":"<pre><code>from typedlogic import FactMixin, axiom, gen1\nfrom pydantic import BaseModel\n\nclass Animal(BaseModel, FactMixin):\n    name: str\n\nclass Mammal(Animal):\n    pass\n\nclass Dog(Mammal):\n    breed: str\n\n@axiom\ndef dogs_are_mammals():\n    return all(\n        Dog(name=x, breed=y) &gt;&gt; Mammal(name=x)\n        for x, y in gen2(str, str)\n    )\n\n@axiom\ndef mammals_are_animals():\n    return all(\n        Mammal(name=x) &gt;&gt; Animal(name=x)\n        for x in gen1(str)\n    )\n\n# Usage\ntheory = Theory(\n    name=\"animal_hierarchy\",\n    predicate_definitions=[\n        PredicateDefinition(\"Animal\", {\"name\": str}),\n        PredicateDefinition(\"Mammal\", {\"name\": str}),\n        PredicateDefinition(\"Dog\", {\"name\": str, \"breed\": str}),\n    ],\n    sentence_groups=[SentenceGroup(name=\"axioms\", sentences=[dogs_are_mammals(), mammals_are_animals()])],\n)\n\nsolver = Z3Solver()\nsolver.add(theory)\nsolver.add_fact(Dog(name=\"Buddy\", breed=\"Labrador\"))\n\nresult = solver.prove(Animal(name=\"Buddy\"))\nprint(f\"Buddy is an animal: {result}\")\n</code></pre> <p>These examples demonstrate how to use TypedLogic to model relationships and hierarchies, define axioms, and perform logical reasoning. You can expand on these examples to create more complex logical systems tailored to your specific use cases.</p>"},{"location":"quickstart/","title":"Getting Started with TypedLogic","text":"<p>This guide will help you get up and running with TypedLogic quickly.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Install TypedLogic using pip:</p> <pre><code>pip install \"typedlogic[snakelog]\"\n</code></pre>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":"<p>First define some basic data structures that you want to reason over. Here we will use Pydantic, but you can use dataframes or plain python objects (and in the future, SQLModels, SQL Alchemy):</p> <pre><code>from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n\nID = str\n\n\nclass Link(FactBaseModel):\n    source: ID\n    target: ID\n\n\nclass Path(FactBaseModel):\n    source: ID\n    target: ID\n</code></pre> <p>These can be used in the standard way in Python:</p> <pre><code>links = [Link(source='CA', target='OR'), Link(source='OR', target='WA')]\n</code></pre> <p>Now we can define some rules:</p> <pre><code>from typedlogic.decorators import axiom\n\n@axiom\ndef link_implies_path(x: ID, y: ID):\n    \"\"\"\"For all x, y, if there is a link from x to y, then there is a path from x to y\"\"\"\n    if Link(source=x, target=y):\n        assert Path(source=x, target=y)\n\n@axiom\ndef transitivity(x: ID, y: ID, z: ID):\n    \"\"\"For all x, y, z, if there is a path from x to y and a path from y to z,\n       then there is a path from x to z\"\"\"\n    if Path(source=x, target=y) and Path(source=y, target=z):\n        assert Path(source=x, target=z)\n</code></pre> <p>Note that these rules are not actually executed in a Python environment, but they are syntactically well-formed and accurately typed.</p> <p>Now we can reason over the data. We will use a lightweight pure Python solver called <code>snakelog</code> that is easily installed as an extra:</p> <pre><code>from typedlogic.integrations.snakelogic import SnakeSolver\n\nsolver = SnakeSolver()\nsolver.load(\"links.py\")\nfor link in links:\n    solver.add(link)\nmodel = solver.model()\nfor fact in model.iter_retrieve(\"Path\"):\n    print(fact)\n</code></pre> <p>This will print:</p> <pre><code>Path(source='CA', target='OR')\nPath(source='OR', target='WA')\nPath(source='CA', target='WA')\n</code></pre>"},{"location":"quickstart/#satisfiability-checking","title":"Satisfiability checking","text":"<pre><code>@axiom\ndef acyclicity(x: ID, y: ID):\n    assert ~(Path(source=x, target=y) and Path(source=y, target=x))\n</code></pre> <p>Now we can check if the model is satisfiable. We will use the Z3 solver for this</p> <pre><code>from typedlogic.integrations.solvers.z3 import Z3Solver\n\nsolver = Z3Solver()\nsolver.load(\"links_with_acyclicity.py\")\nfor link in links:\n    solver.add(link)\n# add a link that causes a cycle\nsolver.add_link(Link(source='WA', target='CA'))\nsolver.check().satisfiable\n</code></pre> <p>This will return <code>False</code> because the model is not satisfiable.</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Core Concepts to understand the fundamental ideas behind TypedLogic</li> <li>Check out the API Reference for detailed information on available classes and functions</li> <li>See Advanced Usage for more complex examples and techniques</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#solvers","title":"Solvers","text":"<p>Add solvers for the following:</p> <ul> <li>dlv</li> <li>vampire</li> <li>OWL Reasoners (via owlery, robot, or py-horned-owl)</li> </ul>"},{"location":"roadmap/#framework-integrations","title":"Framework Integrations","text":"<ul> <li>OWL, using py-horned-owl</li> <li>LinkML</li> </ul>"},{"location":"roadmap/#transformations","title":"Transformations","text":"<p>Add other useful transformations, e.g NNF</p>"},{"location":"roadmap/#documentation","title":"Documentation","text":"<ul> <li>document differences with HETS, DOL</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This page provides solutions to common issues you might encounter when using TypedLogic.</p>"},{"location":"troubleshooting/#type-checking-errors","title":"Type Checking Errors","text":"<p>Issue: MyPy reports type errors in axioms or fact definitions.</p> <p>Solution:  1. Ensure you're using the latest version of TypedLogic and MyPy. 2. Check that all your fact classes properly inherit from both <code>BaseModel</code> and <code>FactMixin</code>. 3. Verify that you're using the correct generator functions (<code>gen1</code>, <code>gen2</code>, etc.) with matching types.</p> <p>Example of correct usage: <pre><code>@axiom\ndef correct_axiom():\n    return all(\n        Parent(parent=x, child=y) &gt;&gt; Ancestor(ancestor=x, descendant=y)\n        for x, y in gen2(str, str)\n    )\n</code></pre></p>"},{"location":"troubleshooting/#solver-not-finding-solutions","title":"Solver Not Finding Solutions","text":"<p>Issue: The solver fails to find a solution or prove a statement that you believe should be true.</p> <p>Solution: 1. Double-check your axioms and make sure they correctly express the logical relationships you intend. 2. Verify that all necessary facts have been added to the solver. 3. Try using a different solver (e.g., switch from Z3 to Souffle) to see if the issue persists. 4. Add intermediate assertions or print statements to debug the logical flow.</p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":"<p>Issue: Solving takes too long or consumes too much memory.</p> <p>Solution: 1. Simplify your axioms if possible. Complex axioms can lead to exponential growth in the search space. 2. Use more specific types in your fact definitions to reduce the search space. 3. Consider using Souffle for large-scale problems, as it's often more efficient for certain types of logical reasoning. 4. Break down complex queries into smaller, manageable parts.</p>"},{"location":"troubleshooting/#integration-issues","title":"Integration Issues","text":"<p>Issue: Difficulty integrating TypedLogic with existing projects or libraries.</p> <p>Solution: 1. Ensure all required dependencies are installed and up-to-date. 2. Check for version compatibility between TypedLogic and other libraries you're using (especially Pydantic). 3. Use TypedLogic's built-in integration modules (e.g., <code>typedlogic.integrations.pydantic</code>) for smoother interoperability.</p>"},{"location":"troubleshooting/#unexpected-logical-results","title":"Unexpected Logical Results","text":"<p>Issue: The solver produces results that seem logically incorrect.</p> <p>Solution: 1. Review your axioms carefully. Small logical errors can lead to unexpected conclusions. 2. Use the <code>prove</code> method to test individual logical statements and isolate the source of the unexpected behavior. 3. Consider the closed-world assumption: the solver only knows what you've explicitly told it or what can be directly inferred from that information.</p> <p>If you encounter issues not covered here, please check the project's issue tracker on GitHub or reach out to the community for assistance.</p>"},{"location":"api/solver/","title":"Solver","text":""},{"location":"api/solver/#typedlogic.solver.Model","title":"<code>Model</code>  <code>dataclass</code>","text":"<p>A model is a set of ground terms that satisfy a set of axioms.</p> Source code in <code>src/typedlogic/solver.py</code> <pre><code>@dataclass\nclass Model:\n    \"\"\"\n    A model is a set of ground terms that satisfy a set of axioms.\n    \"\"\"\n    description: Optional[str] = None\n    source_object: Optional[Any] = None\n    ground_terms: List[Term] = field(default_factory=list)\n\n    def iter_retrieve(self, predicate: str, *args) -&gt; Iterator[Term]:\n        \"\"\"\n        Retrieve all ground terms with a given predicate.\n\n        :param predicate:\n        :return:\n        \"\"\"\n        for t in self.ground_terms:\n            if t.predicate != predicate:\n                continue\n            if args:\n                is_match = True\n                for i in range(len(args)):\n                    if args[i] is None:\n                        continue\n                    if args[i] != t.values[i]:\n                        is_match = False\n                        break\n                if not is_match:\n                    continue\n            yield t\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Model.iter_retrieve","title":"<code>iter_retrieve(predicate, *args)</code>","text":"<p>Retrieve all ground terms with a given predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>str</code> required <p>Returns:</p> Type Description <code>Iterator[Term]</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def iter_retrieve(self, predicate: str, *args) -&gt; Iterator[Term]:\n    \"\"\"\n    Retrieve all ground terms with a given predicate.\n\n    :param predicate:\n    :return:\n    \"\"\"\n    for t in self.ground_terms:\n        if t.predicate != predicate:\n            continue\n        if args:\n            is_match = True\n            for i in range(len(args)):\n                if args[i] is None:\n                    continue\n                if args[i] != t.values[i]:\n                    is_match = False\n                    break\n            if not is_match:\n                continue\n        yield t\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Method","title":"<code>Method</code>  <code>dataclass</code>","text":"<p>A method is a way to solve a set of axioms.</p> Source code in <code>src/typedlogic/solver.py</code> <pre><code>@dataclass\nclass Method:\n    \"\"\"\n    A method is a way to solve a set of axioms.\n    \"\"\"\n    name: str\n    description: Optional[str] = None\n    is_default: bool = False\n    impl_class: Optional[Type] = None\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Solver","title":"<code>Solver</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A solver is a class that can check a set of axioms for consistency, satisfiability, or some other property.</p> <p>This is an abstract class that defines the interface for a solver.</p> <p>You can retrieve a specific solver with the <code>get_solver</code> function:</p> <pre><code>&gt;&gt;&gt; from typedlogic.registry import get_solver\n&gt;&gt;&gt; solver = get_solver(\"clingo\")\n</code></pre> <p>Once you has a solver, you can can add theories, or individual sentences to it:</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n&gt;&gt;&gt; from typedlogic import Term, Variable\n&gt;&gt;&gt; x = Variable(\"x\")\n&gt;&gt;&gt; y = Variable(\"y\")\n&gt;&gt;&gt; z = Variable(\"z\")\n&gt;&gt;&gt; solver.add( (Term(\"AncestorOf\", x, z) &amp; Term(\"AncestorOf\", z, y)) &gt;&gt; Term(\"AncestorOf\", x, y))\n</code></pre> <p>And facts:</p> <pre><code>&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n&gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n&gt;&gt;&gt; solver.add_sentence_group(aa)\n</code></pre> <p>The <code>check</code> method ensures the theory and ground terms (data) are consistent:</p> <pre><code>&gt;&gt;&gt; soln = solver.check()\n&gt;&gt;&gt; soln.satisfiable\nTrue\n</code></pre> <p>You can then query for models:</p> <pre><code>&gt;&gt;&gt; model = solver.model()\n&gt;&gt;&gt; for t in model.ground_terms:\n...     print(t)\nAncestorOf(p1, p1a)\nAncestorOf(p1a, p1aa)\nAncestorOf(p1, p1aa)\n</code></pre> Source code in <code>src/typedlogic/solver.py</code> <pre><code>@dataclass\nclass Solver(ABC):\n    \"\"\"\n    A solver is a class that can check a set of axioms for consistency, satisfiability, or some other property.\n\n    This is an abstract class that defines the interface for a solver.\n\n    You can retrieve a specific solver with the `get_solver` function:\n\n        &gt;&gt;&gt; from typedlogic.registry import get_solver\n        &gt;&gt;&gt; solver = get_solver(\"clingo\")\n\n    Once you has a solver, you can can add theories, or individual sentences to it:\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n        &gt;&gt;&gt; from typedlogic import Term, Variable\n        &gt;&gt;&gt; x = Variable(\"x\")\n        &gt;&gt;&gt; y = Variable(\"y\")\n        &gt;&gt;&gt; z = Variable(\"z\")\n        &gt;&gt;&gt; solver.add( (Term(\"AncestorOf\", x, z) &amp; Term(\"AncestorOf\", z, y)) &gt;&gt; Term(\"AncestorOf\", x, y))\n\n    And facts:\n\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n        &gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n        &gt;&gt;&gt; solver.add_sentence_group(aa)\n\n    The `check` method ensures the theory and ground terms (data) are consistent:\n\n        &gt;&gt;&gt; soln = solver.check()\n        &gt;&gt;&gt; soln.satisfiable\n        True\n\n    You can then query for models:\n\n        &gt;&gt;&gt; model = solver.model()\n        &gt;&gt;&gt; for t in model.ground_terms:\n        ...     print(t)\n        AncestorOf(p1, p1a)\n        AncestorOf(p1a, p1aa)\n        AncestorOf(p1, p1aa)\n\n    \"\"\"\n    strict: bool = False\n    method_name: Optional[str] = None\n    methods_supported: ClassVar[Optional[List[Method]]] = None\n    profile: ClassVar[Profile] = UnspecifiedProfile()\n    assume_closed_world: bool = False\n\n    # TODO: move towards this\n    base_theory: Theory = field(default_factory=Theory)\n\n    predicate_definitions: Optional[Dict[str, PredicateDefinition]] = None\n    type_definitions: Dict[str, str] = field(default_factory=dict)\n    constants: Dict[str, Any] = field(default_factory=dict)\n    goals: Optional[List[SentenceGroup]] = None\n\n    @property\n    def method(self) -&gt; Method:\n        if self.methods_supported is None:\n            raise NotImplementedError(\"Solver must define methods_supported\")\n        for m in self.methods_supported:\n            if self.method_name is None and m.is_default:\n                return m\n            if m.name == self.method_name:\n                return m\n        raise ValueError(f\"Method {self.method_name} not supported\")\n\n    @abstractmethod\n    def check(self) -&gt; Solution:\n        pass\n\n    def model(self) -&gt; Model:\n        return next(self.models())\n\n    @abstractmethod\n    def models(self) -&gt; Iterator[Model]:\n        pass\n\n    def prove_goals(self, strict=True) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        if not self.check().satisfiable:\n            raise ValueError(\"Cannot prove goals for unsatisfiable theory\")\n        if not self.goals:\n            raise ValueError(\"No goals to prove\")\n        for goal_group in self.goals:\n            if not goal_group.sentences:\n                raise ValueError(f\"Goal group {goal_group.name} has no sentences\")\n            for sentence in goal_group.sentences:\n                provable = self.prove(sentence)\n                if not provable and strict:\n                    raise ValueError(f\"Goal {sentence} not provable\")\n                yield sentence, provable\n\n    def prove_multiple(self, sentences: List[Sentence]) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        if self.check().satisfiable is False:\n            raise ValueError(\"Cannot prove goals for unsatisfiable theory\")\n        if not sentences:\n            raise ValueError(\"No goals to prove\")\n        for sentence in sentences:\n            provable = self.prove(sentence)\n            yield sentence, provable\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        \"\"\"\n        Prove a sentence.\n\n        :param sentence:\n        :return:\n        \"\"\"\n        if isinstance(sentence, Term):\n            # Note: the default implementation may be highly ineffecient.\n            # it is recommended to override this method in a subclass.\n            has_vars = sentence.variables\n            cls = type(self)\n            new_solver = cls()\n            new_solver.add(self.base_theory)\n            model = self.model()\n            for t in model.iter_retrieve(sentence.predicate):\n                if t == sentence:\n                    return True\n                if has_vars:\n                    if t.predicate == sentence.predicate:\n                        is_match = True\n                        for i in range(len(sentence.values)):\n                            arg_val = sentence.values[i]\n                            if isinstance(arg_val, Variable):\n                                # auto-match (assume existential over whole domain)\n                                continue\n                            if arg_val != t.values[i]:\n                                is_match = False\n                                break\n                        if is_match:\n                            return True\n            return False\n        if isinstance(sentence, Exists):\n            inner = sentence.sentence\n            if isinstance(inner, Term):\n                return self.prove(inner)\n        return None\n\n    def load(self, source: Union[str, Path, TextIO, ModuleType]) -&gt; None:\n        \"\"\"\n        Load a theory from a file.\n\n        :param source:\n        :return:\n        \"\"\"\n        parser = PythonParser()\n        if isinstance(source, ModuleType):\n            theory = parser.transform(source)\n        else:\n            theory = parser.parse(source)\n        self.add(theory)\n\n\n    def add(self, element: Union[ELEMENT, Iterable[ELEMENT]]) -&gt; None:\n        if isinstance(element, (list, abc.Iterator)):\n            for e in element:\n                self.add(e)\n            return\n        if isinstance(element, FactMixin):\n            self.add_fact(element)\n        elif isinstance(element, SentenceGroup):\n            self.add_sentence_group(element)\n        elif isinstance(element, Theory):\n            self.add_theory(element)\n        elif isinstance(element, PredicateDefinition):\n            self.add_predicate_definition(element)\n        elif isinstance(element, Sentence):\n            self.add_sentence(element)\n        else:\n            raise ValueError(f\"Unsupported axiom type: {type(element)}\")\n\n    def add_fact(self, fact: FactMixin):\n        self.base_theory.ground_terms.append(fact_to_term(fact))\n\n    def add_sentence_group(self, sentence_group: SentenceGroup) -&gt; None:\n        self.base_theory.sentence_groups.append(sentence_group)\n        if sentence_group.group_type == SentenceGroupType.GOAL:\n            if not self.goals:\n                self.goals = []\n            self.goals.append(sentence_group)\n        if sentence_group.sentences:\n            for sentence in sentence_group.sentences:\n                self.add_sentence(sentence)\n\n    def add_sentence(self, sentence: Sentence) -&gt; None:\n        if sentence not in self.base_theory.sentences:\n            self.base_theory.sentence_groups.append(SentenceGroup(name=\"dynamic\",\n                                                                  sentences=[sentence]))\n\n    def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n        \"\"\"\n        Add a predicate definition to the solver.\n\n        Some solvers do not need predicate definitions (for example, classic prolog systems, as well\n        as pure FOL solvers). However, many solvers need some kind of typing information.\n\n        :param predicate_definition:\n        :return:\n        \"\"\"\n        self.base_theory.predicate_definitions.append(predicate_definition)\n\n    def add_theory(self, theory: Theory) -&gt; None:\n        if theory.constants:\n            for k, v in theory.constants.items():\n                self.constants[k] = v\n                self.base_theory.constants[k] = v\n        if theory.type_definitions:\n            for k, v in theory.type_definitions.items():\n                self.type_definitions[k] = v\n                self.base_theory.type_definitions[k] = v\n        if theory.predicate_definitions:\n            for p in theory.predicate_definitions:\n                self.add_predicate_definition(p)\n        if theory.sentence_groups:\n            for aa in theory.sentence_groups:\n                self.add_sentence_group(aa)\n        if theory.ground_terms:\n            for t in theory.ground_terms:\n                self.add(t)\n\n\n    def dump(self) -&gt; str:\n        \"\"\"\n        Dump the internal state of the solver as a string.\n\n        :return:\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Solver.prove","title":"<code>prove(sentence)</code>","text":"<p>Prove a sentence.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Optional[bool]</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n    \"\"\"\n    Prove a sentence.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, Term):\n        # Note: the default implementation may be highly ineffecient.\n        # it is recommended to override this method in a subclass.\n        has_vars = sentence.variables\n        cls = type(self)\n        new_solver = cls()\n        new_solver.add(self.base_theory)\n        model = self.model()\n        for t in model.iter_retrieve(sentence.predicate):\n            if t == sentence:\n                return True\n            if has_vars:\n                if t.predicate == sentence.predicate:\n                    is_match = True\n                    for i in range(len(sentence.values)):\n                        arg_val = sentence.values[i]\n                        if isinstance(arg_val, Variable):\n                            # auto-match (assume existential over whole domain)\n                            continue\n                        if arg_val != t.values[i]:\n                            is_match = False\n                            break\n                    if is_match:\n                        return True\n        return False\n    if isinstance(sentence, Exists):\n        inner = sentence.sentence\n        if isinstance(inner, Term):\n            return self.prove(inner)\n    return None\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Solver.load","title":"<code>load(source)</code>","text":"<p>Load a theory from a file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path, TextIO, ModuleType]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def load(self, source: Union[str, Path, TextIO, ModuleType]) -&gt; None:\n    \"\"\"\n    Load a theory from a file.\n\n    :param source:\n    :return:\n    \"\"\"\n    parser = PythonParser()\n    if isinstance(source, ModuleType):\n        theory = parser.transform(source)\n    else:\n        theory = parser.parse(source)\n    self.add(theory)\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Solver.add_predicate_definition","title":"<code>add_predicate_definition(predicate_definition)</code>","text":"<p>Add a predicate definition to the solver.</p> <p>Some solvers do not need predicate definitions (for example, classic prolog systems, as well as pure FOL solvers). However, many solvers need some kind of typing information.</p> <p>Parameters:</p> Name Type Description Default <code>predicate_definition</code> <code>PredicateDefinition</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n    \"\"\"\n    Add a predicate definition to the solver.\n\n    Some solvers do not need predicate definitions (for example, classic prolog systems, as well\n    as pure FOL solvers). However, many solvers need some kind of typing information.\n\n    :param predicate_definition:\n    :return:\n    \"\"\"\n    self.base_theory.predicate_definitions.append(predicate_definition)\n</code></pre>"},{"location":"api/solver/#typedlogic.solver.Solver.dump","title":"<code>dump()</code>","text":"<p>Dump the internal state of the solver as a string.</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def dump(self) -&gt; str:\n    \"\"\"\n    Dump the internal state of the solver as a string.\n\n    :return:\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/transformations/","title":"Transformations","text":"<p>Function for performing transformation and manipulation of Sentences and Theories</p>"},{"location":"api/transformations/#typedlogic.transformations.PrologConfig","title":"<code>PrologConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Prolog output.</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>@dataclass\nclass PrologConfig:\n    \"\"\"\n    Configuration for Prolog output.\n    \"\"\"\n    use_lowercase_vars: Optional[bool] = False\n    use_uppercase_predicates: Optional[bool]  = False\n    disjunctive_datalog: Optional[bool]  = False\n    operator_map: Optional[Mapping[str, str]] = None\n    negation_symbol : str = field(default=r'\\+')\n    negation_as_failure_symbol : str = field(default=r'\\+')\n    assume_negation_as_failure: bool = False\n    double_quote_strings: bool = False\n    include_parens_for_zero_args: bool = False\n    allow_function_terms: bool = True\n    allow_nesting: bool = True\n    null_term: str = \"null(_)\"\n    allow_skolem_terms: bool = False\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.implies_from_parents","title":"<code>implies_from_parents(theory)</code>","text":"<p>Generate implications from parent classes.</p> <p>In the data model, PredicateDefinition can be linked to any number of parent classes. This function generates implications for each.</p> <pre><code>&gt;&gt;&gt; from typedlogic import PredicateDefinition, Theory, SentenceGroup\n&gt;&gt;&gt; theory = Theory(\n...     name=\"test\",\n...     predicate_definitions=[\n...         PredicateDefinition(\n...             predicate=\"Person\",\n...             arguments={\"name\": \"str\"},\n...             parents=[\"Thing\"],\n...         ),\n...         PredicateDefinition(\n...             predicate=\"Thing\",\n...             arguments={\"name\": \"str\"},\n...             parents=[],\n...         ),\n...     ],\n...     sentence_groups=[]\n... )\n&gt;&gt;&gt; theory2 = implies_from_parents(theory)\n&gt;&gt;&gt; new_sentences = theory2.sentence_groups[0].sentences\n&gt;&gt;&gt; new_sentences\n[Forall([name: str] : Implies(Thing(?name), Person(?name)))]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> <p>The theory to generate implications for</p> required <p>Returns:</p> Type Description <code>Theory</code> <p>A new theory with implications</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def implies_from_parents(theory: Theory) -&gt; Theory:\n    \"\"\"\n    Generate implications from parent classes.\n\n    In the data model, PredicateDefinition can be linked to any number\n    of parent classes. This function generates implications for each.\n\n        &gt;&gt;&gt; from typedlogic import PredicateDefinition, Theory, SentenceGroup\n        &gt;&gt;&gt; theory = Theory(\n        ...     name=\"test\",\n        ...     predicate_definitions=[\n        ...         PredicateDefinition(\n        ...             predicate=\"Person\",\n        ...             arguments={\"name\": \"str\"},\n        ...             parents=[\"Thing\"],\n        ...         ),\n        ...         PredicateDefinition(\n        ...             predicate=\"Thing\",\n        ...             arguments={\"name\": \"str\"},\n        ...             parents=[],\n        ...         ),\n        ...     ],\n        ...     sentence_groups=[]\n        ... )\n        &gt;&gt;&gt; theory2 = implies_from_parents(theory)\n        &gt;&gt;&gt; new_sentences = theory2.sentence_groups[0].sentences\n        &gt;&gt;&gt; new_sentences\n        [Forall([name: str] : Implies(Thing(?name), Person(?name)))]\n\n    :param theory: The theory to generate implications for\n    :return: A new theory with implications\n    \"\"\"\n    new_sentences = sentences_from_predicate_hierarchy(theory)\n    new_sg = SentenceGroup(name=\"Inferred\", sentences=new_sentences)\n    sgs = (theory.sentence_groups or []) + [new_sg]\n    return Theory(\n        name=theory.name,\n        predicate_definitions=theory.predicate_definitions,\n        sentence_groups=sgs,\n    )\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.as_prolog","title":"<code>as_prolog(sentence, config=None, depth=0, translate=False, strict=True)</code>","text":"<p>Convert a sentence to Prolog syntax.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n&gt;&gt;&gt; X = Variable(\"x\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"y\", \"str\")\n&gt;&gt;&gt; A = Term(\"A\", X, Y)\n&gt;&gt;&gt; B = Term(\"B\", X, Y, \"foo\", 5)\n&gt;&gt;&gt; as_prolog(A)\n'a(X, Y)'\n\n&gt;&gt;&gt; as_prolog(Forall([X], A))\n'a(X, Y)'\n\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; E = Term(\"E\")\n&gt;&gt;&gt; print(as_prolog(Implies(C, D)))\nd :- c.\n\n&gt;&gt;&gt; print(as_prolog(Implies(C &amp; E, D)))\nd :- c, e.\n\n&gt;&gt;&gt; print(as_prolog(Implies(And(D, E), C)))\nc :- d, e.\n\n&gt;&gt;&gt; print(as_prolog(Implies(Or(D, E), C)))\nc :- (d; e).\n\n&gt;&gt;&gt; config = PrologConfig(disjunctive_datalog=True)\n&gt;&gt;&gt; print(as_prolog(Implies(And(E), C | D), config, depth=1))\nc; d :- e.\n\n&gt;&gt;&gt; config.negation_symbol = '!'\n&gt;&gt;&gt; as_prolog(~A, config, depth=1)\n'! (a(X, Y))'\n\n&gt;&gt;&gt; print(as_prolog(Term('lt', X, 5)))\nX &lt; 5\n\n&gt;&gt;&gt; print(as_prolog(Term('eq', X, 5)))\nX == 5\n\n&gt;&gt;&gt; print(as_prolog(Implies(And(C, Exists([X], Term(\"A\", X))), D)))\nd :- c, a(X).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Union[Sentence, List[Sentence]]</code> <p>the sentence to render</p> required <code>config</code> <code>Optional[PrologConfig]</code> <code>None</code> <code>depth</code> <code>0</code> <code>translate</code> <code>False</code> <code>strict</code> <code>True</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_prolog(sentence: Union[Sentence, List[Sentence]], config: Optional[PrologConfig]=None, depth=0, translate=False, strict=True) -&gt; str:\n    \"\"\"\n    Convert a sentence to Prolog syntax.\n\n        &gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n        &gt;&gt;&gt; X = Variable(\"x\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"y\", \"str\")\n        &gt;&gt;&gt; A = Term(\"A\", X, Y)\n        &gt;&gt;&gt; B = Term(\"B\", X, Y, \"foo\", 5)\n        &gt;&gt;&gt; as_prolog(A)\n        'a(X, Y)'\n\n        &gt;&gt;&gt; as_prolog(Forall([X], A))\n        'a(X, Y)'\n\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; E = Term(\"E\")\n        &gt;&gt;&gt; print(as_prolog(Implies(C, D)))\n        d :- c.\n\n        &gt;&gt;&gt; print(as_prolog(Implies(C &amp; E, D)))\n        d :- c, e.\n\n        &gt;&gt;&gt; print(as_prolog(Implies(And(D, E), C)))\n        c :- d, e.\n\n        &gt;&gt;&gt; print(as_prolog(Implies(Or(D, E), C)))\n        c :- (d; e).\n\n        &gt;&gt;&gt; config = PrologConfig(disjunctive_datalog=True)\n        &gt;&gt;&gt; print(as_prolog(Implies(And(E), C | D), config, depth=1))\n        c; d :- e.\n\n        &gt;&gt;&gt; config.negation_symbol = '!'\n        &gt;&gt;&gt; as_prolog(~A, config, depth=1)\n        '! (a(X, Y))'\n\n        &gt;&gt;&gt; print(as_prolog(Term('lt', X, 5)))\n        X &lt; 5\n\n        &gt;&gt;&gt; print(as_prolog(Term('eq', X, 5)))\n        X == 5\n\n        &gt;&gt;&gt; print(as_prolog(Implies(And(C, Exists([X], Term(\"A\", X))), D)))\n        d :- c, a(X).\n\n    :param sentence: the sentence to render\n    :param config:\n    :param depth:\n    :param translate:\n    :param strict:\n    :return:\n    \"\"\"\n    if isinstance(sentence, list):\n        return \"\\n\".join(as_prolog(s, config, depth=depth) for s in sentence)\n    if not config:\n        config = PrologConfig()\n    def _paren(s: str) -&gt; str:\n        if config.allow_nesting:\n            return f\"({s})\"\n        return s\n    if translate:\n        rules = to_horn_rules(sentence, allow_disjunctions_in_head=config.disjunctive_datalog)\n        return \"\\n\".join(as_prolog(s, config, depth=depth) for s in rules)\n    if isinstance(sentence, Forall):\n        sentence = sentence.sentence\n    if depth == 0 and not isinstance(sentence, (Implies, Term)):\n        raise NotInProfileError(f\"Top level sentence must be an implication or term {sentence}, got {type(sentence)}\")\n    if isinstance(sentence, Exists) and depth &gt; 0:\n        sentence = sentence.sentence\n    if isinstance(sentence, And):\n        if not sentence.operands:\n            return \"true\"\n        return f\"{', '.join(as_prolog(op, config, depth+1) for op in sentence.operands)}\"\n    if isinstance(sentence, Or):\n        if not sentence.operands:\n            return \"fail\"\n        return _paren(f\"{'; '.join(as_prolog(op, config, depth+1) for op in sentence.operands)}\")\n    if isinstance(sentence, (Not, NegationAsFailure)):\n        negated_clause = _paren(as_prolog(sentence.negated, config, depth+1))\n        return f\"{config.negation_symbol} {negated_clause}\"\n    if isinstance(sentence, Term):\n        if not config.allow_skolem_terms:\n            for t in sentence.values:\n                if isinstance(t, Term) and t.predicate.startswith(\"sk__\"):\n                    raise NotInProfileError(f\"Skolem term not supported: {sentence}\")\n        vals = list(sentence.bindings.values())\n        def _render_arg(v: Any) -&gt; str:\n            if v is None:\n                if depth &gt; 0:\n                    return \"_\"\n                else:\n                    return config.null_term\n            if isinstance(v, Variable):\n                if config.use_lowercase_vars:\n                    return v.name\n                return v.name.capitalize()\n            if isinstance(v, Term):\n                if not config.allow_function_terms:\n                    raise ValueError(f\"Nested term not supported: {v}\")\n                return as_prolog(v, config, depth+1)\n            if config.double_quote_strings:\n                return json.dumps(v)\n            else:\n                return repr(v)\n        p = sentence.predicate\n        operator_map = {k: v for k, v in NAME_TO_INFIX_OP.items()}\n        if config.operator_map:\n            operator_map.update(config.operator_map)\n        if p in operator_map:\n            p = operator_map[p]\n            if len(vals) == 2:\n                return f\"{_render_arg(vals[0])} {p} {_render_arg(vals[1])}\"\n            elif len(vals) == 1:\n                return f\"{p} {_render_arg(vals[0])}\"\n            else:\n                raise ValueError(f\"Operator {p} only supports 1 or 2 arguments\")\n        else:\n            if config.use_uppercase_predicates:\n                p = p.capitalize()\n            if config.use_uppercase_predicates is False:\n                p = p.lower()\n            if not vals and not config.include_parens_for_zero_args:\n                return p\n            else:\n                return f\"{p}({', '.join([_render_arg(v) for v in vals])})\"\n    if not isinstance(sentence, Implies):\n        raise NotInProfileError(f\"Unsupported sentence {sentence}\")\n    # assumption: generation a (head :- body) implication\n    if isinstance(sentence.consequent, Or) and len(sentence.consequent.operands) &gt; 1:\n        if not config.disjunctive_datalog:\n            raise NotInProfileError(f\"Disjunctions on LHS not allowed {sentence}\")\n    if isinstance(sentence.consequent, And):\n        raise NotInProfileError(f\"Conjunctions on LHS not allowed {sentence}\\n\"\n                                \"Transform using simplify_prolog_transform first\")\n    # check for unbound variables\n    body_vars = []\n    # eliminate Exists\n    antecedent_list = [t.sentence if isinstance(t, Exists) else t for t in conjunction_as_list(sentence.antecedent)]\n    for body_term in antecedent_list:\n        if not isinstance(body_term, Term):\n            # TODO: this currently assumes disjunctions are unrolled from body\n            # raise NotInProfileError(f\"Body must be a term {sentence}\")\n            continue\n        body_vars.extend(body_term.variable_names)\n    for head_term in disjunction_as_list(sentence.consequent):\n        if isinstance(head_term, Not):\n            continue\n        if not isinstance(head_term, Term):\n            raise NotInProfileError(f\"Head must be a term, got: {type(head_term)} in {sentence}\")\n        head_vars = head_term.variable_names\n        for v in head_vars:\n            if v not in body_vars:\n                raise NotInProfileError(f\"Variable {v} in head not in body {sentence}\")\n\n    head = as_prolog(sentence.consequent, config, depth+1)\n    body = as_prolog(sentence.antecedent, config, depth+1)\n    if head.startswith(\"(\") and head.endswith(\")\"):\n        head = head[1:-1]\n    if body == \"true\":\n        return f\"{head}.\"\n    if head == \"fail\":\n        return f\":- {body}.\"\n    return f\"{head} :- {body}.\"\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.simple_prolog_transform","title":"<code>simple_prolog_transform(sentence, strict=False)</code>","text":"<p>Transform a sentence to a list of sentences suitable for Prolog.</p> <p>The resulting sentences will all be quantified Body -&gt; Head implications, where Body is a conjunction</p> <pre><code>&gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; simple_prolog_transform(A &gt;&gt; B)\n[Forall([] : Implies(And(A), B))]\n\n&gt;&gt;&gt; simple_prolog_transform(Iff(A, B))\n[Forall([] : Implies(And(B), A)), Forall([] : Implies(And(A), B))]\n\n&gt;&gt;&gt; for s in simple_prolog_transform(Iff(A, B)):\n...     print(as_prolog(s))\na :- b.\nb :- a.\n\n&gt;&gt;&gt; for s in simple_prolog_transform((And(A) &amp; And(B)) &gt;&gt; C):\n...     print(as_prolog(s))\nc :- a, b.\n\n&gt;&gt;&gt; for s in simple_prolog_transform((Or(A,B)) &gt;&gt; C):\n...     print(as_prolog(s))\nc :- b.\nc :- a.\n\n&gt;&gt;&gt; for s in simple_prolog_transform(C &gt;&gt; (A &amp; B)):\n...     print(as_prolog(s))\nb :- c.\na :- c.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>strict</code> <code>False</code> <p>Returns:</p> Type Description <code>List[Sentence]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def simple_prolog_transform(sentence: Sentence, strict=False) -&gt; List[Sentence]:\n    \"\"\"\n    Transform a sentence to a list of sentences suitable for Prolog.\n\n    The resulting sentences will all be quantified Body -&gt; Head implications,\n    where Body is a conjunction\n\n        &gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; simple_prolog_transform(A &gt;&gt; B)\n        [Forall([] : Implies(And(A), B))]\n\n        &gt;&gt;&gt; simple_prolog_transform(Iff(A, B))\n        [Forall([] : Implies(And(B), A)), Forall([] : Implies(And(A), B))]\n\n        &gt;&gt;&gt; for s in simple_prolog_transform(Iff(A, B)):\n        ...     print(as_prolog(s))\n        a :- b.\n        b :- a.\n\n        &gt;&gt;&gt; for s in simple_prolog_transform((And(A) &amp; And(B)) &gt;&gt; C):\n        ...     print(as_prolog(s))\n        c :- a, b.\n\n        &gt;&gt;&gt; for s in simple_prolog_transform((Or(A,B)) &gt;&gt; C):\n        ...     print(as_prolog(s))\n        c :- b.\n        c :- a.\n\n        &gt;&gt;&gt; for s in simple_prolog_transform(C &gt;&gt; (A &amp; B)):\n        ...     print(as_prolog(s))\n        b :- c.\n        a :- c.\n\n\n\n\n    :param sentence:\n    :param strict:\n    :return:\n    \"\"\"\n    def not_in_profile(s: Sentence) -&gt; None:\n        if strict:\n            raise NotInProfileError(f\"Unsupported sentence {s}\")\n    sentence = transform_sentence(sentence, reduce_singleton)\n    sentence = transform_sentence(sentence, eliminate_iff)\n    if not isinstance(sentence, Forall):\n        sentence = Forall([], sentence)\n    # sentence = transform_sentence(sentence, eliminate_implies)\n    outer = sentence\n    sentence = sentence.sentence\n    if isinstance(sentence, And):\n        # expand And to multiple sentences\n        sentences = [op for op in sentence.operands]\n    else:\n        sentences = [sentence]\n    new_sentences: List[Sentence] = []\n    while sentences:\n        sentence = sentences.pop()\n        if isinstance(sentence, Term):\n            new_sentences.append(sentence)\n            continue\n        if isinstance(sentence, Implied):\n            sentences.append(Implies(sentence.operands[1], sentence.operands[0]))\n        if isinstance(sentence, Iff):\n            sentences.append(Implies(sentence.left, sentence.right))\n            sentences.append(Implies(sentence.right, sentence.left))\n        if not isinstance(sentence, Implies):\n            not_in_profile(sentence)\n            continue\n        body = sentence.antecedent\n        head = sentence.consequent\n        if isinstance(head, And):\n            sentences.extend([Implies(body, op) for op in head.operands])\n            continue\n        if not isinstance(head, Term):\n            not_in_profile(sentence)\n            continue\n        if isinstance(body, Or):\n            sentences.extend([Implies(op, head) for op in body.operands])\n            continue\n        if isinstance(body, Term):\n            body = And(body)\n        if not isinstance(body, And):\n            # note: does not check members of And\n            not_in_profile(sentence)\n            continue\n        new_sentences.append(Implies(body, head))\n    return [Forall(outer.variables, s) for s in new_sentences]\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.as_fol","title":"<code>as_fol(sentence, config=None)</code>","text":"<p>Convert a sentence to first order logic syntax.</p> <p>from typedlogic import Term, Variable, Forall X = Variable(\"x\", \"str\") Y = Variable(\"y\", \"str\") A = Term(\"A\", X) B = Term(\"B\", X) print(as_fol(Forall([X], A &gt;&gt; B))) \u2200[x:str]. A(x) \u2192 B(x) print(as_fol(Forall([X], Iff(A, B)))) \u2200[x:str]. A(x) \u2194 B(x) print(as_fol(Exists([X], A &amp; B))) \u2203[x:str]. A(x) \u2227 B(x) print(as_fol(A|B)) (A(x) \u2228 B(x))</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> required <code>config</code> <code>Optional[PrologConfig]</code> <code>None</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_fol(sentence, config: Optional[PrologConfig]=None) -&gt; str:\n    \"\"\"\n    Convert a sentence to first order logic syntax.\n\n    &gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n    &gt;&gt;&gt; X = Variable(\"x\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"y\", \"str\")\n    &gt;&gt;&gt; A = Term(\"A\", X)\n    &gt;&gt;&gt; B = Term(\"B\", X)\n    &gt;&gt;&gt; print(as_fol(Forall([X], A &gt;&gt; B)))\n    \u2200[x:str]. A(x) \u2192 B(x)\n    &gt;&gt;&gt; print(as_fol(Forall([X], Iff(A, B))))\n    \u2200[x:str]. A(x) \u2194 B(x)\n    &gt;&gt;&gt; print(as_fol(Exists([X], A &amp; B)))\n    \u2203[x:str]. A(x) \u2227 B(x)\n    &gt;&gt;&gt; print(as_fol(A|B))\n    (A(x) \u2228 B(x))\n\n    :param sentence:\n    :param config:\n    :return:\n    \"\"\"\n    if not config:\n        config = PrologConfig(use_lowercase_vars=True, use_uppercase_predicates=None)\n    if isinstance(sentence, (Exists, Forall)):\n        qsym = \"\u2200\" if isinstance(sentence, Forall) else \"\u2203\"\n        arg_exprs = [f\"{v.name}:{v.domain}\" if v.domain else v.name for v in sentence.variables]\n        args = \" \".join(arg_exprs)\n        return f\"{qsym}[{args}]. {as_fol(sentence.sentence, config)}\"\n    if isinstance(sentence, And):\n        return f\"{' \u2227 '.join(as_fol(op, config) for op in sentence.operands)}\"\n    if isinstance(sentence, Or):\n        return f\"({' \u2228 '.join(as_fol(op, config) for op in sentence.operands)})\"\n    if isinstance(sentence, Not):\n        return f\"\u00ac{as_fol(sentence.negated, config)}\"\n    if isinstance(sentence, Implies):\n        return f\"{as_fol(sentence.antecedent, config)} \u2192 {as_fol(sentence.consequent, config)}\"\n    if isinstance(sentence, Implied):\n        return f\"{as_fol(sentence.operands[1], config)} \u2190 {as_fol(sentence.operands[0], config)}\"\n    if isinstance(sentence, Iff):\n        return f\"{as_fol(sentence.left, config)} \u2194 {as_fol(sentence.right, config)}\"\n    if isinstance(sentence, Term):\n        vals = list(sentence.bindings.values())\n        def _render_arg(v: Any) -&gt; str:\n            if isinstance(v, Variable):\n                if config.use_lowercase_vars:\n                    return v.name\n                return v.name.capitalize()\n            if config.double_quote_strings:\n                return json.dumps(v)\n            else:\n                return repr(v)\n        p = sentence.predicate\n        operator_map = {k: v for k, v in NAME_TO_INFIX_OP.items()}\n        if config.operator_map:\n            operator_map.update(config.operator_map)\n        if p in operator_map:\n            p = operator_map[p]\n            if len(vals) == 2:\n                return f\"{_render_arg(vals[0])} {p} {_render_arg(vals[1])}\"\n            elif len(vals) == 1:\n                return f\"{p} {_render_arg(vals[0])}\"\n            else:\n                raise ValueError(f\"Operator {p} only supports 1 or 2 arguments\")\n        else:\n            if config.use_uppercase_predicates:\n                p = p.capitalize()\n            if config.use_uppercase_predicates is False:\n                p = p.lower()\n            if not vals and not config.include_parens_for_zero_args:\n                return p\n            else:\n                return f\"{p}({', '.join([_render_arg(v) for v in vals])})\"\n    return \"\"\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.as_tptp","title":"<code>as_tptp(sentence, config=None, depth=0)</code>","text":"<p>Convert a sentence to TPTP syntax.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> <p>The sentence to convert</p> required <code>config</code> <code>Optional[PrologConfig]</code> <p>Configuration options (optional)</p> <code>None</code> <code>depth</code> <p>Current depth in the sentence structure (used for indentation)</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>TPTP representation of the sentence  Examples: &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; P = Term(\"P\", X) &gt;&gt;&gt; Q = Term(\"Q\", X, Y) &gt;&gt;&gt; R = Term(\"R\", Y) &gt;&gt;&gt; print(as_tptp(Forall([X], Implies(P, Q)))) ! [X] : (p(X) =&gt; q(X, Y)) &gt;&gt;&gt; print(as_tptp(Exists([X, Y], And(P, Q)))) ? [X, Y] : (p(X) &amp; q(X, Y)) &gt;&gt;&gt; print(as_tptp(Or(P, Not(R)))) (p(X) | ~r(Y))</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_tptp(sentence: Sentence, config: Optional[PrologConfig] = None, depth=0) -&gt; str:\n    \"\"\"\n    Convert a sentence to TPTP syntax.\n\n    :param sentence: The sentence to convert\n    :param config: Configuration options (optional)\n    :param depth: Current depth in the sentence structure (used for indentation)\n    :return: TPTP representation of the sentence\n\n    Examples:\n    &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; P = Term(\"P\", X)\n    &gt;&gt;&gt; Q = Term(\"Q\", X, Y)\n    &gt;&gt;&gt; R = Term(\"R\", Y)\n    &gt;&gt;&gt; print(as_tptp(Forall([X], Implies(P, Q))))\n    ! [X] : (p(X) =&gt; q(X, Y))\n    &gt;&gt;&gt; print(as_tptp(Exists([X, Y], And(P, Q))))\n    ? [X, Y] : (p(X) &amp; q(X, Y))\n    &gt;&gt;&gt; print(as_tptp(Or(P, Not(R))))\n    (p(X) | ~r(Y))\n    \"\"\"\n    if not config:\n        config = PrologConfig(use_lowercase_vars=False, use_uppercase_predicates=False)\n\n    def format_var(v: Variable) -&gt; str:\n        return v.name if config.use_lowercase_vars else v.name.capitalize()\n\n    def format_predicate(p: str) -&gt; str:\n        return p.lower() if config.use_uppercase_predicates is False else p\n\n    if isinstance(sentence, (Forall, Exists)):\n        quantifier = \"!\" if isinstance(sentence, Forall) else \"?\"\n        vars = \", \".join(format_var(v) for v in sentence.variables)\n        return f\"{quantifier} [{vars}] : {as_tptp(sentence.sentence, config, depth)}\"\n\n    elif isinstance(sentence, And):\n        return f\"({' &amp; '.join(as_tptp(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Or):\n        return f\"({' | '.join(as_tptp(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Not):\n        return f\"~{as_tptp(sentence.negated, config, depth + 1)}\"\n\n    elif isinstance(sentence, Implies):\n        return f\"({as_tptp(sentence.antecedent, config, depth + 1)} =&gt; {as_tptp(sentence.consequent, config, depth + 1)})\"\n\n    elif isinstance(sentence, Iff):\n        return f\"({as_tptp(sentence.left, config, depth + 1)} &lt;=&gt; {as_tptp(sentence.right, config, depth + 1)})\"\n\n    elif isinstance(sentence, Term):\n        predicate = format_predicate(sentence.predicate)\n        args = \", \".join(format_var(v) if isinstance(v, Variable) else repr(v) for v in sentence.bindings.values())\n        return f\"{predicate}({args})\"\n\n    else:\n        raise ValueError(f\"Unsupported sentence type: {type(sentence)}\")\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.tptp_problem","title":"<code>tptp_problem(theory, conjecture=None)</code>","text":"<p>Generate a complete TPTP problem from a theory and an optional conjecture.</p> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> <p>The theory containing axioms</p> required <code>conjecture</code> <code>Optional[Sentence]</code> <p>An optional conjecture to prove</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>TPTP representation of the problem  Example: &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; theory = Theory( ...     name=\"example\", ...     predicate_definitions=[ ...         PredicateDefinition(\"P\", {\"x\": \"str\"}), ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}), ...     ], ...     sentence_groups=[ ...         SentenceGroup(\"axioms\", sentences=[ ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) ...         ]) ...     ] ... ) &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) &gt;&gt;&gt; print(tptp_problem(theory, conjecture)) % Problem: example fof(axiom1, axiom, ! [X] : (p(X) =&gt; q(X, Y))). fof(conjecture, conjecture, ! [X, Y] : (p(X) =&gt; q(X, Y))).</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def tptp_problem(theory: Theory, conjecture: Optional[Sentence] = None) -&gt; str:\n    \"\"\"\n    Generate a complete TPTP problem from a theory and an optional conjecture.\n\n    :param theory: The theory containing axioms\n    :param conjecture: An optional conjecture to prove\n    :return: TPTP representation of the problem\n\n    Example:\n    &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; theory = Theory(\n    ...     name=\"example\",\n    ...     predicate_definitions=[\n    ...         PredicateDefinition(\"P\", {\"x\": \"str\"}),\n    ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}),\n    ...     ],\n    ...     sentence_groups=[\n    ...         SentenceGroup(\"axioms\", sentences=[\n    ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    ...         ])\n    ...     ]\n    ... )\n    &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    &gt;&gt;&gt; print(tptp_problem(theory, conjecture))\n    % Problem: example\n    fof(axiom1, axiom, ! [X] : (p(X) =&gt; q(X, Y))).\n    fof(conjecture, conjecture, ! [X, Y] : (p(X) =&gt; q(X, Y))).\n    \"\"\"\n    lines = [f\"% Problem: {theory.name}\"]\n\n    for i, sentence in enumerate(theory.sentences, 1):\n        lines.append(f\"fof(axiom{i}, axiom, {as_tptp(sentence)}).\")\n\n    if conjecture:\n        lines.append(f\"fof(conjecture, conjecture, {as_tptp(conjecture)}).\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.as_prover9","title":"<code>as_prover9(sentence, config=None, depth=0)</code>","text":"<p>Convert a sentence to Prover9 syntax.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> <p>The sentence to convert</p> required <code>config</code> <code>Optional[PrologConfig]</code> <p>Configuration options (optional)</p> <code>None</code> <code>depth</code> <p>Current depth in the sentence structure (used for indentation)</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>Prover9 representation of the sentence  Examples: &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; P = Term(\"P\", X) &gt;&gt;&gt; Q = Term(\"Q\", X, Y) &gt;&gt;&gt; R = Term(\"R\", Y) &gt;&gt;&gt; print(as_prover9(Forall([X], Implies(P, Q)))) all x ((P(x) -&gt; Q(x, y))) &gt;&gt;&gt; print(as_prover9(Exists([X, Y], And(P, Q)))) exists x y ((P(x) &amp; Q(x, y))) &gt;&gt;&gt; print(as_prover9(Or(P, Not(R)))) (P(x) | - ( R(y) )) &gt;&gt;&gt; print(as_prover9(Term(\"S\", \"hello\"))) S(s_hello)</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_prover9(sentence: Sentence, config: Optional[PrologConfig] = None, depth=0) -&gt; str:\n    \"\"\"\n    Convert a sentence to Prover9 syntax.\n\n    :param sentence: The sentence to convert\n    :param config: Configuration options (optional)\n    :param depth: Current depth in the sentence structure (used for indentation)\n    :return: Prover9 representation of the sentence\n\n    Examples:\n    &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; P = Term(\"P\", X)\n    &gt;&gt;&gt; Q = Term(\"Q\", X, Y)\n    &gt;&gt;&gt; R = Term(\"R\", Y)\n    &gt;&gt;&gt; print(as_prover9(Forall([X], Implies(P, Q))))\n    all x ((P(x) -&gt; Q(x, y)))\n    &gt;&gt;&gt; print(as_prover9(Exists([X, Y], And(P, Q))))\n    exists x y ((P(x) &amp; Q(x, y)))\n    &gt;&gt;&gt; print(as_prover9(Or(P, Not(R))))\n    (P(x) | - ( R(y) ))\n    &gt;&gt;&gt; print(as_prover9(Term(\"S\", \"hello\")))\n    S(s_hello)\n    \"\"\"\n    if not config:\n        config = PrologConfig(use_lowercase_vars=True, use_uppercase_predicates=False)\n\n    def format_var(v: Variable) -&gt; str:\n        return v.name.lower()\n\n    def format_predicate(p: str) -&gt; str:\n        return p.upper() if config.use_uppercase_predicates else p\n\n    def format_value(v: Any) -&gt; str:\n        if isinstance(v, str):\n            # Convert string to a valid Prover9 constant\n            return f\"s_{v.replace(' ', '_')}\"\n        elif isinstance(v, int):\n            return str(v)\n        elif isinstance(v, float):\n            # Prover9 doesn't support floats directly, so we convert to a fraction\n            from fractions import Fraction\n            frac = Fraction(v).limit_denominator()\n            return f\"rational({frac.numerator},{frac.denominator})\"\n        elif v is None:\n            return \"null\"\n        else:\n            return str(v)\n\n    if isinstance(sentence, (Forall, Exists)):\n        quantifier = \"all\" if isinstance(sentence, Forall) else \"exists\"\n        vars = \" \".join(format_var(v) for v in sentence.variables)\n        return f\"{quantifier} {vars} ({as_prover9(sentence.sentence, config, depth)})\"\n\n    elif isinstance(sentence, And):\n        return f\"({' &amp; '.join(as_prover9(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Xor):\n        return as_prover9(expand_xor(sentence), config, depth)\n\n    elif isinstance(sentence, ExactlyOne):\n        return as_prover9(expand_exactly_one(sentence), config, depth)\n\n    elif isinstance(sentence, Or):\n        return f\"({' | '.join(as_prover9(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Not):\n        return f\"- ( {as_prover9(sentence.negated, config, depth + 1)} )\"\n\n    elif isinstance(sentence, Implies):\n        return f\"({as_prover9(sentence.antecedent, config, depth + 1)} -&gt; {as_prover9(sentence.consequent, config, depth + 1)})\"\n\n    elif isinstance(sentence, Implied):\n        return f\"({as_prover9(sentence.consequent, config, depth + 1)} &lt;- {as_prover9(sentence.antecedent, config, depth + 1)})\"\n\n    elif isinstance(sentence, Iff):\n        return f\"({as_prover9(sentence.left, config, depth + 1)} &lt;-&gt; {as_prover9(sentence.right, config, depth + 1)})\"\n\n\n    elif isinstance(sentence, Term):\n        predicate = format_predicate(sentence.predicate)\n        if not sentence.bindings:\n            return predicate\n        args = \", \".join(\n            format_var(v) if isinstance(v, Variable) else format_value(v) for v in sentence.bindings.values())\n        return f\"{predicate}({args})\"\n\n    else:\n        raise ValueError(f\"Unsupported sentence type: {type(sentence)}\")\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.prover9_problem","title":"<code>prover9_problem(theory, conjecture=None)</code>","text":"<p>Generate a complete Prover9 problem from a theory and an optional conjecture.</p> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> <p>The theory containing axioms</p> required <code>conjecture</code> <code>Optional[Sentence]</code> <p>An optional conjecture to prove</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Prover9 representation of the problem  Example: &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; theory = Theory( ...     name=\"example\", ...     predicate_definitions=[ ...         PredicateDefinition(\"P\", {\"x\": \"str\"}), ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}), ...     ], ...     sentence_groups=[ ...         SentenceGroup(\"axioms\", sentences=[ ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) ...         ]) ...     ] ... ) &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) &gt;&gt;&gt; print(prover9_problem(theory, conjecture)) formulas(assumptions). all x ((P(x) -&gt; Q(x, y))). end_of_list.  formulas(goals). all x y ((P(x) -&gt; Q(x, y))). end_of_list. Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def prover9_problem(theory: Theory, conjecture: Optional[Sentence] = None) -&gt; str:\n    \"\"\"\n    Generate a complete Prover9 problem from a theory and an optional conjecture.\n\n    :param theory: The theory containing axioms\n    :param conjecture: An optional conjecture to prove\n    :return: Prover9 representation of the problem\n\n    Example:\n    &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; theory = Theory(\n    ...     name=\"example\",\n    ...     predicate_definitions=[\n    ...         PredicateDefinition(\"P\", {\"x\": \"str\"}),\n    ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}),\n    ...     ],\n    ...     sentence_groups=[\n    ...         SentenceGroup(\"axioms\", sentences=[\n    ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    ...         ])\n    ...     ]\n    ... )\n    &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    &gt;&gt;&gt; print(prover9_problem(theory, conjecture))\n    formulas(assumptions).\n        all x ((P(x) -&gt; Q(x, y))).\n    end_of_list.\n    &lt;BLANKLINE&gt;\n    formulas(goals).\n        all x y ((P(x) -&gt; Q(x, y))).\n    end_of_list.\n    \"\"\"\n    lines = []\n\n    # Assumptions (axioms)\n    lines.append(\"formulas(assumptions).\")\n    for sentence in theory.sentences:\n        lines.append(f\"    {as_prover9(sentence)}.\")\n    lines.append(\"end_of_list.\")\n    lines.append(\"\")\n\n    # Goals (conjecture)\n    if conjecture:\n        lines.append(\"formulas(goals).\")\n        lines.append(f\"    {as_prover9(conjecture)}.\")\n        lines.append(\"end_of_list.\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.transform_sentence_chained","title":"<code>transform_sentence_chained(sentence, rules)</code>","text":"<p>Transform a sentence using a chain of rules.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; sentence = A | (B &amp; C)\n&gt;&gt;&gt; negate_conjunctions = lambda s: Or(*[~op for op in s.operands]) if isinstance(s, And) else s\n&gt;&gt;&gt; reduce_singletons = lambda s: s.operands[0] if isinstance(s, And) and len(s.operands) == 1 else s\n&gt;&gt;&gt; transform_sentence_chained(sentence, [negate_conjunctions, reduce_singletons])\nOr(A, Or(Not(B), Not(C)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>rules</code> <code>Iterable[Callable[[Sentence], Sentence]]</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def transform_sentence_chained(sentence: Sentence, rules: Iterable[Callable[[Sentence], Sentence]]) -&gt; Sentence:\n    \"\"\"\n    Transform a sentence using a chain of rules.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; sentence = A | (B &amp; C)\n        &gt;&gt;&gt; negate_conjunctions = lambda s: Or(*[~op for op in s.operands]) if isinstance(s, And) else s\n        &gt;&gt;&gt; reduce_singletons = lambda s: s.operands[0] if isinstance(s, And) and len(s.operands) == 1 else s\n        &gt;&gt;&gt; transform_sentence_chained(sentence, [negate_conjunctions, reduce_singletons])\n        Or(A, Or(Not(B), Not(C)))\n\n    :param sentence:\n    :param rules:\n    :return:\n    \"\"\"\n    for rule in rules:\n        sentence = transform_sentence(sentence, rule)\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.transform_sentence","title":"<code>transform_sentence(sentence, rule, varmap=None)</code>","text":"<p>Transform a sentence recursively using a rule.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; sentence = A | (B &amp; (C | ~D))\n&gt;&gt;&gt; assert transform_sentence(sentence, lambda s: s) == sentence\n\n&gt;&gt;&gt; def negate_conjunctions(sentence: Sentence) -&gt; Optional[Sentence]:\n...     if isinstance(sentence, And):\n...         return Or(*[~op for op in sentence.operands])\n...     return None\n&gt;&gt;&gt; transform_sentence(B &amp; C, negate_conjunctions)\nOr(Not(B), Not(C))\n&gt;&gt;&gt; transform_sentence(A | (B &amp; C), negate_conjunctions)\nOr(A, Or(Not(B), Not(C)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>rule</code> <code>Callable[[Sentence], Sentence]</code> required <code>varmap</code> <code>Optional[Dict[str, Variable]]</code> <code>None</code> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def transform_sentence(sentence: Sentence, rule: Callable[[Sentence], Sentence], varmap: Optional[Dict[str, Variable]] = None) -&gt; Sentence:\n    \"\"\"\n    Transform a sentence recursively using a rule.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; sentence = A | (B &amp; (C | ~D))\n        &gt;&gt;&gt; assert transform_sentence(sentence, lambda s: s) == sentence\n\n        &gt;&gt;&gt; def negate_conjunctions(sentence: Sentence) -&gt; Optional[Sentence]:\n        ...     if isinstance(sentence, And):\n        ...         return Or(*[~op for op in sentence.operands])\n        ...     return None\n        &gt;&gt;&gt; transform_sentence(B &amp; C, negate_conjunctions)\n        Or(Not(B), Not(C))\n        &gt;&gt;&gt; transform_sentence(A | (B &amp; C), negate_conjunctions)\n        Or(A, Or(Not(B), Not(C)))\n\n    :param sentence:\n    :param rule:\n    :param varmap:\n    :return:\n    \"\"\"\n    varmap = varmap or {}\n    new_sentence = rule(sentence)\n    if new_sentence:\n        if sentence != new_sentence:\n            sentence = transform_sentence(new_sentence, rule, varmap)\n        else:\n            sentence = new_sentence\n    if isinstance(sentence, QuantifiedSentence):\n        return type(sentence)(sentence.variables, transform_sentence(sentence.sentence, rule, varmap))\n    elif isinstance(sentence, BooleanSentence):\n        return type(sentence)(*[transform_sentence(op, rule, varmap) for op in sentence.operands])\n    elif isinstance(sentence, Term):\n        return sentence\n    elif isinstance(sentence, Extension):\n        return sentence.to_model_object()\n    else:\n        raise ValueError(f\"Unknown sentence type {type(sentence)} // {sentence}\")\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.replace_constants","title":"<code>replace_constants(sentence, constant_map)</code>","text":"<p>Replace constants in a sentence with new values.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; A = Term(\"A\", X)\n&gt;&gt;&gt; B = Term(\"B\", Y)\n&gt;&gt;&gt; C = Term(\"C\", Z)\n&gt;&gt;&gt; constant_map = {\"X\": \"foo\", \"Y\": \"bar\", \"Z\": \"baz\"}\n&gt;&gt;&gt; replace_constants(A &amp; B, constant_map)\nAnd(A(foo), B(bar))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>constant_map</code> <code>Dict[str, Any]</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def replace_constants(sentence: Sentence, constant_map: Dict[str, Any] ) -&gt; Sentence:\n    \"\"\"\n    Replace constants in a sentence with new values.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; A = Term(\"A\", X)\n        &gt;&gt;&gt; B = Term(\"B\", Y)\n        &gt;&gt;&gt; C = Term(\"C\", Z)\n        &gt;&gt;&gt; constant_map = {\"X\": \"foo\", \"Y\": \"bar\", \"Z\": \"baz\"}\n        &gt;&gt;&gt; replace_constants(A &amp; B, constant_map)\n        And(A(foo), B(bar))\n\n\n    :param sentence:\n    :param constant_map:\n    :return:\n    \"\"\"\n    if isinstance(sentence, QuantifiedSentence):\n        return type(sentence)(sentence.variables, replace_constants(sentence.sentence, constant_map))\n    elif isinstance(sentence, BooleanSentence):\n        return type(sentence)(*[replace_constants(op, constant_map) for op in sentence.operands])\n    elif isinstance(sentence, Term):\n        def _repl(v: Any) -&gt; Any:\n            if isinstance(v, Variable):\n                if v.name in constant_map:\n                    return constant_map[v.name]\n            return v\n        return Term(sentence.predicate, {k: _repl(v) for k, v in sentence.bindings.items()})\n    else:\n        raise ValueError(f\"Unknown sentence type {sentence}\")\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.reduce_singleton","title":"<code>reduce_singleton(sentence)</code>","text":"<p>Reduce singleton conjunctions and disjunctions in a sentence.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; sentence = And(A, B)\n&gt;&gt;&gt; reduce_singleton(sentence)\nAnd(A, B)\n&gt;&gt;&gt; reduce_singleton(And(A))\nA\n&gt;&gt;&gt; reduce_singleton(Or(A))\nA\n&gt;&gt;&gt; transform_sentence(And(A, Or(B), C), reduce_singleton)\nAnd(A, B, C)\n&gt;&gt;&gt; transform_sentence(And(And(A)), reduce_singleton)\nA\n&gt;&gt;&gt; transform_sentence(And(A, Or(Or(B)), And(Or(And(C)))), reduce_singleton)\nAnd(A, B, C)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def reduce_singleton(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Reduce singleton conjunctions and disjunctions in a sentence.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; sentence = And(A, B)\n        &gt;&gt;&gt; reduce_singleton(sentence)\n        And(A, B)\n        &gt;&gt;&gt; reduce_singleton(And(A))\n        A\n        &gt;&gt;&gt; reduce_singleton(Or(A))\n        A\n        &gt;&gt;&gt; transform_sentence(And(A, Or(B), C), reduce_singleton)\n        And(A, B, C)\n        &gt;&gt;&gt; transform_sentence(And(And(A)), reduce_singleton)\n        A\n        &gt;&gt;&gt; transform_sentence(And(A, Or(Or(B)), And(Or(And(C)))), reduce_singleton)\n        And(A, B, C)\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, And) and len(sentence.operands) == 1:\n        return sentence.operands[0]\n    if isinstance(sentence, Or) and len(sentence.operands) == 1:\n        return sentence.operands[0]\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.simplify","title":"<code>simplify(sentence)</code>","text":"<p>Simplify a sentence by reducing nested conjunctions and disjunctions.</p> <p>from typedlogic import And, Or, Variable, Term, Forall A = Term(\"A\") B = Term(\"B\") C = Term(\"C\") D = Term(\"D\") simplify(And(A, And(B, And(C, D)))) And(A, B, C, D) simplify(And(And(A))) A</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def simplify(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Simplify a sentence by reducing nested conjunctions and disjunctions.\n\n    &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n    &gt;&gt;&gt; A = Term(\"A\")\n    &gt;&gt;&gt; B = Term(\"B\")\n    &gt;&gt;&gt; C = Term(\"C\")\n    &gt;&gt;&gt; D = Term(\"D\")\n    &gt;&gt;&gt; simplify(And(A, And(B, And(C, D))))\n    And(A, B, C, D)\n    &gt;&gt;&gt; simplify(And(And(A)))\n    A\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, (And, Or)):\n        operands = [simplify(op) for op in sentence.operands]\n        if len(operands) == 1:\n            return simplify(operands[0])\n        op_type = type(sentence)\n        new_operands: List[Sentence] = []\n        for op in operands:\n            if isinstance(op, op_type):\n                if not isinstance(op, (And, Or)):\n                    raise AssertionError\n                new_operands.extend(op.operands)\n            else:\n                new_operands.append(op)\n        sentence = op_type(*new_operands)\n    if isinstance(sentence, (Exists, Forall)):\n        typ = type(sentence)\n        qs = sentence.sentence\n        if typ == type(qs):\n            if not isinstance(qs, (Exists, Forall)):\n                raise AssertionError\n            return typ(sentence.variables + qs.variables, simplify(qs.sentence))\n    if isinstance(sentence, Not):\n        negated = simplify(sentence.negated)\n        if isinstance(negated, Not):\n            return negated.negated\n        return Not(negated)\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.distribute_and_over_or","title":"<code>distribute_and_over_or(sentence)</code>","text":"<p>Distribute AND over OR in a sentence.</p> <p>A \u2228 (B1 \u2227 B2 \u2227 ... \u2227 Bn) \u2261 (A \u2228 B1) \u2227 (A \u2228 B2) \u2227 ... \u2227 (A \u2228 Bn)</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; distribute_and_over_or(A | (B &amp; C))\nAnd(Or(B, A), Or(C, A))\n&gt;&gt;&gt; distribute_and_over_or((A &amp; B) | (C &amp; D))\nAnd(Or(C, A), Or(D, A), Or(C, B), Or(D, B))\n\n&gt;&gt;&gt; distribute_and_over_or(A | And(B, C, D))\nAnd(Or(B, A), Or(C, A), Or(D, A))\n\n&gt;&gt;&gt; distribute_and_over_or(A | B)\nOr(A, B)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def distribute_and_over_or(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Distribute AND over OR in a sentence.\n\n    A \u2228 (B1 \u2227 B2 \u2227 ... \u2227 Bn) \u2261 (A \u2228 B1) \u2227 (A \u2228 B2) \u2227 ... \u2227 (A \u2228 Bn)\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; distribute_and_over_or(A | (B &amp; C))\n        And(Or(B, A), Or(C, A))\n        &gt;&gt;&gt; distribute_and_over_or((A &amp; B) | (C &amp; D))\n        And(Or(C, A), Or(D, A), Or(C, B), Or(D, B))\n\n        &gt;&gt;&gt; distribute_and_over_or(A | And(B, C, D))\n        And(Or(B, A), Or(C, A), Or(D, A))\n\n        &gt;&gt;&gt; distribute_and_over_or(A | B)\n        Or(A, B)\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Or):\n        return sentence\n    sentence = _distribute_sentence(sentence, And, Or)\n    # sentence = transform_sentence(sentence, reduce_singleton)\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.flatten_nested_conjunctions_and_disjunctions","title":"<code>flatten_nested_conjunctions_and_disjunctions(sentence)</code>","text":"<p>Flatten nested conjunctions and disjunctions in a sentence.</p> <p>Replace (A \u2227 B) \u2227 C with A \u2227 B \u2227 C Replace (A \u2228 B) \u2228 C with A \u2228 B \u2228 C</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; sentence = And(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n&gt;&gt;&gt; flatten_nested_conjunctions_and_disjunctions(sentence)\nAnd(Q(?X), R(?Y), S(?Z))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def flatten_nested_conjunctions_and_disjunctions(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Flatten nested conjunctions and disjunctions in a sentence.\n\n    Replace (A \u2227 B) \u2227 C with A \u2227 B \u2227 C\n    Replace (A \u2228 B) \u2228 C with A \u2228 B \u2228 C\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; sentence = And(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n        &gt;&gt;&gt; flatten_nested_conjunctions_and_disjunctions(sentence)\n        And(Q(?X), R(?Y), S(?Z))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, (And, Or)):\n        new_ops = []\n        for op in sentence.operands:\n            if isinstance(op, type(sentence)):\n                new_ops.extend(op.operands)\n            else:\n                new_ops.append(op)\n        return type(sentence)(*new_ops)\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.skolemize","title":"<code>skolemize(sentence, universal_vars=None, substitution_map=None)</code>","text":"<p>Skolemize a sentence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall, Exists\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; # no universal quantifiers\n&gt;&gt;&gt; skolemize(Exists([X], Term(\"P\", X)))\nP(sk__1)\n&gt;&gt;&gt; skolemize(Forall([X], Exists([Y], Term(\"P\", X, Y))))\nForall([X: str] : P(?X, sk__1(?X)))\n&gt;&gt;&gt; skolemize(Forall([X], Exists([Y, Z], Term(\"P\", X, Y, Z))))\nForall([X: str] : P(?X, sk__1(?X), sk__2(?X)))\n&gt;&gt;&gt; skolemize(Forall([X], And(Exists([Y, Z], Term(\"P\", X, Y, Z)), Exists([Y], Term(\"Q\", X, Y)))))\nForall([X: str] : And(P(?X, sk__1(?X), sk__2(?X)), Q(?X, sk__3(?X))))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>universal_vars</code> <code>Optional[List[Variable]]</code> <code>None</code> <code>substitution_map</code> <code>Optional[Dict[str, Term]]</code> <code>None</code> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def skolemize(sentence: Sentence, universal_vars: Optional[List[Variable]] = None, substitution_map: Optional[Dict[str, Term]] = None) -&gt; Sentence:\n    \"\"\"\n    Skolemize a sentence.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall, Exists\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; # no universal quantifiers\n        &gt;&gt;&gt; skolemize(Exists([X], Term(\"P\", X)))\n        P(sk__1)\n        &gt;&gt;&gt; skolemize(Forall([X], Exists([Y], Term(\"P\", X, Y))))\n        Forall([X: str] : P(?X, sk__1(?X)))\n        &gt;&gt;&gt; skolemize(Forall([X], Exists([Y, Z], Term(\"P\", X, Y, Z))))\n        Forall([X: str] : P(?X, sk__1(?X), sk__2(?X)))\n        &gt;&gt;&gt; skolemize(Forall([X], And(Exists([Y, Z], Term(\"P\", X, Y, Z)), Exists([Y], Term(\"Q\", X, Y)))))\n        Forall([X: str] : And(P(?X, sk__1(?X), sk__2(?X)), Q(?X, sk__3(?X))))\n\n\n    :param sentence:\n    :param universal_vars:\n    :param substitution_map:\n    :return:\n    \"\"\"\n    if substitution_map is None:\n        substitution_map = {}\n    if not universal_vars:\n        universal_vars = []\n    if isinstance(sentence, Forall):\n        return Forall(sentence.variables, skolemize(sentence.sentence, universal_vars + sentence.variables, substitution_map))\n    if isinstance(sentence, Exists):\n        vars_to_skolemize = [v for v in sentence.variables if v not in universal_vars]\n        n = len(substitution_map)\n        for v in vars_to_skolemize:\n            n += 1\n            skolem_term = Term(f\"sk__{n}\", *universal_vars)\n            substitution_map[v.name] = skolem_term\n        return skolemize(sentence.sentence, universal_vars, substitution_map)\n    if isinstance(sentence, BooleanSentence):\n        return type(sentence)(*[skolemize(op, universal_vars, substitution_map) for op in sentence.operands])\n    elif isinstance(sentence, Term):\n        return Term(sentence.predicate,\n                    {\n                        k: substitution_map[v.name] if isinstance(v, Variable) and v.name in substitution_map else v\n                        for k, v in sentence.bindings.items()\n                    })\n    else:\n        raise ValueError(f\"Unknown sentence type {type(sentence)} // {sentence}\")\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.to_cnf","title":"<code>to_cnf(sentence, skip_skolemization=False)</code>","text":"<p>Convert a sentence to conjunctive normal form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic.profiles import SortedLogic\n&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; S = Term(\"S\")\n&gt;&gt;&gt; T = Term(\"T\")\n&gt;&gt;&gt; to_cnf(P)\nP\n&gt;&gt;&gt; to_cnf(P &amp; Q)\nAnd(P, Q)\n&gt;&gt;&gt; to_cnf(P | Q)\nOr(P, Q)\n&gt;&gt;&gt; to_cnf(P &gt;&gt; Q)\nOr(Not(P), Q)\n&gt;&gt;&gt; to_cnf(~(P | Q) | R)\nAnd(Or(Not(P), R), Or(Not(Q), R))\n&gt;&gt;&gt; to_cnf((P &amp; Q) &gt;&gt; R)\nOr(Not(P), Not(Q), R)\n&gt;&gt;&gt; to_cnf(((P &amp; Q) | (R &amp; S)))\nAnd(Or(R, P), Or(S, P), Or(R, Q), Or(S, Q))\n&gt;&gt;&gt; to_cnf((P | Q) &amp; (R | S))\nAnd(Or(P, Q), Or(R, S))\n&gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n&gt;&gt;&gt; to_cnf(sentence)\nAnd(Or(Q(?X), S(?Z)), Or(R(?Y), S(?Z)))\n&gt;&gt;&gt; to_cnf(P &gt;&gt; (Q | R))\nOr(Not(P), Q, R)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>skip_skolemization</code> <code>False</code> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def to_cnf(sentence: Sentence, skip_skolemization=False) -&gt; Sentence:\n    \"\"\"\n    Convert a sentence to conjunctive normal form.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic.profiles import SortedLogic\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; S = Term(\"S\")\n        &gt;&gt;&gt; T = Term(\"T\")\n        &gt;&gt;&gt; to_cnf(P)\n        P\n        &gt;&gt;&gt; to_cnf(P &amp; Q)\n        And(P, Q)\n        &gt;&gt;&gt; to_cnf(P | Q)\n        Or(P, Q)\n        &gt;&gt;&gt; to_cnf(P &gt;&gt; Q)\n        Or(Not(P), Q)\n        &gt;&gt;&gt; to_cnf(~(P | Q) | R)\n        And(Or(Not(P), R), Or(Not(Q), R))\n        &gt;&gt;&gt; to_cnf((P &amp; Q) &gt;&gt; R)\n        Or(Not(P), Not(Q), R)\n        &gt;&gt;&gt; to_cnf(((P &amp; Q) | (R &amp; S)))\n        And(Or(R, P), Or(S, P), Or(R, Q), Or(S, Q))\n        &gt;&gt;&gt; to_cnf((P | Q) &amp; (R | S))\n        And(Or(P, Q), Or(R, S))\n        &gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n        &gt;&gt;&gt; to_cnf(sentence)\n        And(Or(Q(?X), S(?Z)), Or(R(?Y), S(?Z)))\n        &gt;&gt;&gt; to_cnf(P &gt;&gt; (Q | R))\n        Or(Not(P), Q, R)\n\n    :param sentence:\n    :param skip_skolemization:\n    :return:\n    \"\"\"\n    # Eliminate XORs\n    sentence = transform_sentence_chained(sentence, [expand_xor, expand_exactly_one])\n    # Eliminate implications and equivalences\n    sentence = eliminate_all_implications_recursive(sentence)\n    # Move negations inward\n    sentence = transform_sentence_chained(sentence, [apply_demorgans, apply_quantifier_negation])\n    # Standardize variables - TODO\n    # Skolemize\n    if not skip_skolemization:\n        sentence = skolemize(sentence)\n    #def raise_if_exists(s: Sentence) -&gt; Sentence:\n    #    if isinstance(s, Exists):\n    #        raise NotInProfileError(\"Exists not allowed in CNF\")\n    #    return s\n\n    #transform_sentence(sentence, raise_if_exists)\n    # Drop universal quantifiers\n    sentence = transform_sentence(sentence, lambda s: s.sentence if isinstance(s, Forall) else s)\n    # Distribute OR over AND\n    sentence = transform_sentence(sentence, distribute_and_over_or)\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.to_cnf_lol","title":"<code>to_cnf_lol(sentence, **kwargs)</code>","text":"<p>Convert a sentence to a list of lists of sentences in conjunctive normal form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n&gt;&gt;&gt; to_cnf_lol(sentence)\n[[Q(?X), S(?Z)], [R(?Y), S(?Z)]]\n\n&gt;&gt;&gt; to_cnf_lol(Term(\"P\"))\n[[P]]\n\n&gt;&gt;&gt; to_cnf_lol(Or(Term(\"P\"), Term(\"Q\")))\n[[P, Q]]\n&gt;&gt;&gt; to_cnf_lol(And(Term(\"P\"), Term(\"Q\")))\n[[P], [Q]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>List[List[Sentence]]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def to_cnf_lol(sentence: Sentence, **kwargs) -&gt; List[List[Sentence]]:\n    \"\"\"\n    Convert a sentence to a list of lists of sentences in conjunctive normal form.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n        &gt;&gt;&gt; to_cnf_lol(sentence)\n        [[Q(?X), S(?Z)], [R(?Y), S(?Z)]]\n\n        &gt;&gt;&gt; to_cnf_lol(Term(\"P\"))\n        [[P]]\n\n        &gt;&gt;&gt; to_cnf_lol(Or(Term(\"P\"), Term(\"Q\")))\n        [[P, Q]]\n        &gt;&gt;&gt; to_cnf_lol(And(Term(\"P\"), Term(\"Q\")))\n        [[P], [Q]]\n\n    :param sentence:\n    :param kwargs:\n    :return:\n    \"\"\"\n    sentence = to_cnf(sentence, **kwargs)\n    sentence = simplify(sentence)\n    if not isinstance(sentence, And):\n        sentence = And(sentence)\n    return [\n        list(op.operands) if isinstance(op, Or) else [op] for op in sentence.operands\n    ]\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.to_horn_rules","title":"<code>to_horn_rules(sentence, allow_disjunctions_in_head=False, allow_goal_clauses=None)</code>","text":"<p>Convert a sentence to a list of Horn rules.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; S = Term(\"S\")\n&gt;&gt;&gt; print(as_prolog(to_horn_rules(R &gt;&gt; (Q &amp; P))))\nq :- r.\np :- r.\n&gt;&gt;&gt; print(as_prolog(to_horn_rules((R &amp; S) &gt;&gt; P)))\np :- r, s.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>allow_disjunctions_in_head</code> <code>False</code> <p>Returns:</p> Type Description <code>List[Sentence]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def to_horn_rules(sentence: Sentence, allow_disjunctions_in_head=False, allow_goal_clauses=None) -&gt; List[Sentence]:\n    \"\"\"\n    Convert a sentence to a list of Horn rules.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; S = Term(\"S\")\n        &gt;&gt;&gt; print(as_prolog(to_horn_rules(R &gt;&gt; (Q &amp; P))))\n        q :- r.\n        p :- r.\n        &gt;&gt;&gt; print(as_prolog(to_horn_rules((R &amp; S) &gt;&gt; P)))\n        p :- r, s.\n\n    :param sentence:\n    :param allow_disjunctions_in_head:\n    :return:\n    \"\"\"\n    if allow_goal_clauses is None:\n        allow_goal_clauses = allow_disjunctions_in_head\n    sentence = transform_sentence(sentence, lambda s: s.to_model_object() if isinstance(s, Extension) else s)\n    sentence = simplify(sentence)\n    # TODO: check if already in horn profile\n    cnf_lol = to_cnf_lol(sentence, skip_skolemization=True)\n    rules: List[Sentence] = []\n    for dnf_sentence in cnf_lol:\n        # separate into positive and negative literals\n        positive = [] # head\n        negative = [] # body\n        for lit in dnf_sentence:\n            if isinstance(lit, Not):\n                negative.append(lit.negated)\n            else:\n                positive.append(lit)\n        if not positive and not negative:\n            # The empty clause, consisting of no literals (which is equivalent to false) is a goal clause\n            rules.append(Or())\n            continue\n        # a horn clause is a disjunction of literals with at most one positive literal.\n        if len(positive) &gt; 1 and not allow_disjunctions_in_head:\n            # not a horn clause (and not disjunctive datalog).\n            # we could potentially generate multiple rules here, but this could\n            # lead to stratified negation issues. We choose the last to be order preserving\n            pos = positive[-1]\n            other_pos = positive[:-1]\n            anded = negative + [Not(other) for other in other_pos]\n            rules.append(Implies(And(*anded), pos))\n            # TODO: uncomment this to generate multiple rules\n            #for pos in positive:\n            #    other_pos = [p for p in positive if p != pos]\n            #    anded = negative + [Not(other) for other in other_pos]\n            #    rules.append(Implies(And(*anded), pos))\n            continue\n        # a unit clause is a disjunction of literals with no negative literals\n        body = And(*negative) if len(negative) != 1 else negative[0]\n        if not positive and allow_goal_clauses:\n            # A Horn clause without a positive literal is a goal clause.\n            # Or() == False\n            rules.append(Implies(body, Or()))\n        if len(positive) == 1:\n            head = positive[0]\n            rules.append(Implies(body, head))\n        if len(positive) &gt; 1:\n            # we must be in disjunctive datalog at this pont\n            head = Or(*positive)\n            rules.append(Implies(body, head))\n    return rules\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.expand_xor","title":"<code>expand_xor(sentence)</code>","text":"<p>Expand XOR in a sentence.</p> <p>Replace A \u2295 B with (A \u2228 B) \u2227 \u00ac(A \u2227 B)</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; expand_xor(P ^ Q)\nAnd(Or(P, Q), Not(And(P, Q)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def expand_xor(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Expand XOR in a sentence.\n\n    Replace A \u2295 B with (A \u2228 B) \u2227 \u00ac(A \u2227 B)\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; expand_xor(P ^ Q)\n        And(Or(P, Q), Not(And(P, Q)))\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Xor):\n        return sentence\n    # expand XOR to an OR plus an AND, where len(operands) may be &gt; 2\n    operands = sentence.operands\n    if len(operands) == 1:\n        return operands[0]\n    return And(Or(*operands), Not(And(*operands)))\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.eliminate_all_implications_recursive","title":"<code>eliminate_all_implications_recursive(sentence)</code>","text":"<p>Replace A \u2192 B with \u00acA \u2228 B Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A), then apply the above rule</p> <p>Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)</p> <pre><code>&gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; print(eliminate_all_implications_recursive(P &gt;&gt; Q))\n(~P) | (Q)\n&gt;&gt;&gt; print(eliminate_all_implications_recursive(Iff(P, Q)))\n((~P) | (Q)) &amp; ((~Q) | (P))\n&gt;&gt;&gt; print(eliminate_all_implications_recursive(P &amp; ( Q &gt;&gt; R)))\n(P) &amp; ((~Q) | (R))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_all_implications_recursive(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Replace A \u2192 B with \u00acA \u2228 B\n    Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A), then apply the above rule\n\n    Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)\n\n        &gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; print(eliminate_all_implications_recursive(P &gt;&gt; Q))\n        (~P) | (Q)\n        &gt;&gt;&gt; print(eliminate_all_implications_recursive(Iff(P, Q)))\n        ((~P) | (Q)) &amp; ((~Q) | (P))\n        &gt;&gt;&gt; print(eliminate_all_implications_recursive(P &amp; ( Q &gt;&gt; R)))\n        (P) &amp; ((~Q) | (R))\n\n    :param sentence:\n    :return:\n    \"\"\"\n\n    def eliminate_implies(sentence: Sentence) -&gt; Sentence:\n        if isinstance(sentence, Implies):\n            return Or(Not(sentence.antecedent), sentence.consequent)\n        return sentence\n\n    def eliminate_implied(sentence: Sentence) -&gt; Sentence:\n        if isinstance(sentence, Implied):\n            return Implies(sentence.antecedent, sentence.consequent)\n        return sentence\n\n    def eliminate_iff(sentence: Sentence) -&gt; Sentence:\n        if isinstance(sentence, Iff):\n            return And(\n                Implies(sentence.left, sentence.right),\n                Implies(sentence.right, sentence.left),\n            )\n        return sentence\n\n    return transform_sentence_chained(sentence, [eliminate_iff, eliminate_implied, eliminate_implies])\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.eliminate_iff","title":"<code>eliminate_iff(sentence)</code>","text":"<p>Eliminate iff from a sentence.</p> <p>Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)</p> <pre><code>&gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Iff(Term(\"Q\", X), Term(\"R\", Y))\n&gt;&gt;&gt; eliminate_iff(sentence)\nAnd(Implies(Q(?X), R(?Y)), Implies(R(?Y), Q(?X)))\n\n&gt;&gt;&gt; sentence = Forall([X], Iff(Term(\"Q\", X), Term(\"R\", Y)))\n&gt;&gt;&gt; eliminate_iff(sentence)\nForall([X: str] : Iff(Q(?X), R(?Y)))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_iff(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Eliminate iff from a sentence.\n\n    Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)\n\n        &gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Iff(Term(\"Q\", X), Term(\"R\", Y))\n        &gt;&gt;&gt; eliminate_iff(sentence)\n        And(Implies(Q(?X), R(?Y)), Implies(R(?Y), Q(?X)))\n\n        &gt;&gt;&gt; sentence = Forall([X], Iff(Term(\"Q\", X), Term(\"R\", Y)))\n        &gt;&gt;&gt; eliminate_iff(sentence)\n        Forall([X: str] : Iff(Q(?X), R(?Y)))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Iff):\n        return sentence\n    return And(\n        Implies(sentence.left, sentence.right),\n        Implies(sentence.right, sentence.left),\n    )\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.eliminate_implied","title":"<code>eliminate_implied(sentence)</code>","text":"<p>Eliminate implied from a sentence.</p> <p>This simply reverses the direction of the implication.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Implied, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Implied(Term(\"Q\", X), Term(\"R\", Y))\n&gt;&gt;&gt; eliminate_implied(sentence)\nImplies(R(?Y), Q(?X))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_implied(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Eliminate implied from a sentence.\n\n    This simply reverses the direction of the implication.\n\n        &gt;&gt;&gt; from typedlogic import Implied, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Implied(Term(\"Q\", X), Term(\"R\", Y))\n        &gt;&gt;&gt; eliminate_implied(sentence)\n        Implies(R(?Y), Q(?X))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Implied):\n        return sentence\n    return Implies(sentence.operands[1], sentence.operands[0])\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.eliminate_implies","title":"<code>eliminate_implies(sentence)</code>","text":"<p>Eliminate implies from a sentence in translation to CNF</p> <p>Replace A \u2192 B with \u00acA \u2228 B</p> <pre><code>&gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Implies(Term(\"Q\", X), Term(\"R\", Y))\n&gt;&gt;&gt; eliminate_implies(sentence)\nOr(Not(Q(?X)), R(?Y))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_implies(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Eliminate implies from a sentence in translation to CNF\n\n    Replace A \u2192 B with \u00acA \u2228 B\n\n        &gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Implies(Term(\"Q\", X), Term(\"R\", Y))\n        &gt;&gt;&gt; eliminate_implies(sentence)\n        Or(Not(Q(?X)), R(?Y))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n    \"\"\"\n    if not isinstance(sentence, Implies):\n        return sentence\n    return Or(Not(sentence.operands[0]), sentence.operands[1])\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.apply_demorgans","title":"<code>apply_demorgans(sentence)</code>","text":"<p>Apply De Morgan's laws to a sentence.</p> <p>Replace \u00ac(A \u2227 B) with \u00acA \u2228 \u00acB Replace \u00ac(A \u2228 B) with \u00acA \u2227 \u00acB</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Not, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Not(And(Term(\"Q\", X), Term(\"R\", Y)))\n&gt;&gt;&gt; apply_demorgans(sentence)\nOr(Not(Q(?X)), Not(R(?Y)))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def apply_demorgans(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Apply De Morgan's laws to a sentence.\n\n    Replace \u00ac(A \u2227 B) with \u00acA \u2228 \u00acB\n    Replace \u00ac(A \u2228 B) with \u00acA \u2227 \u00acB\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Not, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Not(And(Term(\"Q\", X), Term(\"R\", Y)))\n        &gt;&gt;&gt; apply_demorgans(sentence)\n        Or(Not(Q(?X)), Not(R(?Y)))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Not):\n        return sentence\n    negated = sentence.negated\n    if isinstance(negated, And):\n        return Or(*[Not(op) for op in negated.operands])\n    if isinstance(negated, Or):\n        return And(*[Not(op) for op in negated.operands])\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.apply_quantifier_negation","title":"<code>apply_quantifier_negation(sentence)</code>","text":"<p>Apply negation of quantifiers to a sentence.</p> <p>Replace \u00ac\u2200x P(x) with \u2203x \u00acP(x) Replace \u00ac\u2203x P(x) with \u2200x \u00acP(x)</p> <pre><code>&gt;&gt;&gt; from typedlogic import Forall, Variable, Term\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; sentence = Not(Forall([X], Term(\"P\", X)))\n&gt;&gt;&gt; apply_quantifier_negation(sentence)\nExists(X: str : Not(P(?X)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def apply_quantifier_negation(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Apply negation of quantifiers to a sentence.\n\n    Replace \u00ac\u2200x P(x) with \u2203x \u00acP(x)\n    Replace \u00ac\u2203x P(x) with \u2200x \u00acP(x)\n\n        &gt;&gt;&gt; from typedlogic import Forall, Variable, Term\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; sentence = Not(Forall([X], Term(\"P\", X)))\n        &gt;&gt;&gt; apply_quantifier_negation(sentence)\n        Exists(X: str : Not(P(?X)))\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Not):\n        return sentence\n    negated = sentence.negated\n    if isinstance(negated, Forall):\n        return Exists(negated.variables, Not(negated.sentence))\n    if isinstance(negated, Exists):\n        return Forall(negated.variables, Not(negated.sentence))\n    return sentence\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.force_stratification","title":"<code>force_stratification(horn_rules)</code>","text":"<p>Force stratification of a list of horn rules.</p> <p>If the program is not stratified, remove a rule using negation that causes the issue and recurse.</p> <p>Note that this will weaken the program, but it will be stratified.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; sentence = Iff(P&amp;Q, R)\n&gt;&gt;&gt; rules = to_horn_rules(sentence)\n&gt;&gt;&gt; force_stratification(rules)\n[Implies(And(P, Q), R), Implies(R, P), Implies(R, Q)]\n&gt;&gt;&gt; sentence = And(Iff(P|Q, R), Iff(P, ~Q))\n&gt;&gt;&gt; rules = to_horn_rules(sentence)\n&gt;&gt;&gt; rules\n[Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q), Implies(And(Not(Q)), P)]\n&gt;&gt;&gt; force_stratification(rules)\n[Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>horn_rules</code> <code>List[Sentence]</code> required <p>Returns:</p> Type Description <code>List[Sentence]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def force_stratification(horn_rules: List[Sentence]) -&gt; List[Sentence]:\n    \"\"\"\n    Force stratification of a list of horn rules.\n\n    If the program is not stratified, remove a rule using negation that causes the issue\n    and recurse.\n\n    Note that this will weaken the program, but it will be stratified.\n\n        &gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; sentence = Iff(P&amp;Q, R)\n        &gt;&gt;&gt; rules = to_horn_rules(sentence)\n        &gt;&gt;&gt; force_stratification(rules)\n        [Implies(And(P, Q), R), Implies(R, P), Implies(R, Q)]\n        &gt;&gt;&gt; sentence = And(Iff(P|Q, R), Iff(P, ~Q))\n        &gt;&gt;&gt; rules = to_horn_rules(sentence)\n        &gt;&gt;&gt; rules\n        [Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q), Implies(And(Not(Q)), P)]\n        &gt;&gt;&gt; force_stratification(rules)\n        [Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q)]\n\n    :param horn_rules:\n    :return:\n    \"\"\"\n    pmap: Dict[str, List[Tuple[str, bool]]] = defaultdict(list)\n    edge_to_rules = defaultdict(list)\n    for i, rule in enumerate(horn_rules):\n        if isinstance(rule, Implies):\n            head = rule.consequent\n            if not isinstance(head, Term):\n                continue\n            pred = head.predicate\n            body = rule.antecedent\n            if isinstance(body, And):\n                terms = list(body.operands)\n            else:\n                terms = [body]\n            for term in terms:\n                negated = False\n                if isinstance(term, Not):\n                    term = term.negated\n                    negated = True\n                if not isinstance(term, Term):\n                    continue\n                pmap[pred].append((term.predicate, negated))\n                if negated:\n                    edge_to_rules[(pred, term.predicate)].append(i)\n    is_stratified, edge, _ = analyze_datalog_program(list(pmap.items()))\n    if not is_stratified:\n        if not edge:\n            raise AssertionError\n        candidates = edge_to_rules[edge] if edge in edge_to_rules else []\n        if not candidates:\n            raise AssertionError(f\"Stratification failed; cannot find {edge} in {edge_to_rules}\")\n        rule_to_remove = candidates[0]\n        horn_rules = [rule for i, rule in enumerate(horn_rules) if i != rule_to_remove]\n        return force_stratification(horn_rules)\n    return horn_rules\n</code></pre>"},{"location":"api/transformations/#typedlogic.transformations.ensure_terms_positional","title":"<code>ensure_terms_positional(theory)</code>","text":"<p>Ensure that all terms in a theory have all positions filled and ordered.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Term, Variable, PredicateDefinition, Theory\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; theory = Theory(predicate_definitions=[PredicateDefinition(\"P\", {\"x\": \"str\", \"y\": \"str\"})])\n&gt;&gt;&gt; s1 = Term(\"P\", X, Y)\n&gt;&gt;&gt; s2 = Term(\"P\", {\"x\": X, \"y\": Y})\n&gt;&gt;&gt; s3 = Term(\"P\", {\"y\": Y, \"x\": X})\n&gt;&gt;&gt; s4 = Term(\"P\", {\"y\": Y})\n&gt;&gt;&gt; s5 = Term(\"P\", {})\n&gt;&gt;&gt; theory.add(s1)\n&gt;&gt;&gt; theory.add(s2)\n&gt;&gt;&gt; theory.add(s3)\n&gt;&gt;&gt; theory.add(s4)\n&gt;&gt;&gt; theory.add(s5)\n&gt;&gt;&gt; ensure_terms_positional(theory)\n&gt;&gt;&gt; for s in theory.sentences:\n...     print(s)\nP(?X, ?Y)\nP(?X, ?Y)\nP(?X, ?Y)\nP(None, ?Y)\nP(None, None)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> required <p>Returns:</p> Type Description Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def ensure_terms_positional(theory: Theory):\n    \"\"\"\n    Ensure that all terms in a theory have all positions filled and ordered.\n\n        &gt;&gt;&gt; from typedlogic import Term, Variable, PredicateDefinition, Theory\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; theory = Theory(predicate_definitions=[PredicateDefinition(\"P\", {\"x\": \"str\", \"y\": \"str\"})])\n        &gt;&gt;&gt; s1 = Term(\"P\", X, Y)\n        &gt;&gt;&gt; s2 = Term(\"P\", {\"x\": X, \"y\": Y})\n        &gt;&gt;&gt; s3 = Term(\"P\", {\"y\": Y, \"x\": X})\n        &gt;&gt;&gt; s4 = Term(\"P\", {\"y\": Y})\n        &gt;&gt;&gt; s5 = Term(\"P\", {})\n        &gt;&gt;&gt; theory.add(s1)\n        &gt;&gt;&gt; theory.add(s2)\n        &gt;&gt;&gt; theory.add(s3)\n        &gt;&gt;&gt; theory.add(s4)\n        &gt;&gt;&gt; theory.add(s5)\n        &gt;&gt;&gt; ensure_terms_positional(theory)\n        &gt;&gt;&gt; for s in theory.sentences:\n        ...     print(s)\n        P(?X, ?Y)\n        P(?X, ?Y)\n        P(?X, ?Y)\n        P(None, ?Y)\n        P(None, None)\n\n    :param theory:\n    :return:\n    \"\"\"\n    def tr(s: Sentence):\n        if isinstance(s, Term):\n            pds = [pd for pd in theory.predicate_definitions if pd.predicate == s.predicate]\n            if len(pds) != 1:\n                # could include builtins\n                return\n            pd = pds[0]\n            if not s.positional:\n                s.bindings = {k: s.bindings.get(k) for k, v in pd.arguments.items()}\n    for s in theory.sentences:\n        transform_sentence(s, tr)\n</code></pre>"},{"location":"concepts/","title":"typed-logic: Bridging Formal Logic and Typed Python","text":"<p>typed-logic is a Python package that allows Python data models to be augmented using formal logical statements, which are then interpreted by solvers which can reason over combinations of programs and data allowing for  satisfiability checking, and the generation of new data.</p> <p>Currently the solvers supported are:</p> <ul> <li>Z3</li> <li>Souffle</li> <li>Clingo</li> <li>Prover9</li> <li>Snakelog)</li> </ul> <p>With support for more solvers (Vampire, OWL reasoners, etc.) planned.</p> <p>typed-logic is aimed primarily at software developers and data modelers who are logic-curious, but don't necessarily have a background in formal logic. It is especially aimed at Python developers who like to use lightweight ways of ensuring program and data correctness, such as Pydantic for data and mypy for type checking of programs. </p>"},{"location":"concepts/#key-features","title":"Key Features","text":"<ul> <li>Write logical axioms and rules using familiar Python syntax</li> <li>Benefit from strong typing and mypy validation</li> <li>Seamless integration with logic programming engines</li> <li>Support for various solvers, including Z3 and Souffle</li> <li>Compatible with popular Python libraries like Pydantic</li> </ul>"},{"location":"concepts/#why-typedlogic","title":"Why TypedLogic?","text":"<p>TypedLogic combines the best of both worlds: the expressiveness and familiarity of Python with the power of formal logic and fast logic programming engines. This unique approach allows developers to:</p> <ol> <li>Write more maintainable and less error-prone logical rules</li> <li>Catch type-related errors early in the development process</li> <li>Seamlessly integrate logical reasoning into existing Python projects</li> <li>Leverage the performance of specialized logic engines without sacrificing the Python ecosystem</li> </ol> <p>Get started with TypedLogic and experience a new way of combining logic programming with strongly typed Python!</p>"},{"location":"concepts/#core-concepts","title":"Core Concepts","text":"<p>TypedLogic is built around several core concepts that blend logical programming with typed Python. Understanding these concepts is crucial for effectively using the library.</p>"},{"location":"concepts/#use-python-idioms-to-define-your-data-structures","title":"Use Python idioms to define your data structures","text":"<p>Facts are the basic units of information in TypedLogic. They are represented as Python classes that inherit from both <code>pydantic.BaseModel</code> and <code>FactMixin</code>. This approach allows you to define strongly-typed facts with automatic validation.</p> <p>Example:</p> <pre><code>from pydantic import BaseModel\nfrom typedlogic import FactMixin\n\nPersonID = str\nPetID = str\n\nclass Person(BaseModel, FactMixin):\n    name: PersonID\n\nclass PersonAge(BaseModel, FactMixin):\n    name: PersonID\n    age: int\n\nclass Pet(BaseModel, FactMixin):\n    name: PetID\n\nclass PetSpecies(BaseModel, FactMixin):\n    name: PetID\n    species: str\n\nclass OwnsPet(BaseModel, FactMixin):\n    person: PersonID\n    pet: PetID\n</code></pre>"},{"location":"concepts/#axioms","title":"Axioms","text":"<p>Axioms are logical rules or statements that define relationships between facts. In TypedLogic, axioms are defined using Python functions decorated with <code>@axiom</code>.</p> <p>Example:</p> <pre><code>from typedlogic.decorators import axiom\n\n@axiom\ndef constraints(person: PersonID, pet: PetID):\n    if OwnsPet(person=person, pet=pet):\n        assert Person(name=person) and Pet(name=pet)\n</code></pre> <p>You can also derive new facts from axioms:</p> <pre><code>class SameOwner(BaseModel, FactMixin):\n    pet1: PetID\n    pet2: PetID\n\nfrom typedlogic.decorators import axiom\n\n@axiom\ndef entail_same_owner(person: PersonID, pet1: PetID, pet2: PetID):\n    if OwnsPet(person=person, pet=pet1) and OwnsPet(person=person, pet=pet2):\n        assert SameOwner(pet1=pet1, pet2=pet2)\n</code></pre>"},{"location":"concepts/#generators","title":"Generators","text":"<p>Generators like <code>gen1</code>, <code>gen2</code>, etc., are used within axioms to create typed placeholders for variables. They help maintain type safety while defining logical rules.</p>"},{"location":"concepts/#solvers","title":"Solvers","text":"<p>TypedLogic supports multiple solvers, including Z3 and Souffle. Solvers are responsible for reasoning over the facts and axioms to derive new information or check for consistency.</p> <p>Example (using Z3 solver):</p> <pre><code>from typedlogic.integrations.solvers.z3 import Z3Solver\n\nsolver = Z3Solver()\nsolver.add(theory)\nresult = solver.check()\n</code></pre>"},{"location":"concepts/#theories","title":"Theories","text":"<p>A Theory in TypedLogic is a collection of predicate definitions, facts, and axioms. It represents a complete knowledge base that can be reasoned over.</p> <p>Example:</p> <pre><code>from typedlogic import Theory\n\ntheory = Theory(\n    name=\"family_relationships\",\n    predicate_definitions=[...],\n    sentence_groups=[...],\n)\n</code></pre> <p>Understanding these core concepts will provide a solid foundation for working with TypedLogic and leveraging its power in your projects.</p>"},{"location":"concepts/compilers/","title":"Compilers","text":""},{"location":"concepts/datamodel/","title":"Data Model","text":"<p>Data model for the typed-logic framework.</p> <p>This module defines the core classes and structures used to represent logical constructs such as sentences, terms, predicates, and theories. It is based on the Common Logic Interchange Format (CLIF) and the Common Logic Standard (CL), with additions to make working with simple type systems easier.</p> <p>Logical axioms are called sentences which organized into theories.,  which can be loaded into a solver.</p> <p>While one of the goals of typed-logic is to be able to write logic intuitively in Python,  this data model is independent of the mapping from the Python language to the logic language;  it can be used independently of the python syntax.</p> <p>Here is an example:</p> <pre><code>    &gt;&gt;&gt; from typedlogic import Term, Forall, Implies\n    &gt;&gt;&gt; x = Variable('x')\n    &gt;&gt;&gt; y = Variable('y')\n    &gt;&gt;&gt; pdef = PredicateDefinition(predicate='FriendOf',\n    ...                          arguments={'x': 'str', 'y': 'str'}),\n    &gt;&gt;&gt; theory = Theory(\n    ...     name=\"My theory\",\n    ...     predicate_definitions=[pdef],\n    ... )\n    &gt;&gt;&gt; s = Forall([x, y],\n    ...            Implies(Term('friend_of', x, y),\n    ...                    Term('friend_of', y, x)))\n    &gt;&gt;&gt; theory.add(s)\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.PredicateDefinition","title":"<code>PredicateDefinition</code>  <code>dataclass</code>","text":"<p>Defines the name and arguments of a predicate.</p> <pre><code>&gt;&gt;&gt; pdef = PredicateDefinition(predicate='FriendOf',\n...                            arguments={'x': 'str', 'y': 'str'})\n</code></pre> <p>The arguments are mappings between variable names and types. You can use either base types (e.g. 'str', 'int', 'float') or custom types.</p> <p>Custom types should be defined in the theory's <code>type_definitions</code> attribute.</p> <pre><code>&gt;&gt;&gt; pdef = PredicateDefinition(predicate='FriendOf',\n...                            arguments={'x': 'Person', 'y': 'Person'})\n&gt;&gt;&gt; theory = Theory(\n...     name=\"My theory\",\n...     type_definitions={'Person': 'str'},\n...     predicate_definitions=[pdef],\n... )\n</code></pre> <pre><code>classDiagram\nclass PredicateDefinition {\n    +String predicate\n    +Dict arguments\n    +String description\n    +Dict metadata\n}\nPredicateDefinition --&gt; \"*\" PredicateDefinition : parents</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass PredicateDefinition:\n    \"\"\"\n    Defines the name and arguments of a predicate.\n\n        &gt;&gt;&gt; pdef = PredicateDefinition(predicate='FriendOf',\n        ...                            arguments={'x': 'str', 'y': 'str'})\n\n    The arguments are mappings between variable names and types.\n    You can use either base types (e.g. 'str', 'int', 'float') or custom types.\n\n    Custom types should be defined in the theory's `type_definitions` attribute.\n\n        &gt;&gt;&gt; pdef = PredicateDefinition(predicate='FriendOf',\n        ...                            arguments={'x': 'Person', 'y': 'Person'})\n        &gt;&gt;&gt; theory = Theory(\n        ...     name=\"My theory\",\n        ...     type_definitions={'Person': 'str'},\n        ...     predicate_definitions=[pdef],\n        ... )\n\n    ```mermaid\n    classDiagram\n    class PredicateDefinition {\n        +String predicate\n        +Dict arguments\n        +String description\n        +Dict metadata\n    }\n    PredicateDefinition --&gt; \"*\" PredicateDefinition : parents\n    ```\n\n    \"\"\"\n\n    predicate: str\n    arguments: Dict[str, str]\n    description: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n    parents: Optional[List[str]] = None\n    python_class: Optional[Type] = None\n\n    def argument_base_type(self, arg: str) -&gt; str:\n        typ = self.arguments[arg]\n        try:\n            import pydantic\n            if isinstance(typ, pydantic.fields.FieldInfo):\n                typ = typ.annotation\n        except ImportError:\n            pass\n        return str(typ)\n\n    @classmethod\n    def from_class(cls, python_class: Type) -&gt; \"PredicateDefinition\":\n        \"\"\"\n        Create a predicate definition from a python class\n\n        :param predicate_class:\n        :return:\n        \"\"\"\n        return PredicateDefinition(predicate=python_class.__name__,\n                                   arguments={k: v for k, v in python_class.__annotations__.items()},\n                                   )\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.PredicateDefinition.from_class","title":"<code>from_class(python_class)</code>  <code>classmethod</code>","text":"<p>Create a predicate definition from a python class</p> <p>Parameters:</p> Name Type Description Default <code>predicate_class</code> required <p>Returns:</p> Type Description <code>PredicateDefinition</code> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@classmethod\ndef from_class(cls, python_class: Type) -&gt; \"PredicateDefinition\":\n    \"\"\"\n    Create a predicate definition from a python class\n\n    :param predicate_class:\n    :return:\n    \"\"\"\n    return PredicateDefinition(predicate=python_class.__name__,\n                               arguments={k: v for k, v in python_class.__annotations__.items()},\n                               )\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Variable","title":"<code>Variable</code>  <code>dataclass</code>","text":"<p>A variable in a logical sentence.</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; y = Variable('y')\n&gt;&gt;&gt; s = Forall([x, y],\n...            Implies(Term('friend_of', x, y),\n...                    Term('friend_of', y, x)))\n</code></pre> <p>Variables can have domains (types) specified:</p> <pre><code>&gt;&gt;&gt; x = Variable('x', domain='str')\n&gt;&gt;&gt; y = Variable('y', domain='str')\n&gt;&gt;&gt; z = Variable('y', domain='int')\n&gt;&gt;&gt; xa = Variable('xa', domain='int')\n&gt;&gt;&gt; ya = Variable('ya', domain='int')\n&gt;&gt;&gt; s = Forall([x, y, z],\n...            Implies(And(Term('ParentOf', x, y),\n...                        Term('Age', x, xa),\n...                        Term('Age', y, ya)),\n...                    Term('OlderThan', x, y)))\n\nThe domains should be either base types or defined types in the theory's `type_definitions` attribute.\n</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Variable:\n    \"\"\"\n    A variable in a logical sentence.\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; y = Variable('y')\n        &gt;&gt;&gt; s = Forall([x, y],\n        ...            Implies(Term('friend_of', x, y),\n        ...                    Term('friend_of', y, x)))\n\n    Variables can have domains (types) specified:\n\n        &gt;&gt;&gt; x = Variable('x', domain='str')\n        &gt;&gt;&gt; y = Variable('y', domain='str')\n        &gt;&gt;&gt; z = Variable('y', domain='int')\n        &gt;&gt;&gt; xa = Variable('xa', domain='int')\n        &gt;&gt;&gt; ya = Variable('ya', domain='int')\n        &gt;&gt;&gt; s = Forall([x, y, z],\n        ...            Implies(And(Term('ParentOf', x, y),\n        ...                        Term('Age', x, xa),\n        ...                        Term('Age', y, ya)),\n        ...                    Term('OlderThan', x, y)))\n\n        The domains should be either base types or defined types in the theory's `type_definitions` attribute.\n\n    \"\"\"\n\n    name: str\n    domain: Optional[str] = None\n    constraints: Optional[List[str]] = None\n\n    def __eq__(self, other):\n        return isinstance(other, Variable) and self.name == other.name\n\n    def __str__(self):\n        return \"?\" + self.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def as_sexpr(self) -&gt; SExpression:\n        sexpr = [type(self).__name__, self.name]\n        if self.domain:\n            return sexpr + [self.domain]\n        else:\n            return sexpr\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Sentence","title":"<code>Sentence</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for logical sentences.</p> <p>Do not use this class directly; use one of the subclasses instead.</p> <p>Model:</p> <pre><code>classDiagram\nSentence &lt;|-- Term\nSentence &lt;|-- BooleanSentence\nSentence &lt;|-- QuantifiedSentence\nSentence &lt;|-- Extension</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>class Sentence(ABC):\n    \"\"\"\n    Base class for logical sentences.\n\n    Do not use this class directly; use one of the subclasses instead.\n\n    Model:\n\n    ```mermaid\n    classDiagram\n    Sentence &lt;|-- Term\n    Sentence &lt;|-- BooleanSentence\n    Sentence &lt;|-- QuantifiedSentence\n    Sentence &lt;|-- Extension\n    ```\n\n\n    \"\"\"\n\n    def __init__(self):\n        self._annotations = {}\n\n    def __and__(self, other):\n        return And(self, other)\n\n    def __or__(self, other):\n        return Or(self, other)\n\n    def __invert__(self):\n        return Not(self)\n\n    def __sub__(self):\n        return NegationAsFailure(self)\n\n    def __rshift__(self, other):\n        return Implies(self, other)\n\n    def __lshift__(self, other):\n        return Implied(self, other)\n\n    def __xor__(self, other):\n        return Xor(self, other)\n\n    def iff(self, other):\n        return Iff(self, other)\n\n    def __lt__(self, other):\n        return Term(operator.lt.__name__, self, other)\n\n    def __le__(self, other):\n        return Term(operator.le.__name__, self, other)\n\n    def __gt__(self, other):\n        return Term(operator.gt.__name__, self, other)\n\n    def __ge__(self, other):\n        return Term(operator.ge.__name__, self, other)\n\n    def __add__(self, other):\n        return Term(operator.add.__name__, self, other)\n\n    @property\n    def annotations(self):\n        return self._annotations\n\n    def as_sexpr(self) -&gt; SExpression:\n        raise NotImplementedError(f\"type = {type(self)} // {self}\")\n\n    @property\n    def arguments(self) -&gt; List[Any]:\n        raise NotImplementedError(f\"type = {type(self)} // {self}\")\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Term","title":"<code>Term</code>","text":"<p>               Bases: <code>Sentence</code></p> <p>An atomic part of a sentence.</p> <p>A ground term is a term with no variables:</p> <pre><code>&gt;&gt;&gt; t = Term('FriendOf', 'Alice', 'Bob')\n&gt;&gt;&gt; t\nFriendOf(Alice, Bob)\n&gt;&gt;&gt; t.values\n('Alice', 'Bob')\n&gt;&gt;&gt; t.is_ground\nTrue\n</code></pre> <p>Keyword argument based initializaton is also supported:</p> <pre><code>&gt;&gt;&gt; t = Term('FriendOf', dict(about='Alice', friend='Bob'))\n&gt;&gt;&gt; t.values\n('Alice', 'Bob')\n&gt;&gt;&gt; t.positional\nFalse\n</code></pre> <p>Mappings:</p> <ul> <li>Corresponds to AtomicSentence in Common Logic</li> </ul> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>class Term(Sentence):\n    \"\"\"\n    An atomic part of a sentence.\n\n    A ground term is a term with no variables:\n\n        &gt;&gt;&gt; t = Term('FriendOf', 'Alice', 'Bob')\n        &gt;&gt;&gt; t\n        FriendOf(Alice, Bob)\n        &gt;&gt;&gt; t.values\n        ('Alice', 'Bob')\n        &gt;&gt;&gt; t.is_ground\n        True\n\n    Keyword argument based initializaton is also supported:\n\n        &gt;&gt;&gt; t = Term('FriendOf', dict(about='Alice', friend='Bob'))\n        &gt;&gt;&gt; t.values\n        ('Alice', 'Bob')\n        &gt;&gt;&gt; t.positional\n        False\n\n    Mappings:\n\n     - Corresponds to AtomicSentence in Common Logic\n    \"\"\"\n\n    def __init__(self, predicate: str, *args, **kwargs):\n        self.predicate = predicate\n        if not args:\n            self.positional = None\n            bindings = {}\n        elif len(args) == 1 and isinstance(args[0], dict):\n            bindings = args[0]\n            self.positional = False\n        else:\n            bindings = {f'arg{i}': arg for i, arg in enumerate(args)}\n            self.positional = True\n        self.bindings = bindings\n        self._annotations = kwargs\n\n    @property\n    def is_constant(self):\n        \"\"\"\n        :return: True if the term is a constant (zero arguments)\n        \"\"\"\n        return not self.bindings\n\n    @property\n    def is_ground(self):\n        \"\"\"\n        :return: True if none of the arguments are variables\n        \"\"\"\n        return not any(isinstance(v, Variable) for v in self.bindings.values())\n\n    @property\n    def values(self) -&gt; Tuple[Any, ...]:\n        \"\"\"\n        Representation of the arguments of the term as a fixed-position tuples\n        :return:\n        \"\"\"\n        return tuple([v for v in self.bindings.values()])\n\n    @property\n    def variables(self) -&gt; List[Variable]:\n        \"\"\"\n        :return: All of the arguments that are variables\n        \"\"\"\n        return [v for v in self.bindings.values() if isinstance(v, Variable)]\n\n    @property\n    def variable_names(self) -&gt; List[str]:\n        return [v.name for v in self.bindings.values() if isinstance(v, Variable)]\n\n    def make_keyword_indexed(self, keywords: List[str]):\n        \"\"\"\n        Convert positional arguments to keyword arguments\n        \"\"\"\n        if self.positional:\n            self.bindings = {k: v for k, v in zip(keywords, self.bindings.values(), strict=False)}\n            self.positional = False\n\n    def __repr__(self):\n        if not self.bindings:\n            return f'{self.predicate}'\n        elif self.positional:\n            return f'{self.predicate}({\", \".join(f\"{v}\" for v in self.bindings.values())})'\n        else:\n            return f'{self.predicate}({\", \".join(f\"{v}\" for k, v in self.bindings.items())})'\n\n    def __eq__(self, other):\n        # return isinstance(other, Term) and self.predicate == other.predicate and self.bindings == other.bindings\n        return isinstance(other, Term) and self.predicate == other.predicate and self.values == other.values\n\n    def __hash__(self):\n        return hash((self.predicate, tuple(self.values)))\n\n    def as_sexpr(self) -&gt; SExpression:\n        return [self.predicate] + [as_sexpr(v) for v in self.bindings.values()]\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Term.is_constant","title":"<code>is_constant</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <p>True if the term is a constant (zero arguments)</p>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Term.is_ground","title":"<code>is_ground</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <p>True if none of the arguments are variables</p>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Term.values","title":"<code>values: Tuple[Any, ...]</code>  <code>property</code>","text":"<p>Representation of the arguments of the term as a fixed-position tuples</p> <p>Returns:</p> Type Description <code>Tuple[Any, ...]</code>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Term.variables","title":"<code>variables: List[Variable]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>List[Variable]</code> <p>All of the arguments that are variables</p>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Term.make_keyword_indexed","title":"<code>make_keyword_indexed(keywords)</code>","text":"<p>Convert positional arguments to keyword arguments</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>def make_keyword_indexed(self, keywords: List[str]):\n    \"\"\"\n    Convert positional arguments to keyword arguments\n    \"\"\"\n    if self.positional:\n        self.bindings = {k: v for k, v in zip(keywords, self.bindings.values(), strict=False)}\n        self.positional = False\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Extension","title":"<code>Extension</code>","text":"<p>               Bases: <code>Sentence</code>, <code>ABC</code></p> <p>Use this class for framework-specific extensions.</p> <p>An example of this is the <code>Fact</code> class which subclasses Extension, and is intended to be subclasses by domain-specific classes representing predicate definitions, whose instances map to terms.</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>class Extension(Sentence, ABC):\n    \"\"\"\n    Use this class for framework-specific extensions.\n\n    An example of this is the `Fact` class which subclasses Extension, and is intended to be\n    subclasses by domain-specific classes representing predicate definitions, whose instances\n    map to terms.\n    \"\"\"\n\n    @abstractmethod\n    def to_model_object(self) -&gt; Sentence:\n        \"\"\"\n        Convert the extension to a standard model object.\n\n        :return:\n        \"\"\"\n        pass\n\n    def as_sexpr(self) -&gt; List[Any]:\n        return self.to_model_object().as_sexpr()\n\n    @property\n    def arguments(self) -&gt; List[Any]:\n        return self.to_model_object().arguments\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Extension.to_model_object","title":"<code>to_model_object()</code>  <code>abstractmethod</code>","text":"<p>Convert the extension to a standard model object.</p> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@abstractmethod\ndef to_model_object(self) -&gt; Sentence:\n    \"\"\"\n    Convert the extension to a standard model object.\n\n    :return:\n    \"\"\"\n    pass\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.BooleanSentence","title":"<code>BooleanSentence</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sentence</code>, <code>ABC</code></p> <p>Base class for sentences that are boolean expressions</p> <p>Corresponds to BooleanSentence in CL</p> <pre><code>classDiagram\nBooleanSentence &lt;|-- And\nBooleanSentence &lt;|-- Or\nBooleanSentence &lt;|-- Not\nBooleanSentence &lt;|-- Xor\nBooleanSentence &lt;|-- ExactlyOne\nBooleanSentence &lt;|-- Implication\nBooleanSentence &lt;|-- Implied\nBooleanSentence &lt;|-- Iff\nBooleanSentence &lt;|-- NegationAsFailure\nBooleanSentence --&gt; \"*\" Sentence : operands</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass BooleanSentence(Sentence, ABC):\n    \"\"\"\n    Base class for sentences that are boolean expressions\n\n    Corresponds to BooleanSentence in CL\n\n    ```mermaid\n    classDiagram\n    BooleanSentence &lt;|-- And\n    BooleanSentence &lt;|-- Or\n    BooleanSentence &lt;|-- Not\n    BooleanSentence &lt;|-- Xor\n    BooleanSentence &lt;|-- ExactlyOne\n    BooleanSentence &lt;|-- Implication\n    BooleanSentence &lt;|-- Implied\n    BooleanSentence &lt;|-- Iff\n    BooleanSentence &lt;|-- NegationAsFailure\n    BooleanSentence --&gt; \"*\" Sentence : operands\n    ```\n\n    \"\"\"\n\n    operands: Tuple = field(default_factory=tuple)\n\n    def __init__(self, *operands, **kwargs):\n        self.operands = operands\n        self._annotations = kwargs\n\n    def __eq__(self, other):\n        return isinstance(other, type(self)) and self.operands == other.operands\n\n    def as_sexpr(self) -&gt; SExpression:\n        return [type(self).__name__] + [as_sexpr(op) for op in self.operands]\n\n    @property\n    def arguments(self) -&gt; List[Any]:\n        return list(self.operands)\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.And","title":"<code>And</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BooleanSentence</code></p> <p>A conjunction of sentences.</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; y = Variable('y')\n&gt;&gt;&gt; s = And(Term('friend_of', x, y), Term('friend_of', y, x))\n</code></pre> <p>You can also use syntactic sugar:</p> <pre><code>&gt;&gt;&gt; s = Term('friend_of', x, y) &amp; Term('friend_of', y, x)\n</code></pre> <p>Note however that precedence rules for <code>&amp;</code> are different from <code>and</code>.</p> <p>In the context of a pylog program, you can also use <code>and</code>:</p> <p><code>assert FriendOf(x, y) &amp; FriendOf(y, x)</code></p> <p>As in CL, <code>And()</code> means True</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass And(BooleanSentence):\n    \"\"\"\n    A conjunction of sentences.\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; y = Variable('y')\n        &gt;&gt;&gt; s = And(Term('friend_of', x, y), Term('friend_of', y, x))\n\n    You can also use syntactic sugar:\n\n        &gt;&gt;&gt; s = Term('friend_of', x, y) &amp; Term('friend_of', y, x)\n\n    Note however that precedence rules for `&amp;` are different from `and`.\n\n    In the context of a pylog program, you can also use `and`:\n\n    ```assert FriendOf(x, y) &amp; FriendOf(y, x)```\n\n    As in CL, ``And()`` means True\n    \"\"\"\n\n    def __init__(self, *operands, **kwargs):\n        super().__init__(*operands, **kwargs)\n\n\n    def __str__(self):\n        return f'({\") &amp; (\".join(str(op) for op in self.operands)})'\n\n    def __repr__(self):\n        return f'And({\", \".join(repr(op) for op in self.operands)})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Or","title":"<code>Or</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BooleanSentence</code></p> <p>A disjunction of sentences.</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; y = Variable('y')\n&gt;&gt;&gt; s = Or(Term('friend_of', x, y), Term('friend_of', y, x))\n&gt;&gt;&gt; s.operands[0]\nfriend_of(?x, ?y)\n</code></pre> <p>You can also use syntactic sugar:</p> <pre><code>&gt;&gt;&gt; s = Term('friend_of', x, y) | Term('friend_of', y, x)\n</code></pre> <p>Note however that precedence rules for <code>|</code> are different from <code>or</code>.</p> <p>In the context of a pylog program, you can also use <code>or</code>:</p> <p><code>assert FriendOf(x, y) | FriendOf(y, x)</code></p> <p>As in CL, <code>Or()</code> means False</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Or(BooleanSentence):\n    \"\"\"\n    A disjunction of sentences.\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; y = Variable('y')\n        &gt;&gt;&gt; s = Or(Term('friend_of', x, y), Term('friend_of', y, x))\n        &gt;&gt;&gt; s.operands[0]\n        friend_of(?x, ?y)\n\n    You can also use syntactic sugar:\n\n        &gt;&gt;&gt; s = Term('friend_of', x, y) | Term('friend_of', y, x)\n\n    Note however that precedence rules for `|` are different from `or`.\n\n    In the context of a pylog program, you can also use `or`:\n\n    ```assert FriendOf(x, y) | FriendOf(y, x)```\n\n    As in CL, ``Or()`` means False\n    \"\"\"\n\n    def __init__(self, *operands, **kwargs):\n        super().__init__(*operands, **kwargs)\n\n    def __str__(self):\n        return f'({\") | (\".join(str(op) for op in self.operands)})'\n\n    def __repr__(self):\n        return f'Or({\", \".join(repr(op) for op in self.operands)})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Not","title":"<code>Not</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BooleanSentence</code></p> <p>A complement of a sentence</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; y = Variable('y')\n&gt;&gt;&gt; s = Not(Term('friend_of', x, y))\n&gt;&gt;&gt; s.negated\nfriend_of(?x, ?y)\n</code></pre> <p>You can also use syntactic sugar:</p> <pre><code>&gt;&gt;&gt; s = ~Term('friend_of', x, y)\n</code></pre> <p>In the context of a pylog program, you can also use <code>not</code>:</p> <p><code>assert not FriendOf(x, y)</code></p> <p>This SHOULD be interpreted as strict negation, not as failure.</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Not(BooleanSentence):\n    \"\"\"\n    A complement of a sentence\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; y = Variable('y')\n        &gt;&gt;&gt; s = Not(Term('friend_of', x, y))\n        &gt;&gt;&gt; s.negated\n        friend_of(?x, ?y)\n\n    You can also use syntactic sugar:\n\n        &gt;&gt;&gt; s = ~Term('friend_of', x, y)\n\n    In the context of a pylog program, you can also use `not`:\n\n    ```assert not FriendOf(x, y)```\n\n    This SHOULD be interpreted as strict negation, not as failure.\n    \"\"\"\n\n    def __init__(self, operand, **kwargs):\n        super().__init__(operand, **kwargs)\n\n    def __str__(self):\n        return f'~{self.operands[0]}'\n\n    def __repr__(self):\n        return f'Not({repr(self.operands[0])})'\n\n    @property\n    def negated(self) -&gt; Sentence:\n        \"\"\"\n        The negated sentence\n        :return: Sentence\n        \"\"\"\n        return self.operands[0]\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Not.negated","title":"<code>negated: Sentence</code>  <code>property</code>","text":"<p>The negated sentence</p> <p>Returns:</p> Type Description <code>Sentence</code> <p>Sentence</p>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Xor","title":"<code>Xor</code>","text":"<p>               Bases: <code>BooleanSentence</code></p> <p>An exclusive or of sentences</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>class Xor(BooleanSentence):\n    \"\"\"\n    An exclusive or of sentences\n    \"\"\"\n\n    def __init__(self, left, right, **kwargs):\n        super().__init__(left, right, **kwargs)\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.ExactlyOne","title":"<code>ExactlyOne</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BooleanSentence</code></p> <p>Exactly one of the sentences is true</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; s = ExactlyOne(Term('likes', x, \"root beer\"), Term('likes', x, \"marmite\"))\n</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass ExactlyOne(BooleanSentence):\n    \"\"\"\n    Exactly one of the sentences is true\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; s = ExactlyOne(Term('likes', x, \"root beer\"), Term('likes', x, \"marmite\"))\n\n    \"\"\"\n\n    def __init__(self, *operands, **kwargs):\n        super().__init__(*operands, **kwargs)\n\n    def __str__(self):\n        return f'({\") x| (\".join(str(op) for op in self.operands)})'\n\n    def __repr__(self):\n        return f'ExactlyOne({\", \".join(repr(op) for op in self.operands)})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Implication","title":"<code>Implication</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BooleanSentence</code>, <code>ABC</code></p> <p>An abstract grouping of sentences with an implication operator.</p> <pre><code>classDiagram\nImplication &lt;|-- Implies\nImplication &lt;|-- Implied\nImplication &lt;|-- Iff</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Implication(BooleanSentence, ABC):\n    \"\"\"\n    An abstract grouping of sentences with an implication operator.\n\n    ```mermaid\n    classDiagram\n    Implication &lt;|-- Implies\n    Implication &lt;|-- Implied\n    Implication &lt;|-- Iff\n    ```\n\n    \"\"\"\n\n    def __init__(self, left, right, **kwargs):\n        super().__init__(left, right, **kwargs)\n\n    @property\n    def symbol(self):\n        raise NotImplementedError\n\n    def __str__(self):\n        return f'({self.operands[0]} {self.symbol} {self.operands[1]})'\n\n    def __repr__(self):\n        return f'{type(self).__name__}({repr(self.operands[0])}, {repr(self.operands[1])})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Implies","title":"<code>Implies</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Implication</code></p> <p>An if-then implication.</p> <p>Corresponds to Implication in CommonLogic</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; s = Iff(Term('likes', x, \"root beer\"), ~Term('likes', x, \"marmite\"))\n</code></pre> <p>You can also use syntactic sugar:</p> <pre><code>&gt;&gt;&gt; s = Term('likes', x, \"root beer\") &gt;&gt; ~Term('likes', x, \"marmite\")\n</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Implies(Implication):\n    \"\"\"\n    An if-then implication.\n\n    Corresponds to Implication in CommonLogic\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; s = Iff(Term('likes', x, \"root beer\"), ~Term('likes', x, \"marmite\"))\n\n    You can also use syntactic sugar:\n\n        &gt;&gt;&gt; s = Term('likes', x, \"root beer\") &gt;&gt; ~Term('likes', x, \"marmite\")\n\n    \"\"\"\n\n    def __init__(self, antecedent, consequent, **kwargs):\n        super().__init__(antecedent, consequent, **kwargs)\n\n    @property\n    def symbol(self):\n        return \"-&gt;\"\n\n    @property\n    def antecedent(self):\n        return self.operands[0]\n\n    @property\n    def consequent(self):\n        return self.operands[1]\n\n    def __str__(self):\n        return f'({self.operands[0]} -&gt; {self.operands[1]})'\n\n    def __repr__(self):\n        return f'Implies({repr(self.operands[0])}, {repr(self.operands[1])})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Implied","title":"<code>Implied</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Implication</code></p> <p>An implication of the form consequent &lt;- antecedent</p> <p>Inverse of <code>Implies</code></p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Implied(Implication):\n    \"\"\"\n    An implication of the form consequent &lt;- antecedent\n\n    Inverse of `Implies`\n    \"\"\"\n\n    def __init__(self, consequent, antecedent, **kwargs):\n        super().__init__(consequent, antecedent, **kwargs)\n\n    @property\n    def symbol(self):\n        return \"&lt;-\"\n\n    @property\n    def antecedent(self):\n        return self.operands[1]\n\n    @property\n    def consequent(self):\n        return self.operands[0]\n\n\n    def __str__(self):\n        return f'({self.operands[0]} &lt;- {self.operands[1]})'\n\n    def __repr__(self):\n        return f'Implied({repr(self.operands[0])}, {repr(self.operands[1])})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Iff","title":"<code>Iff</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Implication</code></p> <p>An equivalence of sentences</p> <p>Corresponds to Biconditional in CommonLogic.</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; s = Iff(Term('likes', x, \"jaffa cakes\"), Term('likes', x, \"marmite\"))\n</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Iff(Implication):\n    \"\"\"\n    An equivalence of sentences\n\n    Corresponds to Biconditional in CommonLogic.\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; s = Iff(Term('likes', x, \"jaffa cakes\"), Term('likes', x, \"marmite\"))\n\n    \"\"\"\n\n    def __init__(self, left, right, **kwargs):\n        super().__init__(left, right, **kwargs)\n\n    @property\n    def symbol(self):\n        return \"&lt;-&gt;\"\n\n    @property\n    def left(self):\n        return self.operands[0]\n\n    @property\n    def right(self):\n        return self.operands[1]\n\n    def __str__(self):\n        return f'({self.operands[0]} &lt;-&gt; {self.operands[1]})'\n\n    def __repr__(self):\n        return f'Iff({repr(self.operands[0])}, {repr(self.operands[1])})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.NegationAsFailure","title":"<code>NegationAsFailure</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BooleanSentence</code></p> <p>A negated sentence, interpreted via negation as failure semantics.</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass NegationAsFailure(BooleanSentence):\n    \"\"\"\n    A negated sentence, interpreted via negation as failure semantics.\n    \"\"\"\n\n    def __init__(self, operand, **kwargs):\n        super().__init__(operand, **kwargs)\n\n    @property\n    def negated(self):\n        return self.operands[0]\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.QuantifiedSentence","title":"<code>QuantifiedSentence</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Sentence</code>, <code>ABC</code></p> <p>A sentence with a logical quantifier.</p> <pre><code>classDiagram\nQuantifiedSentence &lt;|-- Forall\nQuantifiedSentence &lt;|-- Exists\nQuantifiedSentence --&gt; \"*\" Variable : variables</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass QuantifiedSentence(Sentence, ABC):\n    \"\"\"\n    A sentence with a logical quantifier.\n\n    ```mermaid\n    classDiagram\n    QuantifiedSentence &lt;|-- Forall\n    QuantifiedSentence &lt;|-- Exists\n    QuantifiedSentence --&gt; \"*\" Variable : variables\n    ```\n\n    \"\"\"\n\n    variables: List[Variable]\n    sentence: Sentence\n    _annotations: Optional[Dict[str, Any]] = None\n\n    @property\n    def quantifier(self) -&gt; str:\n        raise NotImplementedError\n\n    def _bindings_str(self) -&gt; str:\n        return \", \".join(f\"{v.name}: {v.domain}\" for v in self.variables)\n\n    def __hash__(self):\n        return hash((self.quantifier, tuple(self.variables), self.sentence))\n\n    def as_sexpr(self) -&gt; SExpression:\n        return [type(self).__name__, [v.as_sexpr() for v in self.variables], self.sentence.as_sexpr()]\n\n    @property\n    def arguments(self) -&gt; List[Any]:\n        return [self.variables, self.sentence]\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Forall","title":"<code>Forall</code>  <code>dataclass</code>","text":"<p>               Bases: <code>QuantifiedSentence</code></p> <p>Universal quantifier.</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; y = Variable('y')\n&gt;&gt;&gt; s = Forall([x, y], Implies(Term('friend_of', x, y), Term('friend_of', y, x)))\n</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Forall(QuantifiedSentence):\n    \"\"\"\n    Universal quantifier.\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; y = Variable('y')\n        &gt;&gt;&gt; s = Forall([x, y], Implies(Term('friend_of', x, y), Term('friend_of', y, x)))\n\n    \"\"\"\n\n    @property\n    def quantifier(self) -&gt; str:\n        return \"all\"\n\n    def __str__(self):\n        return f'\u2200{self._bindings_str()} : {self.sentence}'\n\n    def __repr__(self):\n        return f'Forall([{self._bindings_str()}] : {repr(self.sentence)})'\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Exists","title":"<code>Exists</code>  <code>dataclass</code>","text":"<p>               Bases: <code>QuantifiedSentence</code></p> <p>Existential quantifier.</p> <pre><code>&gt;&gt;&gt; x = Variable('x')\n&gt;&gt;&gt; y = Variable('y')\n&gt;&gt;&gt; s = ~Exists([x, y], And(Term('friend_of', x, y), Term('enemy_of', x, y)))\n</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Exists(QuantifiedSentence):\n    \"\"\"\n    Existential quantifier.\n\n        &gt;&gt;&gt; x = Variable('x')\n        &gt;&gt;&gt; y = Variable('y')\n        &gt;&gt;&gt; s = ~Exists([x, y], And(Term('friend_of', x, y), Term('enemy_of', x, y)))\n\n    \"\"\"\n\n    @property\n    def quantifier(self) -&gt; str:\n        return \"exists\"\n\n    def __str__(self):\n        return f'\u2203{self.sentence}'\n\n    def __repr__(self):\n        return f'Exists({self._bindings_str()} : {repr(self.sentence)})'\n\n    def __hash__(self):\n        return hash((self.quantifier, self._bindings_str(), self.sentence))\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.SentenceGroup","title":"<code>SentenceGroup</code>  <code>dataclass</code>","text":"<p>A logical grouping of related sentences with common documentation.</p> <p>One way to collect these is via a decorated python function.</p> <p>```mermaid classDiagram class SentenceGroup {     +String name     +SentenceGroupType group_type     +String docstring     +Dict annotations } SentenceGroup --&gt; \"*\" Sentence : sentences</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass SentenceGroup:\n    \"\"\"\n    A logical grouping of related sentences with common documentation.\n\n    One way to collect these is via a decorated python function.\n\n    ```mermaid\n    classDiagram\n    class SentenceGroup {\n        +String name\n        +SentenceGroupType group_type\n        +String docstring\n        +Dict annotations\n    }\n    SentenceGroup --&gt; \"*\" Sentence : sentences\n\n    \"\"\"\n\n    name: str\n    group_type: Optional[SentenceGroupType] = None\n    docstring: Optional[str] = None\n    sentences: Optional[List[Sentence]] = None\n    _annotations: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Theory","title":"<code>Theory</code>  <code>dataclass</code>","text":"<p>A collection of predicate definitions and sentences.</p> <p>Analogous to a Text in CommonLogic.</p> <pre><code>classDiagram\nclass Theory {\n    +String name\n    +Dict constants\n    +Dict type_definitions\n    +List predicate_definitions\n    +List sentence_groups\n    +List ground_terms\n    +Dict annotations\n}\nTheory --&gt; \"*\" DefinedType : type_definitions\nTheory --&gt; \"*\" PredicateDefinition : predicate_definitions\nTheory --&gt; \"*\" Term : ground_terms\nTheory --&gt; \"*\" SentenceGroup : sentence_groups</code></pre> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>@dataclass\nclass Theory:\n    \"\"\"\n    A collection of predicate definitions and sentences.\n\n    Analogous to a Text in CommonLogic.\n\n    ```mermaid\n    classDiagram\n    class Theory {\n        +String name\n        +Dict constants\n        +Dict type_definitions\n        +List predicate_definitions\n        +List sentence_groups\n        +List ground_terms\n        +Dict annotations\n    }\n    Theory --&gt; \"*\" DefinedType : type_definitions\n    Theory --&gt; \"*\" PredicateDefinition : predicate_definitions\n    Theory --&gt; \"*\" Term : ground_terms\n    Theory --&gt; \"*\" SentenceGroup : sentence_groups\n    ```\n\n    \"\"\"\n\n    name: Optional[str] = None\n    constants: Dict[str, Any] = field(default_factory=dict)\n    type_definitions: Dict[str, DefinedType] = field(default_factory=dict)\n    predicate_definitions: List[PredicateDefinition] = field(default_factory=list)\n    sentence_groups: List[SentenceGroup] = field(default_factory=list)\n    ground_terms: List[Term] = field(default_factory=list)\n    _annotations: Optional[Dict[str, Any]] = None\n    source_module_name: Optional[str] = None\n\n    @property\n    def sentences(self) -&gt; List[Sentence]:\n        \"\"\"\n        Return all sentences in the theory\n\n        :return:\n        \"\"\"\n        if self.sentence_groups:\n            return [s for sg in self.sentence_groups for s in sg.sentences or []]\n        return []\n\n    @property\n    def goals(self) -&gt; List[Sentence]:\n        \"\"\"\n        Return all goal sentences in the theory\n\n        :return:\n        \"\"\"\n        return [s for sg in self.sentence_groups or [] if sg.group_type == SentenceGroupType.GOAL for s in sg.sentences or []]\n\n    def add(self, sentence: Sentence):\n        \"\"\"\n        Add a sentence to the theory\n\n        :param sentence:\n        :return:\n        \"\"\"\n        if isinstance(sentence, Extension):\n            sentence = sentence.to_model_object()\n        if not self.sentence_groups:\n            self.sentence_groups = []\n        self.sentence_groups.append(SentenceGroup(name=\"Sentences\", sentences=[sentence]))\n\n    def remove(self, sentence: Sentence, strict=False):\n        \"\"\"\n        Remove a sentence to the theory\n\n        :param sentence:\n        :param strict:\n        :return:\n        \"\"\"\n        if isinstance(sentence, Extension):\n            sentence = sentence.to_model_object()\n        if not self.sentence_groups:\n            if strict:\n                raise ValueError(\"No sentences to remove from\")\n            return\n        n = 0\n        for sg in self.sentence_groups:\n            if sg.sentences and sentence in sg.sentences:\n                sg.sentences.remove(sentence)\n                n += 1\n        if n != 1 and strict:\n            raise ValueError(f\"Removed {n} sentences\")\n\n    def unroll_type(self, typ: DefinedType) -&gt; List[str]:\n        \"\"\"\n        Unroll a defined type into its components\n\n        :param typ:\n        :return:\n        \"\"\"\n        if isinstance(typ, str):\n            if typ in self.type_definitions:\n                return self.unroll_type(self.type_definitions[typ])\n            return [typ]\n        if isinstance(typ, list):\n            ts = []\n            for t in typ:\n                ts.extend(self.unroll_type(t))\n            return ts\n        raise ValueError(f\"Unknown type {typ}\")\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Theory.sentences","title":"<code>sentences: List[Sentence]</code>  <code>property</code>","text":"<p>Return all sentences in the theory</p> <p>Returns:</p> Type Description <code>List[Sentence]</code>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Theory.goals","title":"<code>goals: List[Sentence]</code>  <code>property</code>","text":"<p>Return all goal sentences in the theory</p> <p>Returns:</p> Type Description <code>List[Sentence]</code>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Theory.add","title":"<code>add(sentence)</code>","text":"<p>Add a sentence to the theory</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>def add(self, sentence: Sentence):\n    \"\"\"\n    Add a sentence to the theory\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, Extension):\n        sentence = sentence.to_model_object()\n    if not self.sentence_groups:\n        self.sentence_groups = []\n    self.sentence_groups.append(SentenceGroup(name=\"Sentences\", sentences=[sentence]))\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Theory.remove","title":"<code>remove(sentence, strict=False)</code>","text":"<p>Remove a sentence to the theory</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>strict</code> <code>False</code> <p>Returns:</p> Type Description Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>def remove(self, sentence: Sentence, strict=False):\n    \"\"\"\n    Remove a sentence to the theory\n\n    :param sentence:\n    :param strict:\n    :return:\n    \"\"\"\n    if isinstance(sentence, Extension):\n        sentence = sentence.to_model_object()\n    if not self.sentence_groups:\n        if strict:\n            raise ValueError(\"No sentences to remove from\")\n        return\n    n = 0\n    for sg in self.sentence_groups:\n        if sg.sentences and sentence in sg.sentences:\n            sg.sentences.remove(sentence)\n            n += 1\n    if n != 1 and strict:\n        raise ValueError(f\"Removed {n} sentences\")\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.Theory.unroll_type","title":"<code>unroll_type(typ)</code>","text":"<p>Unroll a defined type into its components</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>DefinedType</code> required <p>Returns:</p> Type Description <code>List[str]</code> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>def unroll_type(self, typ: DefinedType) -&gt; List[str]:\n    \"\"\"\n    Unroll a defined type into its components\n\n    :param typ:\n    :return:\n    \"\"\"\n    if isinstance(typ, str):\n        if typ in self.type_definitions:\n            return self.unroll_type(self.type_definitions[typ])\n        return [typ]\n    if isinstance(typ, list):\n        ts = []\n        for t in typ:\n            ts.extend(self.unroll_type(t))\n        return ts\n    raise ValueError(f\"Unknown type {typ}\")\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.NotInProfileError","title":"<code>NotInProfileError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when a sentence is not in some profile</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>class NotInProfileError(ValueError):\n    \"\"\"\n    Raised when a sentence is not in some profile\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.term","title":"<code>term(predicate, *args, **kwargs)</code>","text":"<p>Create a term object.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Union[str, Type[Extension], Extension]</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Term</code> <p>Term object</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>def term(predicate: Union[str, Type[Extension], Extension], *args, **kwargs) -&gt; Term:\n    \"\"\"\n    Create a term object.\n\n    :param predicate:\n    :param args:\n    :param kwargs:\n    :return: Term object\n    \"\"\"\n    if isinstance(predicate, Extension):\n        s = predicate.to_model_object()\n        if isinstance(s, Term):\n            return s\n        else:\n            raise ValueError(f\"Cannot convert {predicate} to a Term\")\n    if isinstance(predicate, type):\n        predicate = predicate.__name__\n    return Term(predicate, *args, **kwargs)\n</code></pre>"},{"location":"concepts/datamodel/#typedlogic.datamodel.not_provable","title":"<code>not_provable(predicate)</code>","text":"<p>Function for Negation as Failure</p> Source code in <code>src/typedlogic/datamodel.py</code> <pre><code>def not_provable(predicate):\n    \"\"\"Function for Negation as Failure\"\"\"\n    return NegationAsFailure(predicate)\n</code></pre>"},{"location":"concepts/decorators/","title":"Decorators","text":"<p>Decorators for marking functions as axioms and goals.</p> <p>Example:</p> <pre><code>    from dataclasses import dataclass\n    from typedlogic import Fact\n    from typedlogic.decorators import axiom, goal\n\n    @dataclass\n    class Dog(Fact):\n        unique_name: str\n\n    @dataclass\n    class Cat(Fact):\n        unique_name: str\n\n    @axiom\n    def disjointness(n: str):\n        '''Nothing os both a dog and a cat'''\n        assert not(Dog(n) and Cat(n))\n\n    @goal\n    def unit_test1():\n        '''unit test: if Violet is a cat, then it must be provable that Violet is not a dog```\n        if Cat('Violet'):\n           assert not Dog('Violet')\n</code></pre> <p>Note: when axioms are expressed directly in python programs, it is possible to use logical connectives such as <code>and</code>, <code>or</code>, as well as <code>if...then</code> to express implication.</p> <p>When working directly with objects in the datamodel, it's necessary to use symbols such as <code>&amp;</code> and <code>~</code>.</p>"},{"location":"concepts/decorators/#typedlogic.decorators.axiom","title":"<code>axiom(func)</code>","text":"<p>Decorator to mark a function as an axiom.</p> <p>The marked function is not intended to be executed in a standard python environment.</p> <p>The arguments to the function are treated as universally quantified variables</p> <p>Example usage:</p> <pre><code>from dataclasses import dataclass\nfrom typedlogic import Fact\nfrom typedlogic.decorators import axiom, goal\n\n@dataclass\nclass Dog(Fact):\n    unique_name: str\n\n@dataclass\nclass Cat(Fact):\n    unique_name: str\n\n@axiom\ndef disjointness(n: str):\n    '''Forall n: Dog(n) =&gt; not Cat(n)'''\n    assert not(Dog(n) and Cat(n))\n</code></pre> <p>The arguments of the wrapped functions are treated as universal quantifiers (Forall x: ...)</p> Source code in <code>src/typedlogic/decorators.py</code> <pre><code>def axiom(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to mark a function as an axiom.\n\n    The marked function is not intended to be executed in a standard python environment.\n\n    The arguments to the function are treated as universally quantified variables\n\n    Example usage:\n\n        from dataclasses import dataclass\n        from typedlogic import Fact\n        from typedlogic.decorators import axiom, goal\n\n        @dataclass\n        class Dog(Fact):\n            unique_name: str\n\n        @dataclass\n        class Cat(Fact):\n            unique_name: str\n\n        @axiom\n        def disjointness(n: str):\n            '''Forall n: Dog(n) =&gt; not Cat(n)'''\n            assert not(Dog(n) and Cat(n))\n\n    The arguments of the wrapped functions are treated as universal quantifiers (Forall x: ...)\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n\n    AXIOM_REGISTRY.append(func)\n    return wrapper\n</code></pre>"},{"location":"concepts/decorators/#typedlogic.decorators.goal","title":"<code>goal(func)</code>","text":"<p>Decorator to mark a function as a goal.</p> <p>The <code>prove_goals</code> function in a Solver object will attempt to prove the goal.</p> <p>The function is not intended to be called directly, but rather to be interpreted using logical semantics.</p> Source code in <code>src/typedlogic/decorators.py</code> <pre><code>def goal(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to mark a function as a goal.\n\n    The `prove_goals` function in a Solver object will attempt to prove the goal.\n\n    The function is not intended to be called directly, but rather to be interpreted\n    using logical semantics.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n\n    # AXIOM_REGISTRY.append(func)\n    return wrapper\n</code></pre>"},{"location":"concepts/generators/","title":"Generators","text":"<p>Generators can be used to create universally quantified variables in a way that preserves type safety.</p> <p>Example:</p> <pre><code>TreeNodeType = str\n\nclass AncestorOf(BaseModel, Fact):\n    ancestor: TreeNodeType\n    descendant: TreeNodeType\n\n@axiom\ndef ancestor_transitivity_axiom() -&gt; bool:\n    '''For all x,y,z, if AncestorOf(x,z) and AncestorOf(z,y), then AncestorOf(x,y)'''\n    return all(\n        AncestorOf(ancestor=x, descendant=y)\n        for x, y, z in gen3(TreeNodeType, TreeNodeType, TreeNodeType)\n        if AncestorOf(ancestor=x, descendant=z) and AncestorOf(ancestor=z, descendant=y)\n    )\n</code></pre> <p>The above axiom defines a universally quantified statement over the variables x, y, and z, whose range is all strings.</p> <p>Note that while the semantics of the above program are consistent with Python semantics, actually executing the above code would take infinite time as there are infinite strings. Instead, the python is treated as a logical specification.</p>"},{"location":"concepts/generators/#typedlogic.generators.gen","title":"<code>gen(*types)</code>","text":"<p>A generator that yields tuples of values of the specified types.</p> <p>Note: this is more weakly typed than the arity-specific :ref:<code>gen1</code>, :ref:<code>gen2</code>, and :ref:<code>gen3</code> functions.</p> <p>.. note:: These are generally used in defining axioms using python syntax, rather than executed directly.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>Type[Any]</code> <code>()</code> <p>Returns:</p> Type Description <code>Generator[Tuple[Any, ...], None, None]</code> Source code in <code>src/typedlogic/generators.py</code> <pre><code>def gen(*types: Type[Any]) -&gt; Generator[Tuple[Any, ...], None, None]:\n    \"\"\"\n    A generator that yields tuples of values of the specified types.\n\n    Note: this is more weakly typed than the arity-specific :ref:`gen1`, :ref:`gen2`, and :ref:`gen3` functions.\n\n    .. note:: These are generally used in defining axioms using python syntax, rather than executed directly.\n\n    :param types:\n    :return:\n    \"\"\"\n    while True:\n        yield tuple(t() for t in types)  # Replace with actual logic\n</code></pre>"},{"location":"concepts/generators/#typedlogic.generators.gen1","title":"<code>gen1(type1)</code>","text":"<p>A generator that yields individual values of the specified type.</p> <p>.. note:: This is generally used in defining axioms using python syntax, rather than executed directly.</p> <p>Parameters:</p> Name Type Description Default <code>type1</code> <code>Type[T1]</code> required <p>Returns:</p> Type Description <code>Generator[T1, None, None]</code> Source code in <code>src/typedlogic/generators.py</code> <pre><code>def gen1(type1: Type[T1]) -&gt; Generator[T1, None, None]:\n    \"\"\"\n    A generator that yields individual values of the specified type.\n\n    .. note:: This is generally used in defining axioms using python syntax, rather than executed directly.\n\n    :param type1:\n    :return:\n    \"\"\"\n    while True:\n        yield type1()  # R\n</code></pre>"},{"location":"concepts/generators/#typedlogic.generators.gen2","title":"<code>gen2(type1, type2)</code>","text":"<p>A generator that yields arity 2 tuples of values of the specified types.</p> <p>.. note:: This is generally used in defining axioms using python syntax, rather than executed directly.</p> <p>Parameters:</p> Name Type Description Default <code>type1</code> <code>Type[T1]</code> required <code>type2</code> <code>Type[T2]</code> required <p>Returns:</p> Type Description <code>Generator[Tuple[T1, T2], None, None]</code> Source code in <code>src/typedlogic/generators.py</code> <pre><code>def gen2(type1: Type[T1], type2: Type[T2]) -&gt; Generator[Tuple[T1, T2], None, None]:\n    \"\"\"\n    A generator that yields arity 2 tuples of values of the specified types.\n\n    .. note:: This is generally used in defining axioms using python syntax, rather than executed directly.\n\n    :param type1:\n    :param type2:\n    :return:\n    \"\"\"\n    while True:\n        yield type1(), type2()  # Replace with actual logic\n</code></pre>"},{"location":"concepts/generators/#typedlogic.generators.gen3","title":"<code>gen3(type1, type2, type3)</code>","text":"<p>A generator that yields arity 3 tuples of values of the specified types.</p> <p>.. note:: This is generally used in defining axioms using python syntax, rather than executed directly.</p> <p>Parameters:</p> Name Type Description Default <code>type1</code> <code>Type[T1]</code> required <code>type2</code> <code>Type[T2]</code> required <code>type3</code> <code>Type[T3]</code> required <p>Returns:</p> Type Description <code>Generator[Tuple[T1, T2, T3], None, None]</code> Source code in <code>src/typedlogic/generators.py</code> <pre><code>def gen3(type1: Type[T1], type2: Type[T2], type3: Type[T3]) -&gt; Generator[Tuple[T1, T2, T3], None, None]:\n    \"\"\"\n    A generator that yields arity 3 tuples of values of the specified types.\n\n    .. note:: This is generally used in defining axioms using python syntax, rather than executed directly.\n\n    :param type1:\n    :param type2:\n    :param type3:\n    :return:\n    \"\"\"\n    while True:\n        yield type1(), type2(), type3()  # Replace with actual logic\n</code></pre>"},{"location":"concepts/models/","title":"Models","text":"<p>A model is a set of ground terms that satisfy a set of axioms.</p> Source code in <code>src/typedlogic/solver.py</code> <pre><code>@dataclass\nclass Model:\n    \"\"\"\n    A model is a set of ground terms that satisfy a set of axioms.\n    \"\"\"\n    description: Optional[str] = None\n    source_object: Optional[Any] = None\n    ground_terms: List[Term] = field(default_factory=list)\n\n    def iter_retrieve(self, predicate: str, *args) -&gt; Iterator[Term]:\n        \"\"\"\n        Retrieve all ground terms with a given predicate.\n\n        :param predicate:\n        :return:\n        \"\"\"\n        for t in self.ground_terms:\n            if t.predicate != predicate:\n                continue\n            if args:\n                is_match = True\n                for i in range(len(args)):\n                    if args[i] is None:\n                        continue\n                    if args[i] != t.values[i]:\n                        is_match = False\n                        break\n                if not is_match:\n                    continue\n            yield t\n</code></pre>"},{"location":"concepts/models/#typedlogic.solver.Model.iter_retrieve","title":"<code>iter_retrieve(predicate, *args)</code>","text":"<p>Retrieve all ground terms with a given predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>str</code> required <p>Returns:</p> Type Description <code>Iterator[Term]</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def iter_retrieve(self, predicate: str, *args) -&gt; Iterator[Term]:\n    \"\"\"\n    Retrieve all ground terms with a given predicate.\n\n    :param predicate:\n    :return:\n    \"\"\"\n    for t in self.ground_terms:\n        if t.predicate != predicate:\n            continue\n        if args:\n            is_match = True\n            for i in range(len(args)):\n                if args[i] is None:\n                    continue\n                if args[i] != t.values[i]:\n                    is_match = False\n                    break\n            if not is_match:\n                continue\n        yield t\n</code></pre>"},{"location":"concepts/parsers/","title":"Parsers","text":""},{"location":"concepts/parsers/#typedlogic.parser.Parser","title":"<code>Parser</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A parser is a class that can parse a source and return a Theory object.</p> <p>You can use the registry <code>get_parser</code> method to get a parser for a particular syntax:</p> <pre><code>&gt;&gt;&gt; from typedlogic.registry import get_parser\n&gt;&gt;&gt; parser = get_parser(\"yaml\")\n</code></pre> Source code in <code>src/typedlogic/parser.py</code> <pre><code>class Parser(ABC):\n    \"\"\"\n    A parser is a class that can parse a source and return a Theory object.\n\n    You can use the registry `get_parser` method to get a parser for a particular syntax:\n\n        &gt;&gt;&gt; from typedlogic.registry import get_parser\n        &gt;&gt;&gt; parser = get_parser(\"yaml\")\n\n\n    \"\"\"\n\n    default_suffix: ClassVar[str] = \"txt\"\n\n    def parse_file(self, source: Union[Path, str, TextIO], **kwargs) -&gt; Theory:\n        if isinstance(source, str):\n            source = Path(source)\n        return self.parse(source, **kwargs)\n\n    @abstractmethod\n    def parse(self, source: Union[Path, str, TextIO], **kwargs) -&gt; Theory:\n        \"\"\"\n        Parse a source and return a Theory object.\n\n        :param source: A path to a file, a string representation of the source, or a file-like object.\n        :param kwargs:\n        :return:\n        \"\"\"\n        pass\n\n    def translate(self, source: Any, **kwargs) -&gt; Theory:\n        \"\"\"\n        Translate a source object into a Theory object.\n\n        The type of the source object may be constrained by individual subclasses\n\n        :param source:\n        :param kwargs:\n        :return:\n        \"\"\"\n        raise NotImplementedError(\"Translation not supported by this parser\")\n</code></pre>"},{"location":"concepts/parsers/#typedlogic.parser.Parser.parse","title":"<code>parse(source, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Parse a source and return a Theory object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[Path, str, TextIO]</code> <p>A path to a file, a string representation of the source, or a file-like object.</p> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Theory</code> Source code in <code>src/typedlogic/parser.py</code> <pre><code>@abstractmethod\ndef parse(self, source: Union[Path, str, TextIO], **kwargs) -&gt; Theory:\n    \"\"\"\n    Parse a source and return a Theory object.\n\n    :param source: A path to a file, a string representation of the source, or a file-like object.\n    :param kwargs:\n    :return:\n    \"\"\"\n    pass\n</code></pre>"},{"location":"concepts/parsers/#typedlogic.parser.Parser.translate","title":"<code>translate(source, **kwargs)</code>","text":"<p>Translate a source object into a Theory object.</p> <p>The type of the source object may be constrained by individual subclasses</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>Theory</code> Source code in <code>src/typedlogic/parser.py</code> <pre><code>def translate(self, source: Any, **kwargs) -&gt; Theory:\n    \"\"\"\n    Translate a source object into a Theory object.\n\n    The type of the source object may be constrained by individual subclasses\n\n    :param source:\n    :param kwargs:\n    :return:\n    \"\"\"\n    raise NotImplementedError(\"Translation not supported by this parser\")\n</code></pre>"},{"location":"concepts/profiles/","title":"Profiles","text":""},{"location":"concepts/profiles/#typedlogic.profiles.Profile","title":"<code>Profile</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A profile of FOL</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Profile(ABC):\n    \"\"\"A profile of FOL\"\"\"\n\n    disjoint_profiles: ClassVar[Set[Type[\"Profile\"]]] = set()\n\n    def impl(self, profile: Type[\"Profile\"]) -&gt; bool:\n        \"\"\"True if self is an implementation of profile.\n\n        Operates under NAF: if it cannot be proven that self is an implementation of profile, it returns None.\n\n        &gt;&gt;&gt; p = WellFoundedSemantics()\n        &gt;&gt;&gt; p.impl(WellFoundedSemantics)\n        True\n        &gt;&gt;&gt; p.impl(ClosedWorld)\n        True\n        &gt;&gt;&gt; p.impl(OpenWorld)\n        False\n\n        \"\"\"\n        return isinstance(self, profile)\n\n    def not_impl(self, profile: Type[\"Profile\"]) -&gt; Optional[bool]:\n        \"\"\"True if self is provably not an implementation of profile\n\n        &gt;&gt;&gt; p = WellFoundedSemantics()\n        &gt;&gt;&gt; p.not_impl(WellFoundedSemantics)\n        False\n        &gt;&gt;&gt; p.impl(ClosedWorld)\n        True\n        &gt;&gt;&gt; p.not_impl(ClosedWorld)\n        False\n        &gt;&gt;&gt; p.not_impl(OpenWorld)\n        True\n        &gt;&gt;&gt; assert p.not_impl(SortedLogic) is None\n\n        \"\"\"\n        if self.impl(profile):\n            return False\n        disjoints = profile.disjoint_profiles\n        if disjoints and any(isinstance(self, p) for p in disjoints):\n            return True\n        this_disjoints = type(self).disjoint_profiles\n        if this_disjoints and any(issubclass(profile, p) for p in this_disjoints):\n            return True\n        return None\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Profile.impl","title":"<code>impl(profile)</code>","text":"<p>True if self is an implementation of profile.</p> <p>Operates under NAF: if it cannot be proven that self is an implementation of profile, it returns None.</p> <p>p = WellFoundedSemantics() p.impl(WellFoundedSemantics) True p.impl(ClosedWorld) True p.impl(OpenWorld) False</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>def impl(self, profile: Type[\"Profile\"]) -&gt; bool:\n    \"\"\"True if self is an implementation of profile.\n\n    Operates under NAF: if it cannot be proven that self is an implementation of profile, it returns None.\n\n    &gt;&gt;&gt; p = WellFoundedSemantics()\n    &gt;&gt;&gt; p.impl(WellFoundedSemantics)\n    True\n    &gt;&gt;&gt; p.impl(ClosedWorld)\n    True\n    &gt;&gt;&gt; p.impl(OpenWorld)\n    False\n\n    \"\"\"\n    return isinstance(self, profile)\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Profile.not_impl","title":"<code>not_impl(profile)</code>","text":"<p>True if self is provably not an implementation of profile</p> <p>p = WellFoundedSemantics() p.not_impl(WellFoundedSemantics) False p.impl(ClosedWorld) True p.not_impl(ClosedWorld) False p.not_impl(OpenWorld) True assert p.not_impl(SortedLogic) is None</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>def not_impl(self, profile: Type[\"Profile\"]) -&gt; Optional[bool]:\n    \"\"\"True if self is provably not an implementation of profile\n\n    &gt;&gt;&gt; p = WellFoundedSemantics()\n    &gt;&gt;&gt; p.not_impl(WellFoundedSemantics)\n    False\n    &gt;&gt;&gt; p.impl(ClosedWorld)\n    True\n    &gt;&gt;&gt; p.not_impl(ClosedWorld)\n    False\n    &gt;&gt;&gt; p.not_impl(OpenWorld)\n    True\n    &gt;&gt;&gt; assert p.not_impl(SortedLogic) is None\n\n    \"\"\"\n    if self.impl(profile):\n        return False\n    disjoints = profile.disjoint_profiles\n    if disjoints and any(isinstance(self, p) for p in disjoints):\n        return True\n    this_disjoints = type(self).disjoint_profiles\n    if this_disjoints and any(issubclass(profile, p) for p in this_disjoints):\n        return True\n    return None\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.MixedProfile","title":"<code>MixedProfile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Profile</code></p> <p>A profile that mixes multiple profiles.md</p> <p>p = MixedProfile(Unrestricted(), SortedLogic()) p.impl(Unrestricted) True p.impl(SortedLogic) True</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>@dataclass\nclass MixedProfile(Profile):\n    \"\"\"A profile that mixes multiple profiles.md\n\n    &gt;&gt;&gt; p = MixedProfile(Unrestricted(), SortedLogic())\n    &gt;&gt;&gt; p.impl(Unrestricted)\n    True\n    &gt;&gt;&gt; p.impl(SortedLogic)\n    True\n\n    \"\"\"\n    profiles: Tuple = field(default_factory=tuple)\n\n    def __init__(self, *profiles: Profile):\n        self.profiles = profiles\n\n    def impl(self, profile: Type[\"Profile\"]) -&gt; bool:\n        return isinstance(self, profile) or any(p.impl(profile) for p in self.profiles)\n\n    def not_impl(self, profile: Type[\"Profile\"]) -&gt; Optional[bool]:\n        provably_not_impl = any(p.not_impl(profile) for p in self.profiles)\n        provable_impl = any(p.impl(profile) for p in self.profiles)\n        if provable_impl and provably_not_impl:\n            raise ValueError(f\"Inconsistent profiles.md: {self} is both an implementation and not an implementation of {profile}\")\n        return provably_not_impl\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ExcludedProfile","title":"<code>ExcludedProfile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Profile</code></p> <p>A profile that excludes other profiles.md</p> <p>p = ExcludedProfile(WellFoundedSemantics()) p.impl(WellFoundedSemantics) False p.not_impl(WellFoundedSemantics) True</p> <p>p = MixedProfile(Unrestricted(), SortedLogic(), ExcludedProfile(PropositionalLogic())) p.impl(Unrestricted) True p.impl(PropositionalLogic) False p.not_impl(PropositionalLogic) True</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>@dataclass\nclass ExcludedProfile(Profile):\n    \"\"\"A profile that excludes other profiles.md\n\n    &gt;&gt;&gt; p = ExcludedProfile(WellFoundedSemantics())\n    &gt;&gt;&gt; p.impl(WellFoundedSemantics)\n    False\n    &gt;&gt;&gt; p.not_impl(WellFoundedSemantics)\n    True\n\n    &gt;&gt;&gt; p = MixedProfile(Unrestricted(), SortedLogic(), ExcludedProfile(PropositionalLogic()))\n    &gt;&gt;&gt; p.impl(Unrestricted)\n    True\n    &gt;&gt;&gt; p.impl(PropositionalLogic)\n    False\n    &gt;&gt;&gt; p.not_impl(PropositionalLogic)\n    True\n\n    \"\"\"\n    profile: Profile\n\n    def impl(self, profile: Type[\"Profile\"]) -&gt; bool:\n        \"\"\"True if self is an implementation of profile\"\"\"\n        if self.profile.impl(profile):\n            return False\n        return super().impl(profile)\n\n    def not_impl(self, profile: Type[\"Profile\"]) -&gt; Optional[bool]:\n        \"\"\"True if self is not an implementation of profile\"\"\"\n        if isinstance(self.profile, profile):\n            return True\n        return super().not_impl(profile)\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ExcludedProfile.impl","title":"<code>impl(profile)</code>","text":"<p>True if self is an implementation of profile</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>def impl(self, profile: Type[\"Profile\"]) -&gt; bool:\n    \"\"\"True if self is an implementation of profile\"\"\"\n    if self.profile.impl(profile):\n        return False\n    return super().impl(profile)\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ExcludedProfile.not_impl","title":"<code>not_impl(profile)</code>","text":"<p>True if self is not an implementation of profile</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>def not_impl(self, profile: Type[\"Profile\"]) -&gt; Optional[bool]:\n    \"\"\"True if self is not an implementation of profile\"\"\"\n    if isinstance(self.profile, profile):\n        return True\n    return super().not_impl(profile)\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ComputationalProfile","title":"<code>ComputationalProfile</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A profile that describes the computational properties of a logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ComputationalProfile(Profile, ABC):\n    \"\"\"A profile that describes the computational properties of a logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Decidable","title":"<code>Decidable</code>","text":"<p>               Bases: <code>ComputationalProfile</code></p> <p>The logic is decidable</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Decidable(ComputationalProfile):\n    \"\"\"The logic is decidable\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Undecidable","title":"<code>Undecidable</code>","text":"<p>               Bases: <code>ComputationalProfile</code></p> <p>The logic is undecidable</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Undecidable(ComputationalProfile):\n    \"\"\"The logic is undecidable\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.LogicalFeature","title":"<code>LogicalFeature</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A profile grouping corresponding to a feature of logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class LogicalFeature(Profile, ABC):\n    \"\"\"A profile grouping corresponding to a feature of logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.NegationLogic","title":"<code>NegationLogic</code>","text":"<p>               Bases: <code>LogicalFeature</code></p> <p>The logic has negation</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class NegationLogic(LogicalFeature):\n    \"\"\"The logic has negation\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.DisjunctionLogic","title":"<code>DisjunctionLogic</code>","text":"<p>               Bases: <code>LogicalFeature</code></p> <p>The logic has disjunction</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class DisjunctionLogic(LogicalFeature):\n    \"\"\"The logic has disjunction\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ConjunctionLogic","title":"<code>ConjunctionLogic</code>","text":"<p>               Bases: <code>LogicalFeature</code></p> <p>The logic has conjunction</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ConjunctionLogic(LogicalFeature):\n    \"\"\"The logic has conjunction\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.AllowsComparisonTerms","title":"<code>AllowsComparisonTerms</code>","text":"<p>               Bases: <code>LogicalFeature</code></p> <p>The logic allows comparison terms</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class AllowsComparisonTerms(LogicalFeature):\n    \"\"\"The logic allows comparison terms\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ModelMultiplicitySemantics","title":"<code>ModelMultiplicitySemantics</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A profile grouping corresponding to a model semantics</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ModelMultiplicitySemantics(Profile, ABC):\n    \"\"\"A profile grouping corresponding to a model semantics\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.SingleModelSemantics","title":"<code>SingleModelSemantics</code>","text":"<p>               Bases: <code>ModelMultiplicitySemantics</code></p> <p>The logic has a single model</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class SingleModelSemantics(ModelMultiplicitySemantics):\n    \"\"\"The logic has a single model\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.MultipleModelSemantics","title":"<code>MultipleModelSemantics</code>","text":"<p>               Bases: <code>ModelMultiplicitySemantics</code></p> <p>The logic has multiple models</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class MultipleModelSemantics(ModelMultiplicitySemantics):\n    \"\"\"The logic has multiple models\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Assumption","title":"<code>Assumption</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>Category of assumptions</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Assumption(Profile, ABC):\n    \"\"\"Category of assumptions\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.OpenWorld","title":"<code>OpenWorld</code>","text":"<p>               Bases: <code>Assumption</code></p> <p>The assumption that what is not known to be true is false</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class OpenWorld(Assumption):\n    \"\"\"The assumption that what is not known to be true is false\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ClosedWorld","title":"<code>ClosedWorld</code>","text":"<p>               Bases: <code>Assumption</code></p> <p>The assumption that what is not known to be true is unknown</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ClosedWorld(Assumption):\n    \"\"\"The assumption that what is not known to be true is unknown\"\"\"\n    disjoint_profiles = {OpenWorld}\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.WellFoundedSemantics","title":"<code>WellFoundedSemantics</code>","text":"<p>               Bases: <code>ClosedWorld</code></p> <p>The assumption that the world is well-founded</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class WellFoundedSemantics(ClosedWorld):\n    \"\"\"The assumption that the world is well-founded\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ClassicPrologNegationAsFailure","title":"<code>ClassicPrologNegationAsFailure</code>","text":"<p>               Bases: <code>ClosedWorld</code></p> <p>The assumption that negation is failure</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ClassicPrologNegationAsFailure(ClosedWorld):\n    \"\"\"The assumption that negation is failure\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.TypeSystem","title":"<code>TypeSystem</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>Category of type systems</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class TypeSystem(Profile, ABC):\n    \"\"\"Category of type systems\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.UnsortedLogic","title":"<code>UnsortedLogic</code>","text":"<p>               Bases: <code>TypeSystem</code></p> <p>The logic has no type system</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class UnsortedLogic(TypeSystem):\n    \"\"\"The logic has no type system\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.SortedLogic","title":"<code>SortedLogic</code>","text":"<p>               Bases: <code>TypeSystem</code></p> <p>The logic has a type system</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class SortedLogic(TypeSystem):\n    \"\"\"The logic has a type system\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.LogicalFamily","title":"<code>LogicalFamily</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A profile grouping corresponding to a family of logics</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class LogicalFamily(Profile, ABC):\n    \"\"\"A profile grouping corresponding to a family of logics\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Classical","title":"<code>Classical</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The classical logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Classical(LogicalFamily):\n    \"\"\"The classical logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.NonClassical","title":"<code>NonClassical</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The non-classical logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class NonClassical(LogicalFamily):\n    \"\"\"The non-classical logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Modal","title":"<code>Modal</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The modal logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Modal(LogicalFamily):\n    \"\"\"The modal logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Temporal","title":"<code>Temporal</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The temporal logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Temporal(LogicalFamily):\n    \"\"\"The temporal logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Paraconsistent","title":"<code>Paraconsistent</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The paraconsistent logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Paraconsistent(LogicalFamily):\n    \"\"\"The paraconsistent logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Intuitionistic","title":"<code>Intuitionistic</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The intuitionistic logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Intuitionistic(LogicalFamily):\n    \"\"\"The intuitionistic logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Probabilistic","title":"<code>Probabilistic</code>","text":"<p>               Bases: <code>LogicalFamily</code></p> <p>The probabilistic logic family</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Probabilistic(LogicalFamily):\n    \"\"\"The probabilistic logic family\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.LogicalSubset","title":"<code>LogicalSubset</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A profile grouping corresponding to a subset of logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class LogicalSubset(Profile, ABC):\n    \"\"\"A profile grouping corresponding to a subset of logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Unrestricted","title":"<code>Unrestricted</code>","text":"<p>               Bases: <code>LogicalSubset</code>, <code>Undecidable</code></p> <p>The an unrestricted logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Unrestricted(LogicalSubset, Undecidable):\n    \"\"\"The an unrestricted logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ClassicDatalog","title":"<code>ClassicDatalog</code>","text":"<p>               Bases: <code>LogicalSubset</code>, <code>ClosedWorld</code>, <code>SingleModelSemantics</code></p> <p>A subset of logic that corresponds to Datalog</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ClassicDatalog(LogicalSubset, ClosedWorld, SingleModelSemantics):\n    \"\"\"A subset of logic that corresponds to Datalog\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.DisjunctiveDatalog","title":"<code>DisjunctiveDatalog</code>","text":"<p>               Bases: <code>LogicalSubset</code>, <code>ClosedWorld</code>, <code>MultipleModelSemantics</code></p> <p>A subset of logic that corresponds to Datalog</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class DisjunctiveDatalog(LogicalSubset, ClosedWorld, MultipleModelSemantics):\n    \"\"\"A subset of logic that corresponds to Datalog\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.DescriptionLogic","title":"<code>DescriptionLogic</code>","text":"<p>               Bases: <code>LogicalSubset</code>, <code>Decidable</code></p> <p>A subset of logic that corresponds to Description Logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class DescriptionLogic(LogicalSubset, Decidable):\n    \"\"\"A subset of logic that corresponds to Description Logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.OWLProfile","title":"<code>OWLProfile</code>","text":"<p>               Bases: <code>LogicalSubset</code>, <code>ABC</code></p> <p>The OWL 2 DL subset of Description Logic.</p> <p>Note al OWL Profile is not necessarily a DL profile</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class OWLProfile(LogicalSubset, ABC):\n    \"\"\"The OWL 2 DL subset of Description Logic.\n\n    Note al OWL Profile is not necessarily a DL profile\n    \"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.OWL2DL","title":"<code>OWL2DL</code>","text":"<p>               Bases: <code>DescriptionLogic</code>, <code>OWLProfile</code></p> <p>The OWL 2 DL subset of Description Logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class OWL2DL(DescriptionLogic, OWLProfile):\n    \"\"\"The OWL 2 DL subset of Description Logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ModalLogic","title":"<code>ModalLogic</code>","text":"<p>               Bases: <code>LogicalSubset</code></p> <p>A subset of logic that corresponds to Modal Logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ModalLogic(LogicalSubset):\n    \"\"\"A subset of logic that corresponds to Modal Logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.OrderOfLogic","title":"<code>OrderOfLogic</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>Category of orderings</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class OrderOfLogic(Profile, ABC):\n    \"\"\"Category of orderings\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.PropositionalLogic","title":"<code>PropositionalLogic</code>","text":"<p>               Bases: <code>OrderOfLogic</code></p> <p>The assumption that all predicates are propositional</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class PropositionalLogic(OrderOfLogic):\n    \"\"\"The assumption that all predicates are propositional\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.FirstOrder","title":"<code>FirstOrder</code>","text":"<p>               Bases: <code>OrderOfLogic</code></p> <p>The assumption that all predicates are first-order</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class FirstOrder(OrderOfLogic):\n    \"\"\"The assumption that all predicates are first-order\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.HigherOrder","title":"<code>HigherOrder</code>","text":"<p>               Bases: <code>OrderOfLogic</code></p> <p>The assumption that predicates may be higher-order</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class HigherOrder(OrderOfLogic):\n    \"\"\"The assumption that predicates may be higher-order\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.NamedLogic","title":"<code>NamedLogic</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A named logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class NamedLogic(Profile, ABC):\n    \"\"\"A named logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.AnswerSetProgramming","title":"<code>AnswerSetProgramming</code>","text":"<p>               Bases: <code>NamedLogic</code>, <code>WellFoundedSemantics</code>, <code>DisjunctiveDatalog</code></p> <p>The Answer Set Programming logic</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class AnswerSetProgramming(NamedLogic, WellFoundedSemantics, DisjunctiveDatalog):\n    \"\"\"The Answer Set Programming logic\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ReasoningParadigm","title":"<code>ReasoningParadigm</code>","text":"<p>               Bases: <code>Profile</code>, <code>ABC</code></p> <p>A profile grouping corresponding to a reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ReasoningParadigm(Profile, ABC):\n    \"\"\"A profile grouping corresponding to a reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Inductive","title":"<code>Inductive</code>","text":"<p>               Bases: <code>ReasoningParadigm</code></p> <p>The inductive reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Inductive(ReasoningParadigm):\n    \"\"\"The inductive reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Deductive","title":"<code>Deductive</code>","text":"<p>               Bases: <code>ReasoningParadigm</code></p> <p>The deductive reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Deductive(ReasoningParadigm):\n    \"\"\"The deductive reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Abductive","title":"<code>Abductive</code>","text":"<p>               Bases: <code>ReasoningParadigm</code></p> <p>The abductive reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Abductive(ReasoningParadigm):\n    \"\"\"The abductive reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.Monotonic","title":"<code>Monotonic</code>","text":"<p>               Bases: <code>ReasoningParadigm</code></p> <p>The monotonic reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class Monotonic(ReasoningParadigm):\n    \"\"\"The monotonic reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.NonMonotonic","title":"<code>NonMonotonic</code>","text":"<p>               Bases: <code>ReasoningParadigm</code></p> <p>The non-monotonic reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class NonMonotonic(ReasoningParadigm):\n    \"\"\"The non-monotonic reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.ConstraintSolver","title":"<code>ConstraintSolver</code>","text":"<p>               Bases: <code>ReasoningParadigm</code></p> <p>The constraint solver reasoning paradigm</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class ConstraintSolver(ReasoningParadigm):\n    \"\"\"The constraint solver reasoning paradigm\"\"\"\n</code></pre>"},{"location":"concepts/profiles/#typedlogic.profiles.UnspecifiedProfile","title":"<code>UnspecifiedProfile</code>","text":"<p>               Bases: <code>Profile</code></p> <p>An unspecified profile</p> Source code in <code>src/typedlogic/profiles.py</code> <pre><code>class UnspecifiedProfile(Profile):\n    \"\"\"An unspecified profile\"\"\"\n</code></pre>"},{"location":"concepts/solvers/","title":"Solvers","text":"<p>               Bases: <code>ABC</code></p> <p>A solver is a class that can check a set of axioms for consistency, satisfiability, or some other property.</p> <p>This is an abstract class that defines the interface for a solver.</p> <p>You can retrieve a specific solver with the <code>get_solver</code> function:</p> <pre><code>&gt;&gt;&gt; from typedlogic.registry import get_solver\n&gt;&gt;&gt; solver = get_solver(\"clingo\")\n</code></pre> <p>Once you has a solver, you can can add theories, or individual sentences to it:</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n&gt;&gt;&gt; from typedlogic import Term, Variable\n&gt;&gt;&gt; x = Variable(\"x\")\n&gt;&gt;&gt; y = Variable(\"y\")\n&gt;&gt;&gt; z = Variable(\"z\")\n&gt;&gt;&gt; solver.add( (Term(\"AncestorOf\", x, z) &amp; Term(\"AncestorOf\", z, y)) &gt;&gt; Term(\"AncestorOf\", x, y))\n</code></pre> <p>And facts:</p> <pre><code>&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n&gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n&gt;&gt;&gt; solver.add_sentence_group(aa)\n</code></pre> <p>The <code>check</code> method ensures the theory and ground terms (data) are consistent:</p> <pre><code>&gt;&gt;&gt; soln = solver.check()\n&gt;&gt;&gt; soln.satisfiable\nTrue\n</code></pre> <p>You can then query for models:</p> <pre><code>&gt;&gt;&gt; model = solver.model()\n&gt;&gt;&gt; for t in model.ground_terms:\n...     print(t)\nAncestorOf(p1, p1a)\nAncestorOf(p1a, p1aa)\nAncestorOf(p1, p1aa)\n</code></pre> Source code in <code>src/typedlogic/solver.py</code> <pre><code>@dataclass\nclass Solver(ABC):\n    \"\"\"\n    A solver is a class that can check a set of axioms for consistency, satisfiability, or some other property.\n\n    This is an abstract class that defines the interface for a solver.\n\n    You can retrieve a specific solver with the `get_solver` function:\n\n        &gt;&gt;&gt; from typedlogic.registry import get_solver\n        &gt;&gt;&gt; solver = get_solver(\"clingo\")\n\n    Once you has a solver, you can can add theories, or individual sentences to it:\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n        &gt;&gt;&gt; from typedlogic import Term, Variable\n        &gt;&gt;&gt; x = Variable(\"x\")\n        &gt;&gt;&gt; y = Variable(\"y\")\n        &gt;&gt;&gt; z = Variable(\"z\")\n        &gt;&gt;&gt; solver.add( (Term(\"AncestorOf\", x, z) &amp; Term(\"AncestorOf\", z, y)) &gt;&gt; Term(\"AncestorOf\", x, y))\n\n    And facts:\n\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n        &gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n        &gt;&gt;&gt; solver.add_sentence_group(aa)\n\n    The `check` method ensures the theory and ground terms (data) are consistent:\n\n        &gt;&gt;&gt; soln = solver.check()\n        &gt;&gt;&gt; soln.satisfiable\n        True\n\n    You can then query for models:\n\n        &gt;&gt;&gt; model = solver.model()\n        &gt;&gt;&gt; for t in model.ground_terms:\n        ...     print(t)\n        AncestorOf(p1, p1a)\n        AncestorOf(p1a, p1aa)\n        AncestorOf(p1, p1aa)\n\n    \"\"\"\n    strict: bool = False\n    method_name: Optional[str] = None\n    methods_supported: ClassVar[Optional[List[Method]]] = None\n    profile: ClassVar[Profile] = UnspecifiedProfile()\n    assume_closed_world: bool = False\n\n    # TODO: move towards this\n    base_theory: Theory = field(default_factory=Theory)\n\n    predicate_definitions: Optional[Dict[str, PredicateDefinition]] = None\n    type_definitions: Dict[str, str] = field(default_factory=dict)\n    constants: Dict[str, Any] = field(default_factory=dict)\n    goals: Optional[List[SentenceGroup]] = None\n\n    @property\n    def method(self) -&gt; Method:\n        if self.methods_supported is None:\n            raise NotImplementedError(\"Solver must define methods_supported\")\n        for m in self.methods_supported:\n            if self.method_name is None and m.is_default:\n                return m\n            if m.name == self.method_name:\n                return m\n        raise ValueError(f\"Method {self.method_name} not supported\")\n\n    @abstractmethod\n    def check(self) -&gt; Solution:\n        pass\n\n    def model(self) -&gt; Model:\n        return next(self.models())\n\n    @abstractmethod\n    def models(self) -&gt; Iterator[Model]:\n        pass\n\n    def prove_goals(self, strict=True) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        if not self.check().satisfiable:\n            raise ValueError(\"Cannot prove goals for unsatisfiable theory\")\n        if not self.goals:\n            raise ValueError(\"No goals to prove\")\n        for goal_group in self.goals:\n            if not goal_group.sentences:\n                raise ValueError(f\"Goal group {goal_group.name} has no sentences\")\n            for sentence in goal_group.sentences:\n                provable = self.prove(sentence)\n                if not provable and strict:\n                    raise ValueError(f\"Goal {sentence} not provable\")\n                yield sentence, provable\n\n    def prove_multiple(self, sentences: List[Sentence]) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        if self.check().satisfiable is False:\n            raise ValueError(\"Cannot prove goals for unsatisfiable theory\")\n        if not sentences:\n            raise ValueError(\"No goals to prove\")\n        for sentence in sentences:\n            provable = self.prove(sentence)\n            yield sentence, provable\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        \"\"\"\n        Prove a sentence.\n\n        :param sentence:\n        :return:\n        \"\"\"\n        if isinstance(sentence, Term):\n            # Note: the default implementation may be highly ineffecient.\n            # it is recommended to override this method in a subclass.\n            has_vars = sentence.variables\n            cls = type(self)\n            new_solver = cls()\n            new_solver.add(self.base_theory)\n            model = self.model()\n            for t in model.iter_retrieve(sentence.predicate):\n                if t == sentence:\n                    return True\n                if has_vars:\n                    if t.predicate == sentence.predicate:\n                        is_match = True\n                        for i in range(len(sentence.values)):\n                            arg_val = sentence.values[i]\n                            if isinstance(arg_val, Variable):\n                                # auto-match (assume existential over whole domain)\n                                continue\n                            if arg_val != t.values[i]:\n                                is_match = False\n                                break\n                        if is_match:\n                            return True\n            return False\n        if isinstance(sentence, Exists):\n            inner = sentence.sentence\n            if isinstance(inner, Term):\n                return self.prove(inner)\n        return None\n\n    def load(self, source: Union[str, Path, TextIO, ModuleType]) -&gt; None:\n        \"\"\"\n        Load a theory from a file.\n\n        :param source:\n        :return:\n        \"\"\"\n        parser = PythonParser()\n        if isinstance(source, ModuleType):\n            theory = parser.transform(source)\n        else:\n            theory = parser.parse(source)\n        self.add(theory)\n\n\n    def add(self, element: Union[ELEMENT, Iterable[ELEMENT]]) -&gt; None:\n        if isinstance(element, (list, abc.Iterator)):\n            for e in element:\n                self.add(e)\n            return\n        if isinstance(element, FactMixin):\n            self.add_fact(element)\n        elif isinstance(element, SentenceGroup):\n            self.add_sentence_group(element)\n        elif isinstance(element, Theory):\n            self.add_theory(element)\n        elif isinstance(element, PredicateDefinition):\n            self.add_predicate_definition(element)\n        elif isinstance(element, Sentence):\n            self.add_sentence(element)\n        else:\n            raise ValueError(f\"Unsupported axiom type: {type(element)}\")\n\n    def add_fact(self, fact: FactMixin):\n        self.base_theory.ground_terms.append(fact_to_term(fact))\n\n    def add_sentence_group(self, sentence_group: SentenceGroup) -&gt; None:\n        self.base_theory.sentence_groups.append(sentence_group)\n        if sentence_group.group_type == SentenceGroupType.GOAL:\n            if not self.goals:\n                self.goals = []\n            self.goals.append(sentence_group)\n        if sentence_group.sentences:\n            for sentence in sentence_group.sentences:\n                self.add_sentence(sentence)\n\n    def add_sentence(self, sentence: Sentence) -&gt; None:\n        if sentence not in self.base_theory.sentences:\n            self.base_theory.sentence_groups.append(SentenceGroup(name=\"dynamic\",\n                                                                  sentences=[sentence]))\n\n    def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n        \"\"\"\n        Add a predicate definition to the solver.\n\n        Some solvers do not need predicate definitions (for example, classic prolog systems, as well\n        as pure FOL solvers). However, many solvers need some kind of typing information.\n\n        :param predicate_definition:\n        :return:\n        \"\"\"\n        self.base_theory.predicate_definitions.append(predicate_definition)\n\n    def add_theory(self, theory: Theory) -&gt; None:\n        if theory.constants:\n            for k, v in theory.constants.items():\n                self.constants[k] = v\n                self.base_theory.constants[k] = v\n        if theory.type_definitions:\n            for k, v in theory.type_definitions.items():\n                self.type_definitions[k] = v\n                self.base_theory.type_definitions[k] = v\n        if theory.predicate_definitions:\n            for p in theory.predicate_definitions:\n                self.add_predicate_definition(p)\n        if theory.sentence_groups:\n            for aa in theory.sentence_groups:\n                self.add_sentence_group(aa)\n        if theory.ground_terms:\n            for t in theory.ground_terms:\n                self.add(t)\n\n\n    def dump(self) -&gt; str:\n        \"\"\"\n        Dump the internal state of the solver as a string.\n\n        :return:\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"concepts/solvers/#typedlogic.solver.Solver.prove","title":"<code>prove(sentence)</code>","text":"<p>Prove a sentence.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Optional[bool]</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n    \"\"\"\n    Prove a sentence.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, Term):\n        # Note: the default implementation may be highly ineffecient.\n        # it is recommended to override this method in a subclass.\n        has_vars = sentence.variables\n        cls = type(self)\n        new_solver = cls()\n        new_solver.add(self.base_theory)\n        model = self.model()\n        for t in model.iter_retrieve(sentence.predicate):\n            if t == sentence:\n                return True\n            if has_vars:\n                if t.predicate == sentence.predicate:\n                    is_match = True\n                    for i in range(len(sentence.values)):\n                        arg_val = sentence.values[i]\n                        if isinstance(arg_val, Variable):\n                            # auto-match (assume existential over whole domain)\n                            continue\n                        if arg_val != t.values[i]:\n                            is_match = False\n                            break\n                    if is_match:\n                        return True\n        return False\n    if isinstance(sentence, Exists):\n        inner = sentence.sentence\n        if isinstance(inner, Term):\n            return self.prove(inner)\n    return None\n</code></pre>"},{"location":"concepts/solvers/#typedlogic.solver.Solver.load","title":"<code>load(source)</code>","text":"<p>Load a theory from a file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path, TextIO, ModuleType]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def load(self, source: Union[str, Path, TextIO, ModuleType]) -&gt; None:\n    \"\"\"\n    Load a theory from a file.\n\n    :param source:\n    :return:\n    \"\"\"\n    parser = PythonParser()\n    if isinstance(source, ModuleType):\n        theory = parser.transform(source)\n    else:\n        theory = parser.parse(source)\n    self.add(theory)\n</code></pre>"},{"location":"concepts/solvers/#typedlogic.solver.Solver.add_predicate_definition","title":"<code>add_predicate_definition(predicate_definition)</code>","text":"<p>Add a predicate definition to the solver.</p> <p>Some solvers do not need predicate definitions (for example, classic prolog systems, as well as pure FOL solvers). However, many solvers need some kind of typing information.</p> <p>Parameters:</p> Name Type Description Default <code>predicate_definition</code> <code>PredicateDefinition</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n    \"\"\"\n    Add a predicate definition to the solver.\n\n    Some solvers do not need predicate definitions (for example, classic prolog systems, as well\n    as pure FOL solvers). However, many solvers need some kind of typing information.\n\n    :param predicate_definition:\n    :return:\n    \"\"\"\n    self.base_theory.predicate_definitions.append(predicate_definition)\n</code></pre>"},{"location":"concepts/solvers/#typedlogic.solver.Solver.dump","title":"<code>dump()</code>","text":"<p>Dump the internal state of the solver as a string.</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def dump(self) -&gt; str:\n    \"\"\"\n    Dump the internal state of the solver as a string.\n\n    :return:\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"concepts/transformations/","title":"Transformations","text":"<p>Function for performing transformation and manipulation of Sentences and Theories</p>"},{"location":"concepts/transformations/#typedlogic.transformations.PrologConfig","title":"<code>PrologConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Prolog output.</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>@dataclass\nclass PrologConfig:\n    \"\"\"\n    Configuration for Prolog output.\n    \"\"\"\n    use_lowercase_vars: Optional[bool] = False\n    use_uppercase_predicates: Optional[bool]  = False\n    disjunctive_datalog: Optional[bool]  = False\n    operator_map: Optional[Mapping[str, str]] = None\n    negation_symbol : str = field(default=r'\\+')\n    negation_as_failure_symbol : str = field(default=r'\\+')\n    assume_negation_as_failure: bool = False\n    double_quote_strings: bool = False\n    include_parens_for_zero_args: bool = False\n    allow_function_terms: bool = True\n    allow_nesting: bool = True\n    null_term: str = \"null(_)\"\n    allow_skolem_terms: bool = False\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.implies_from_parents","title":"<code>implies_from_parents(theory)</code>","text":"<p>Generate implications from parent classes.</p> <p>In the data model, PredicateDefinition can be linked to any number of parent classes. This function generates implications for each.</p> <pre><code>&gt;&gt;&gt; from typedlogic import PredicateDefinition, Theory, SentenceGroup\n&gt;&gt;&gt; theory = Theory(\n...     name=\"test\",\n...     predicate_definitions=[\n...         PredicateDefinition(\n...             predicate=\"Person\",\n...             arguments={\"name\": \"str\"},\n...             parents=[\"Thing\"],\n...         ),\n...         PredicateDefinition(\n...             predicate=\"Thing\",\n...             arguments={\"name\": \"str\"},\n...             parents=[],\n...         ),\n...     ],\n...     sentence_groups=[]\n... )\n&gt;&gt;&gt; theory2 = implies_from_parents(theory)\n&gt;&gt;&gt; new_sentences = theory2.sentence_groups[0].sentences\n&gt;&gt;&gt; new_sentences\n[Forall([name: str] : Implies(Thing(?name), Person(?name)))]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> <p>The theory to generate implications for</p> required <p>Returns:</p> Type Description <code>Theory</code> <p>A new theory with implications</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def implies_from_parents(theory: Theory) -&gt; Theory:\n    \"\"\"\n    Generate implications from parent classes.\n\n    In the data model, PredicateDefinition can be linked to any number\n    of parent classes. This function generates implications for each.\n\n        &gt;&gt;&gt; from typedlogic import PredicateDefinition, Theory, SentenceGroup\n        &gt;&gt;&gt; theory = Theory(\n        ...     name=\"test\",\n        ...     predicate_definitions=[\n        ...         PredicateDefinition(\n        ...             predicate=\"Person\",\n        ...             arguments={\"name\": \"str\"},\n        ...             parents=[\"Thing\"],\n        ...         ),\n        ...         PredicateDefinition(\n        ...             predicate=\"Thing\",\n        ...             arguments={\"name\": \"str\"},\n        ...             parents=[],\n        ...         ),\n        ...     ],\n        ...     sentence_groups=[]\n        ... )\n        &gt;&gt;&gt; theory2 = implies_from_parents(theory)\n        &gt;&gt;&gt; new_sentences = theory2.sentence_groups[0].sentences\n        &gt;&gt;&gt; new_sentences\n        [Forall([name: str] : Implies(Thing(?name), Person(?name)))]\n\n    :param theory: The theory to generate implications for\n    :return: A new theory with implications\n    \"\"\"\n    new_sentences = sentences_from_predicate_hierarchy(theory)\n    new_sg = SentenceGroup(name=\"Inferred\", sentences=new_sentences)\n    sgs = (theory.sentence_groups or []) + [new_sg]\n    return Theory(\n        name=theory.name,\n        predicate_definitions=theory.predicate_definitions,\n        sentence_groups=sgs,\n    )\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.as_prolog","title":"<code>as_prolog(sentence, config=None, depth=0, translate=False, strict=True)</code>","text":"<p>Convert a sentence to Prolog syntax.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n&gt;&gt;&gt; X = Variable(\"x\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"y\", \"str\")\n&gt;&gt;&gt; A = Term(\"A\", X, Y)\n&gt;&gt;&gt; B = Term(\"B\", X, Y, \"foo\", 5)\n&gt;&gt;&gt; as_prolog(A)\n'a(X, Y)'\n\n&gt;&gt;&gt; as_prolog(Forall([X], A))\n'a(X, Y)'\n\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; E = Term(\"E\")\n&gt;&gt;&gt; print(as_prolog(Implies(C, D)))\nd :- c.\n\n&gt;&gt;&gt; print(as_prolog(Implies(C &amp; E, D)))\nd :- c, e.\n\n&gt;&gt;&gt; print(as_prolog(Implies(And(D, E), C)))\nc :- d, e.\n\n&gt;&gt;&gt; print(as_prolog(Implies(Or(D, E), C)))\nc :- (d; e).\n\n&gt;&gt;&gt; config = PrologConfig(disjunctive_datalog=True)\n&gt;&gt;&gt; print(as_prolog(Implies(And(E), C | D), config, depth=1))\nc; d :- e.\n\n&gt;&gt;&gt; config.negation_symbol = '!'\n&gt;&gt;&gt; as_prolog(~A, config, depth=1)\n'! (a(X, Y))'\n\n&gt;&gt;&gt; print(as_prolog(Term('lt', X, 5)))\nX &lt; 5\n\n&gt;&gt;&gt; print(as_prolog(Term('eq', X, 5)))\nX == 5\n\n&gt;&gt;&gt; print(as_prolog(Implies(And(C, Exists([X], Term(\"A\", X))), D)))\nd :- c, a(X).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Union[Sentence, List[Sentence]]</code> <p>the sentence to render</p> required <code>config</code> <code>Optional[PrologConfig]</code> <code>None</code> <code>depth</code> <code>0</code> <code>translate</code> <code>False</code> <code>strict</code> <code>True</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_prolog(sentence: Union[Sentence, List[Sentence]], config: Optional[PrologConfig]=None, depth=0, translate=False, strict=True) -&gt; str:\n    \"\"\"\n    Convert a sentence to Prolog syntax.\n\n        &gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n        &gt;&gt;&gt; X = Variable(\"x\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"y\", \"str\")\n        &gt;&gt;&gt; A = Term(\"A\", X, Y)\n        &gt;&gt;&gt; B = Term(\"B\", X, Y, \"foo\", 5)\n        &gt;&gt;&gt; as_prolog(A)\n        'a(X, Y)'\n\n        &gt;&gt;&gt; as_prolog(Forall([X], A))\n        'a(X, Y)'\n\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; E = Term(\"E\")\n        &gt;&gt;&gt; print(as_prolog(Implies(C, D)))\n        d :- c.\n\n        &gt;&gt;&gt; print(as_prolog(Implies(C &amp; E, D)))\n        d :- c, e.\n\n        &gt;&gt;&gt; print(as_prolog(Implies(And(D, E), C)))\n        c :- d, e.\n\n        &gt;&gt;&gt; print(as_prolog(Implies(Or(D, E), C)))\n        c :- (d; e).\n\n        &gt;&gt;&gt; config = PrologConfig(disjunctive_datalog=True)\n        &gt;&gt;&gt; print(as_prolog(Implies(And(E), C | D), config, depth=1))\n        c; d :- e.\n\n        &gt;&gt;&gt; config.negation_symbol = '!'\n        &gt;&gt;&gt; as_prolog(~A, config, depth=1)\n        '! (a(X, Y))'\n\n        &gt;&gt;&gt; print(as_prolog(Term('lt', X, 5)))\n        X &lt; 5\n\n        &gt;&gt;&gt; print(as_prolog(Term('eq', X, 5)))\n        X == 5\n\n        &gt;&gt;&gt; print(as_prolog(Implies(And(C, Exists([X], Term(\"A\", X))), D)))\n        d :- c, a(X).\n\n    :param sentence: the sentence to render\n    :param config:\n    :param depth:\n    :param translate:\n    :param strict:\n    :return:\n    \"\"\"\n    if isinstance(sentence, list):\n        return \"\\n\".join(as_prolog(s, config, depth=depth) for s in sentence)\n    if not config:\n        config = PrologConfig()\n    def _paren(s: str) -&gt; str:\n        if config.allow_nesting:\n            return f\"({s})\"\n        return s\n    if translate:\n        rules = to_horn_rules(sentence, allow_disjunctions_in_head=config.disjunctive_datalog)\n        return \"\\n\".join(as_prolog(s, config, depth=depth) for s in rules)\n    if isinstance(sentence, Forall):\n        sentence = sentence.sentence\n    if depth == 0 and not isinstance(sentence, (Implies, Term)):\n        raise NotInProfileError(f\"Top level sentence must be an implication or term {sentence}, got {type(sentence)}\")\n    if isinstance(sentence, Exists) and depth &gt; 0:\n        sentence = sentence.sentence\n    if isinstance(sentence, And):\n        if not sentence.operands:\n            return \"true\"\n        return f\"{', '.join(as_prolog(op, config, depth+1) for op in sentence.operands)}\"\n    if isinstance(sentence, Or):\n        if not sentence.operands:\n            return \"fail\"\n        return _paren(f\"{'; '.join(as_prolog(op, config, depth+1) for op in sentence.operands)}\")\n    if isinstance(sentence, (Not, NegationAsFailure)):\n        negated_clause = _paren(as_prolog(sentence.negated, config, depth+1))\n        return f\"{config.negation_symbol} {negated_clause}\"\n    if isinstance(sentence, Term):\n        if not config.allow_skolem_terms:\n            for t in sentence.values:\n                if isinstance(t, Term) and t.predicate.startswith(\"sk__\"):\n                    raise NotInProfileError(f\"Skolem term not supported: {sentence}\")\n        vals = list(sentence.bindings.values())\n        def _render_arg(v: Any) -&gt; str:\n            if v is None:\n                if depth &gt; 0:\n                    return \"_\"\n                else:\n                    return config.null_term\n            if isinstance(v, Variable):\n                if config.use_lowercase_vars:\n                    return v.name\n                return v.name.capitalize()\n            if isinstance(v, Term):\n                if not config.allow_function_terms:\n                    raise ValueError(f\"Nested term not supported: {v}\")\n                return as_prolog(v, config, depth+1)\n            if config.double_quote_strings:\n                return json.dumps(v)\n            else:\n                return repr(v)\n        p = sentence.predicate\n        operator_map = {k: v for k, v in NAME_TO_INFIX_OP.items()}\n        if config.operator_map:\n            operator_map.update(config.operator_map)\n        if p in operator_map:\n            p = operator_map[p]\n            if len(vals) == 2:\n                return f\"{_render_arg(vals[0])} {p} {_render_arg(vals[1])}\"\n            elif len(vals) == 1:\n                return f\"{p} {_render_arg(vals[0])}\"\n            else:\n                raise ValueError(f\"Operator {p} only supports 1 or 2 arguments\")\n        else:\n            if config.use_uppercase_predicates:\n                p = p.capitalize()\n            if config.use_uppercase_predicates is False:\n                p = p.lower()\n            if not vals and not config.include_parens_for_zero_args:\n                return p\n            else:\n                return f\"{p}({', '.join([_render_arg(v) for v in vals])})\"\n    if not isinstance(sentence, Implies):\n        raise NotInProfileError(f\"Unsupported sentence {sentence}\")\n    # assumption: generation a (head :- body) implication\n    if isinstance(sentence.consequent, Or) and len(sentence.consequent.operands) &gt; 1:\n        if not config.disjunctive_datalog:\n            raise NotInProfileError(f\"Disjunctions on LHS not allowed {sentence}\")\n    if isinstance(sentence.consequent, And):\n        raise NotInProfileError(f\"Conjunctions on LHS not allowed {sentence}\\n\"\n                                \"Transform using simplify_prolog_transform first\")\n    # check for unbound variables\n    body_vars = []\n    # eliminate Exists\n    antecedent_list = [t.sentence if isinstance(t, Exists) else t for t in conjunction_as_list(sentence.antecedent)]\n    for body_term in antecedent_list:\n        if not isinstance(body_term, Term):\n            # TODO: this currently assumes disjunctions are unrolled from body\n            # raise NotInProfileError(f\"Body must be a term {sentence}\")\n            continue\n        body_vars.extend(body_term.variable_names)\n    for head_term in disjunction_as_list(sentence.consequent):\n        if isinstance(head_term, Not):\n            continue\n        if not isinstance(head_term, Term):\n            raise NotInProfileError(f\"Head must be a term, got: {type(head_term)} in {sentence}\")\n        head_vars = head_term.variable_names\n        for v in head_vars:\n            if v not in body_vars:\n                raise NotInProfileError(f\"Variable {v} in head not in body {sentence}\")\n\n    head = as_prolog(sentence.consequent, config, depth+1)\n    body = as_prolog(sentence.antecedent, config, depth+1)\n    if head.startswith(\"(\") and head.endswith(\")\"):\n        head = head[1:-1]\n    if body == \"true\":\n        return f\"{head}.\"\n    if head == \"fail\":\n        return f\":- {body}.\"\n    return f\"{head} :- {body}.\"\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.simple_prolog_transform","title":"<code>simple_prolog_transform(sentence, strict=False)</code>","text":"<p>Transform a sentence to a list of sentences suitable for Prolog.</p> <p>The resulting sentences will all be quantified Body -&gt; Head implications, where Body is a conjunction</p> <pre><code>&gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; simple_prolog_transform(A &gt;&gt; B)\n[Forall([] : Implies(And(A), B))]\n\n&gt;&gt;&gt; simple_prolog_transform(Iff(A, B))\n[Forall([] : Implies(And(B), A)), Forall([] : Implies(And(A), B))]\n\n&gt;&gt;&gt; for s in simple_prolog_transform(Iff(A, B)):\n...     print(as_prolog(s))\na :- b.\nb :- a.\n\n&gt;&gt;&gt; for s in simple_prolog_transform((And(A) &amp; And(B)) &gt;&gt; C):\n...     print(as_prolog(s))\nc :- a, b.\n\n&gt;&gt;&gt; for s in simple_prolog_transform((Or(A,B)) &gt;&gt; C):\n...     print(as_prolog(s))\nc :- b.\nc :- a.\n\n&gt;&gt;&gt; for s in simple_prolog_transform(C &gt;&gt; (A &amp; B)):\n...     print(as_prolog(s))\nb :- c.\na :- c.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>strict</code> <code>False</code> <p>Returns:</p> Type Description <code>List[Sentence]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def simple_prolog_transform(sentence: Sentence, strict=False) -&gt; List[Sentence]:\n    \"\"\"\n    Transform a sentence to a list of sentences suitable for Prolog.\n\n    The resulting sentences will all be quantified Body -&gt; Head implications,\n    where Body is a conjunction\n\n        &gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; simple_prolog_transform(A &gt;&gt; B)\n        [Forall([] : Implies(And(A), B))]\n\n        &gt;&gt;&gt; simple_prolog_transform(Iff(A, B))\n        [Forall([] : Implies(And(B), A)), Forall([] : Implies(And(A), B))]\n\n        &gt;&gt;&gt; for s in simple_prolog_transform(Iff(A, B)):\n        ...     print(as_prolog(s))\n        a :- b.\n        b :- a.\n\n        &gt;&gt;&gt; for s in simple_prolog_transform((And(A) &amp; And(B)) &gt;&gt; C):\n        ...     print(as_prolog(s))\n        c :- a, b.\n\n        &gt;&gt;&gt; for s in simple_prolog_transform((Or(A,B)) &gt;&gt; C):\n        ...     print(as_prolog(s))\n        c :- b.\n        c :- a.\n\n        &gt;&gt;&gt; for s in simple_prolog_transform(C &gt;&gt; (A &amp; B)):\n        ...     print(as_prolog(s))\n        b :- c.\n        a :- c.\n\n\n\n\n    :param sentence:\n    :param strict:\n    :return:\n    \"\"\"\n    def not_in_profile(s: Sentence) -&gt; None:\n        if strict:\n            raise NotInProfileError(f\"Unsupported sentence {s}\")\n    sentence = transform_sentence(sentence, reduce_singleton)\n    sentence = transform_sentence(sentence, eliminate_iff)\n    if not isinstance(sentence, Forall):\n        sentence = Forall([], sentence)\n    # sentence = transform_sentence(sentence, eliminate_implies)\n    outer = sentence\n    sentence = sentence.sentence\n    if isinstance(sentence, And):\n        # expand And to multiple sentences\n        sentences = [op for op in sentence.operands]\n    else:\n        sentences = [sentence]\n    new_sentences: List[Sentence] = []\n    while sentences:\n        sentence = sentences.pop()\n        if isinstance(sentence, Term):\n            new_sentences.append(sentence)\n            continue\n        if isinstance(sentence, Implied):\n            sentences.append(Implies(sentence.operands[1], sentence.operands[0]))\n        if isinstance(sentence, Iff):\n            sentences.append(Implies(sentence.left, sentence.right))\n            sentences.append(Implies(sentence.right, sentence.left))\n        if not isinstance(sentence, Implies):\n            not_in_profile(sentence)\n            continue\n        body = sentence.antecedent\n        head = sentence.consequent\n        if isinstance(head, And):\n            sentences.extend([Implies(body, op) for op in head.operands])\n            continue\n        if not isinstance(head, Term):\n            not_in_profile(sentence)\n            continue\n        if isinstance(body, Or):\n            sentences.extend([Implies(op, head) for op in body.operands])\n            continue\n        if isinstance(body, Term):\n            body = And(body)\n        if not isinstance(body, And):\n            # note: does not check members of And\n            not_in_profile(sentence)\n            continue\n        new_sentences.append(Implies(body, head))\n    return [Forall(outer.variables, s) for s in new_sentences]\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.as_fol","title":"<code>as_fol(sentence, config=None)</code>","text":"<p>Convert a sentence to first order logic syntax.</p> <p>from typedlogic import Term, Variable, Forall X = Variable(\"x\", \"str\") Y = Variable(\"y\", \"str\") A = Term(\"A\", X) B = Term(\"B\", X) print(as_fol(Forall([X], A &gt;&gt; B))) \u2200[x:str]. A(x) \u2192 B(x) print(as_fol(Forall([X], Iff(A, B)))) \u2200[x:str]. A(x) \u2194 B(x) print(as_fol(Exists([X], A &amp; B))) \u2203[x:str]. A(x) \u2227 B(x) print(as_fol(A|B)) (A(x) \u2228 B(x))</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> required <code>config</code> <code>Optional[PrologConfig]</code> <code>None</code> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_fol(sentence, config: Optional[PrologConfig]=None) -&gt; str:\n    \"\"\"\n    Convert a sentence to first order logic syntax.\n\n    &gt;&gt;&gt; from typedlogic import Term, Variable, Forall\n    &gt;&gt;&gt; X = Variable(\"x\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"y\", \"str\")\n    &gt;&gt;&gt; A = Term(\"A\", X)\n    &gt;&gt;&gt; B = Term(\"B\", X)\n    &gt;&gt;&gt; print(as_fol(Forall([X], A &gt;&gt; B)))\n    \u2200[x:str]. A(x) \u2192 B(x)\n    &gt;&gt;&gt; print(as_fol(Forall([X], Iff(A, B))))\n    \u2200[x:str]. A(x) \u2194 B(x)\n    &gt;&gt;&gt; print(as_fol(Exists([X], A &amp; B)))\n    \u2203[x:str]. A(x) \u2227 B(x)\n    &gt;&gt;&gt; print(as_fol(A|B))\n    (A(x) \u2228 B(x))\n\n    :param sentence:\n    :param config:\n    :return:\n    \"\"\"\n    if not config:\n        config = PrologConfig(use_lowercase_vars=True, use_uppercase_predicates=None)\n    if isinstance(sentence, (Exists, Forall)):\n        qsym = \"\u2200\" if isinstance(sentence, Forall) else \"\u2203\"\n        arg_exprs = [f\"{v.name}:{v.domain}\" if v.domain else v.name for v in sentence.variables]\n        args = \" \".join(arg_exprs)\n        return f\"{qsym}[{args}]. {as_fol(sentence.sentence, config)}\"\n    if isinstance(sentence, And):\n        return f\"{' \u2227 '.join(as_fol(op, config) for op in sentence.operands)}\"\n    if isinstance(sentence, Or):\n        return f\"({' \u2228 '.join(as_fol(op, config) for op in sentence.operands)})\"\n    if isinstance(sentence, Not):\n        return f\"\u00ac{as_fol(sentence.negated, config)}\"\n    if isinstance(sentence, Implies):\n        return f\"{as_fol(sentence.antecedent, config)} \u2192 {as_fol(sentence.consequent, config)}\"\n    if isinstance(sentence, Implied):\n        return f\"{as_fol(sentence.operands[1], config)} \u2190 {as_fol(sentence.operands[0], config)}\"\n    if isinstance(sentence, Iff):\n        return f\"{as_fol(sentence.left, config)} \u2194 {as_fol(sentence.right, config)}\"\n    if isinstance(sentence, Term):\n        vals = list(sentence.bindings.values())\n        def _render_arg(v: Any) -&gt; str:\n            if isinstance(v, Variable):\n                if config.use_lowercase_vars:\n                    return v.name\n                return v.name.capitalize()\n            if config.double_quote_strings:\n                return json.dumps(v)\n            else:\n                return repr(v)\n        p = sentence.predicate\n        operator_map = {k: v for k, v in NAME_TO_INFIX_OP.items()}\n        if config.operator_map:\n            operator_map.update(config.operator_map)\n        if p in operator_map:\n            p = operator_map[p]\n            if len(vals) == 2:\n                return f\"{_render_arg(vals[0])} {p} {_render_arg(vals[1])}\"\n            elif len(vals) == 1:\n                return f\"{p} {_render_arg(vals[0])}\"\n            else:\n                raise ValueError(f\"Operator {p} only supports 1 or 2 arguments\")\n        else:\n            if config.use_uppercase_predicates:\n                p = p.capitalize()\n            if config.use_uppercase_predicates is False:\n                p = p.lower()\n            if not vals and not config.include_parens_for_zero_args:\n                return p\n            else:\n                return f\"{p}({', '.join([_render_arg(v) for v in vals])})\"\n    return \"\"\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.as_tptp","title":"<code>as_tptp(sentence, config=None, depth=0)</code>","text":"<p>Convert a sentence to TPTP syntax.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> <p>The sentence to convert</p> required <code>config</code> <code>Optional[PrologConfig]</code> <p>Configuration options (optional)</p> <code>None</code> <code>depth</code> <p>Current depth in the sentence structure (used for indentation)</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>TPTP representation of the sentence  Examples: &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; P = Term(\"P\", X) &gt;&gt;&gt; Q = Term(\"Q\", X, Y) &gt;&gt;&gt; R = Term(\"R\", Y) &gt;&gt;&gt; print(as_tptp(Forall([X], Implies(P, Q)))) ! [X] : (p(X) =&gt; q(X, Y)) &gt;&gt;&gt; print(as_tptp(Exists([X, Y], And(P, Q)))) ? [X, Y] : (p(X) &amp; q(X, Y)) &gt;&gt;&gt; print(as_tptp(Or(P, Not(R)))) (p(X) | ~r(Y))</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_tptp(sentence: Sentence, config: Optional[PrologConfig] = None, depth=0) -&gt; str:\n    \"\"\"\n    Convert a sentence to TPTP syntax.\n\n    :param sentence: The sentence to convert\n    :param config: Configuration options (optional)\n    :param depth: Current depth in the sentence structure (used for indentation)\n    :return: TPTP representation of the sentence\n\n    Examples:\n    &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; P = Term(\"P\", X)\n    &gt;&gt;&gt; Q = Term(\"Q\", X, Y)\n    &gt;&gt;&gt; R = Term(\"R\", Y)\n    &gt;&gt;&gt; print(as_tptp(Forall([X], Implies(P, Q))))\n    ! [X] : (p(X) =&gt; q(X, Y))\n    &gt;&gt;&gt; print(as_tptp(Exists([X, Y], And(P, Q))))\n    ? [X, Y] : (p(X) &amp; q(X, Y))\n    &gt;&gt;&gt; print(as_tptp(Or(P, Not(R))))\n    (p(X) | ~r(Y))\n    \"\"\"\n    if not config:\n        config = PrologConfig(use_lowercase_vars=False, use_uppercase_predicates=False)\n\n    def format_var(v: Variable) -&gt; str:\n        return v.name if config.use_lowercase_vars else v.name.capitalize()\n\n    def format_predicate(p: str) -&gt; str:\n        return p.lower() if config.use_uppercase_predicates is False else p\n\n    if isinstance(sentence, (Forall, Exists)):\n        quantifier = \"!\" if isinstance(sentence, Forall) else \"?\"\n        vars = \", \".join(format_var(v) for v in sentence.variables)\n        return f\"{quantifier} [{vars}] : {as_tptp(sentence.sentence, config, depth)}\"\n\n    elif isinstance(sentence, And):\n        return f\"({' &amp; '.join(as_tptp(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Or):\n        return f\"({' | '.join(as_tptp(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Not):\n        return f\"~{as_tptp(sentence.negated, config, depth + 1)}\"\n\n    elif isinstance(sentence, Implies):\n        return f\"({as_tptp(sentence.antecedent, config, depth + 1)} =&gt; {as_tptp(sentence.consequent, config, depth + 1)})\"\n\n    elif isinstance(sentence, Iff):\n        return f\"({as_tptp(sentence.left, config, depth + 1)} &lt;=&gt; {as_tptp(sentence.right, config, depth + 1)})\"\n\n    elif isinstance(sentence, Term):\n        predicate = format_predicate(sentence.predicate)\n        args = \", \".join(format_var(v) if isinstance(v, Variable) else repr(v) for v in sentence.bindings.values())\n        return f\"{predicate}({args})\"\n\n    else:\n        raise ValueError(f\"Unsupported sentence type: {type(sentence)}\")\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.tptp_problem","title":"<code>tptp_problem(theory, conjecture=None)</code>","text":"<p>Generate a complete TPTP problem from a theory and an optional conjecture.</p> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> <p>The theory containing axioms</p> required <code>conjecture</code> <code>Optional[Sentence]</code> <p>An optional conjecture to prove</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>TPTP representation of the problem  Example: &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; theory = Theory( ...     name=\"example\", ...     predicate_definitions=[ ...         PredicateDefinition(\"P\", {\"x\": \"str\"}), ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}), ...     ], ...     sentence_groups=[ ...         SentenceGroup(\"axioms\", sentences=[ ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) ...         ]) ...     ] ... ) &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) &gt;&gt;&gt; print(tptp_problem(theory, conjecture)) % Problem: example fof(axiom1, axiom, ! [X] : (p(X) =&gt; q(X, Y))). fof(conjecture, conjecture, ! [X, Y] : (p(X) =&gt; q(X, Y))).</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def tptp_problem(theory: Theory, conjecture: Optional[Sentence] = None) -&gt; str:\n    \"\"\"\n    Generate a complete TPTP problem from a theory and an optional conjecture.\n\n    :param theory: The theory containing axioms\n    :param conjecture: An optional conjecture to prove\n    :return: TPTP representation of the problem\n\n    Example:\n    &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; theory = Theory(\n    ...     name=\"example\",\n    ...     predicate_definitions=[\n    ...         PredicateDefinition(\"P\", {\"x\": \"str\"}),\n    ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}),\n    ...     ],\n    ...     sentence_groups=[\n    ...         SentenceGroup(\"axioms\", sentences=[\n    ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    ...         ])\n    ...     ]\n    ... )\n    &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    &gt;&gt;&gt; print(tptp_problem(theory, conjecture))\n    % Problem: example\n    fof(axiom1, axiom, ! [X] : (p(X) =&gt; q(X, Y))).\n    fof(conjecture, conjecture, ! [X, Y] : (p(X) =&gt; q(X, Y))).\n    \"\"\"\n    lines = [f\"% Problem: {theory.name}\"]\n\n    for i, sentence in enumerate(theory.sentences, 1):\n        lines.append(f\"fof(axiom{i}, axiom, {as_tptp(sentence)}).\")\n\n    if conjecture:\n        lines.append(f\"fof(conjecture, conjecture, {as_tptp(conjecture)}).\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.as_prover9","title":"<code>as_prover9(sentence, config=None, depth=0)</code>","text":"<p>Convert a sentence to Prover9 syntax.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> <p>The sentence to convert</p> required <code>config</code> <code>Optional[PrologConfig]</code> <p>Configuration options (optional)</p> <code>None</code> <code>depth</code> <p>Current depth in the sentence structure (used for indentation)</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>Prover9 representation of the sentence  Examples: &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; P = Term(\"P\", X) &gt;&gt;&gt; Q = Term(\"Q\", X, Y) &gt;&gt;&gt; R = Term(\"R\", Y) &gt;&gt;&gt; print(as_prover9(Forall([X], Implies(P, Q)))) all x ((P(x) -&gt; Q(x, y))) &gt;&gt;&gt; print(as_prover9(Exists([X, Y], And(P, Q)))) exists x y ((P(x) &amp; Q(x, y))) &gt;&gt;&gt; print(as_prover9(Or(P, Not(R)))) (P(x) | - ( R(y) )) &gt;&gt;&gt; print(as_prover9(Term(\"S\", \"hello\"))) S(s_hello)</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def as_prover9(sentence: Sentence, config: Optional[PrologConfig] = None, depth=0) -&gt; str:\n    \"\"\"\n    Convert a sentence to Prover9 syntax.\n\n    :param sentence: The sentence to convert\n    :param config: Configuration options (optional)\n    :param depth: Current depth in the sentence structure (used for indentation)\n    :return: Prover9 representation of the sentence\n\n    Examples:\n    &gt;&gt;&gt; from typedlogic import Term, Variable, Forall, Exists, And, Or, Not, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; P = Term(\"P\", X)\n    &gt;&gt;&gt; Q = Term(\"Q\", X, Y)\n    &gt;&gt;&gt; R = Term(\"R\", Y)\n    &gt;&gt;&gt; print(as_prover9(Forall([X], Implies(P, Q))))\n    all x ((P(x) -&gt; Q(x, y)))\n    &gt;&gt;&gt; print(as_prover9(Exists([X, Y], And(P, Q))))\n    exists x y ((P(x) &amp; Q(x, y)))\n    &gt;&gt;&gt; print(as_prover9(Or(P, Not(R))))\n    (P(x) | - ( R(y) ))\n    &gt;&gt;&gt; print(as_prover9(Term(\"S\", \"hello\")))\n    S(s_hello)\n    \"\"\"\n    if not config:\n        config = PrologConfig(use_lowercase_vars=True, use_uppercase_predicates=False)\n\n    def format_var(v: Variable) -&gt; str:\n        return v.name.lower()\n\n    def format_predicate(p: str) -&gt; str:\n        return p.upper() if config.use_uppercase_predicates else p\n\n    def format_value(v: Any) -&gt; str:\n        if isinstance(v, str):\n            # Convert string to a valid Prover9 constant\n            return f\"s_{v.replace(' ', '_')}\"\n        elif isinstance(v, int):\n            return str(v)\n        elif isinstance(v, float):\n            # Prover9 doesn't support floats directly, so we convert to a fraction\n            from fractions import Fraction\n            frac = Fraction(v).limit_denominator()\n            return f\"rational({frac.numerator},{frac.denominator})\"\n        elif v is None:\n            return \"null\"\n        else:\n            return str(v)\n\n    if isinstance(sentence, (Forall, Exists)):\n        quantifier = \"all\" if isinstance(sentence, Forall) else \"exists\"\n        vars = \" \".join(format_var(v) for v in sentence.variables)\n        return f\"{quantifier} {vars} ({as_prover9(sentence.sentence, config, depth)})\"\n\n    elif isinstance(sentence, And):\n        return f\"({' &amp; '.join(as_prover9(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Xor):\n        return as_prover9(expand_xor(sentence), config, depth)\n\n    elif isinstance(sentence, ExactlyOne):\n        return as_prover9(expand_exactly_one(sentence), config, depth)\n\n    elif isinstance(sentence, Or):\n        return f\"({' | '.join(as_prover9(op, config, depth + 1) for op in sentence.operands)})\"\n\n    elif isinstance(sentence, Not):\n        return f\"- ( {as_prover9(sentence.negated, config, depth + 1)} )\"\n\n    elif isinstance(sentence, Implies):\n        return f\"({as_prover9(sentence.antecedent, config, depth + 1)} -&gt; {as_prover9(sentence.consequent, config, depth + 1)})\"\n\n    elif isinstance(sentence, Implied):\n        return f\"({as_prover9(sentence.consequent, config, depth + 1)} &lt;- {as_prover9(sentence.antecedent, config, depth + 1)})\"\n\n    elif isinstance(sentence, Iff):\n        return f\"({as_prover9(sentence.left, config, depth + 1)} &lt;-&gt; {as_prover9(sentence.right, config, depth + 1)})\"\n\n\n    elif isinstance(sentence, Term):\n        predicate = format_predicate(sentence.predicate)\n        if not sentence.bindings:\n            return predicate\n        args = \", \".join(\n            format_var(v) if isinstance(v, Variable) else format_value(v) for v in sentence.bindings.values())\n        return f\"{predicate}({args})\"\n\n    else:\n        raise ValueError(f\"Unsupported sentence type: {type(sentence)}\")\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.prover9_problem","title":"<code>prover9_problem(theory, conjecture=None)</code>","text":"<p>Generate a complete Prover9 problem from a theory and an optional conjecture.</p> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> <p>The theory containing axioms</p> required <code>conjecture</code> <code>Optional[Sentence]</code> <p>An optional conjecture to prove</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Prover9 representation of the problem  Example: &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies &gt;&gt;&gt; X = Variable(\"X\", \"str\") &gt;&gt;&gt; Y = Variable(\"Y\", \"str\") &gt;&gt;&gt; theory = Theory( ...     name=\"example\", ...     predicate_definitions=[ ...         PredicateDefinition(\"P\", {\"x\": \"str\"}), ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}), ...     ], ...     sentence_groups=[ ...         SentenceGroup(\"axioms\", sentences=[ ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) ...         ]) ...     ] ... ) &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y))) &gt;&gt;&gt; print(prover9_problem(theory, conjecture)) formulas(assumptions). all x ((P(x) -&gt; Q(x, y))). end_of_list.  formulas(goals). all x y ((P(x) -&gt; Q(x, y))). end_of_list. Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def prover9_problem(theory: Theory, conjecture: Optional[Sentence] = None) -&gt; str:\n    \"\"\"\n    Generate a complete Prover9 problem from a theory and an optional conjecture.\n\n    :param theory: The theory containing axioms\n    :param conjecture: An optional conjecture to prove\n    :return: Prover9 representation of the problem\n\n    Example:\n    &gt;&gt;&gt; from typedlogic import Theory, PredicateDefinition, Term, Variable, Forall, Implies\n    &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n    &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n    &gt;&gt;&gt; theory = Theory(\n    ...     name=\"example\",\n    ...     predicate_definitions=[\n    ...         PredicateDefinition(\"P\", {\"x\": \"str\"}),\n    ...         PredicateDefinition(\"Q\", {\"x\": \"str\", \"y\": \"str\"}),\n    ...     ],\n    ...     sentence_groups=[\n    ...         SentenceGroup(\"axioms\", sentences=[\n    ...             Forall([X], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    ...         ])\n    ...     ]\n    ... )\n    &gt;&gt;&gt; conjecture = Forall([X, Y], Implies(Term(\"P\", X), Term(\"Q\", X, Y)))\n    &gt;&gt;&gt; print(prover9_problem(theory, conjecture))\n    formulas(assumptions).\n        all x ((P(x) -&gt; Q(x, y))).\n    end_of_list.\n    &lt;BLANKLINE&gt;\n    formulas(goals).\n        all x y ((P(x) -&gt; Q(x, y))).\n    end_of_list.\n    \"\"\"\n    lines = []\n\n    # Assumptions (axioms)\n    lines.append(\"formulas(assumptions).\")\n    for sentence in theory.sentences:\n        lines.append(f\"    {as_prover9(sentence)}.\")\n    lines.append(\"end_of_list.\")\n    lines.append(\"\")\n\n    # Goals (conjecture)\n    if conjecture:\n        lines.append(\"formulas(goals).\")\n        lines.append(f\"    {as_prover9(conjecture)}.\")\n        lines.append(\"end_of_list.\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.transform_sentence_chained","title":"<code>transform_sentence_chained(sentence, rules)</code>","text":"<p>Transform a sentence using a chain of rules.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; sentence = A | (B &amp; C)\n&gt;&gt;&gt; negate_conjunctions = lambda s: Or(*[~op for op in s.operands]) if isinstance(s, And) else s\n&gt;&gt;&gt; reduce_singletons = lambda s: s.operands[0] if isinstance(s, And) and len(s.operands) == 1 else s\n&gt;&gt;&gt; transform_sentence_chained(sentence, [negate_conjunctions, reduce_singletons])\nOr(A, Or(Not(B), Not(C)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>rules</code> <code>Iterable[Callable[[Sentence], Sentence]]</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def transform_sentence_chained(sentence: Sentence, rules: Iterable[Callable[[Sentence], Sentence]]) -&gt; Sentence:\n    \"\"\"\n    Transform a sentence using a chain of rules.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; sentence = A | (B &amp; C)\n        &gt;&gt;&gt; negate_conjunctions = lambda s: Or(*[~op for op in s.operands]) if isinstance(s, And) else s\n        &gt;&gt;&gt; reduce_singletons = lambda s: s.operands[0] if isinstance(s, And) and len(s.operands) == 1 else s\n        &gt;&gt;&gt; transform_sentence_chained(sentence, [negate_conjunctions, reduce_singletons])\n        Or(A, Or(Not(B), Not(C)))\n\n    :param sentence:\n    :param rules:\n    :return:\n    \"\"\"\n    for rule in rules:\n        sentence = transform_sentence(sentence, rule)\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.transform_sentence","title":"<code>transform_sentence(sentence, rule, varmap=None)</code>","text":"<p>Transform a sentence recursively using a rule.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; sentence = A | (B &amp; (C | ~D))\n&gt;&gt;&gt; assert transform_sentence(sentence, lambda s: s) == sentence\n\n&gt;&gt;&gt; def negate_conjunctions(sentence: Sentence) -&gt; Optional[Sentence]:\n...     if isinstance(sentence, And):\n...         return Or(*[~op for op in sentence.operands])\n...     return None\n&gt;&gt;&gt; transform_sentence(B &amp; C, negate_conjunctions)\nOr(Not(B), Not(C))\n&gt;&gt;&gt; transform_sentence(A | (B &amp; C), negate_conjunctions)\nOr(A, Or(Not(B), Not(C)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>rule</code> <code>Callable[[Sentence], Sentence]</code> required <code>varmap</code> <code>Optional[Dict[str, Variable]]</code> <code>None</code> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def transform_sentence(sentence: Sentence, rule: Callable[[Sentence], Sentence], varmap: Optional[Dict[str, Variable]] = None) -&gt; Sentence:\n    \"\"\"\n    Transform a sentence recursively using a rule.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; sentence = A | (B &amp; (C | ~D))\n        &gt;&gt;&gt; assert transform_sentence(sentence, lambda s: s) == sentence\n\n        &gt;&gt;&gt; def negate_conjunctions(sentence: Sentence) -&gt; Optional[Sentence]:\n        ...     if isinstance(sentence, And):\n        ...         return Or(*[~op for op in sentence.operands])\n        ...     return None\n        &gt;&gt;&gt; transform_sentence(B &amp; C, negate_conjunctions)\n        Or(Not(B), Not(C))\n        &gt;&gt;&gt; transform_sentence(A | (B &amp; C), negate_conjunctions)\n        Or(A, Or(Not(B), Not(C)))\n\n    :param sentence:\n    :param rule:\n    :param varmap:\n    :return:\n    \"\"\"\n    varmap = varmap or {}\n    new_sentence = rule(sentence)\n    if new_sentence:\n        if sentence != new_sentence:\n            sentence = transform_sentence(new_sentence, rule, varmap)\n        else:\n            sentence = new_sentence\n    if isinstance(sentence, QuantifiedSentence):\n        return type(sentence)(sentence.variables, transform_sentence(sentence.sentence, rule, varmap))\n    elif isinstance(sentence, BooleanSentence):\n        return type(sentence)(*[transform_sentence(op, rule, varmap) for op in sentence.operands])\n    elif isinstance(sentence, Term):\n        return sentence\n    elif isinstance(sentence, Extension):\n        return sentence.to_model_object()\n    else:\n        raise ValueError(f\"Unknown sentence type {type(sentence)} // {sentence}\")\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.replace_constants","title":"<code>replace_constants(sentence, constant_map)</code>","text":"<p>Replace constants in a sentence with new values.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; A = Term(\"A\", X)\n&gt;&gt;&gt; B = Term(\"B\", Y)\n&gt;&gt;&gt; C = Term(\"C\", Z)\n&gt;&gt;&gt; constant_map = {\"X\": \"foo\", \"Y\": \"bar\", \"Z\": \"baz\"}\n&gt;&gt;&gt; replace_constants(A &amp; B, constant_map)\nAnd(A(foo), B(bar))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>constant_map</code> <code>Dict[str, Any]</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def replace_constants(sentence: Sentence, constant_map: Dict[str, Any] ) -&gt; Sentence:\n    \"\"\"\n    Replace constants in a sentence with new values.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; A = Term(\"A\", X)\n        &gt;&gt;&gt; B = Term(\"B\", Y)\n        &gt;&gt;&gt; C = Term(\"C\", Z)\n        &gt;&gt;&gt; constant_map = {\"X\": \"foo\", \"Y\": \"bar\", \"Z\": \"baz\"}\n        &gt;&gt;&gt; replace_constants(A &amp; B, constant_map)\n        And(A(foo), B(bar))\n\n\n    :param sentence:\n    :param constant_map:\n    :return:\n    \"\"\"\n    if isinstance(sentence, QuantifiedSentence):\n        return type(sentence)(sentence.variables, replace_constants(sentence.sentence, constant_map))\n    elif isinstance(sentence, BooleanSentence):\n        return type(sentence)(*[replace_constants(op, constant_map) for op in sentence.operands])\n    elif isinstance(sentence, Term):\n        def _repl(v: Any) -&gt; Any:\n            if isinstance(v, Variable):\n                if v.name in constant_map:\n                    return constant_map[v.name]\n            return v\n        return Term(sentence.predicate, {k: _repl(v) for k, v in sentence.bindings.items()})\n    else:\n        raise ValueError(f\"Unknown sentence type {sentence}\")\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.reduce_singleton","title":"<code>reduce_singleton(sentence)</code>","text":"<p>Reduce singleton conjunctions and disjunctions in a sentence.</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; sentence = And(A, B)\n&gt;&gt;&gt; reduce_singleton(sentence)\nAnd(A, B)\n&gt;&gt;&gt; reduce_singleton(And(A))\nA\n&gt;&gt;&gt; reduce_singleton(Or(A))\nA\n&gt;&gt;&gt; transform_sentence(And(A, Or(B), C), reduce_singleton)\nAnd(A, B, C)\n&gt;&gt;&gt; transform_sentence(And(And(A)), reduce_singleton)\nA\n&gt;&gt;&gt; transform_sentence(And(A, Or(Or(B)), And(Or(And(C)))), reduce_singleton)\nAnd(A, B, C)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def reduce_singleton(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Reduce singleton conjunctions and disjunctions in a sentence.\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; sentence = And(A, B)\n        &gt;&gt;&gt; reduce_singleton(sentence)\n        And(A, B)\n        &gt;&gt;&gt; reduce_singleton(And(A))\n        A\n        &gt;&gt;&gt; reduce_singleton(Or(A))\n        A\n        &gt;&gt;&gt; transform_sentence(And(A, Or(B), C), reduce_singleton)\n        And(A, B, C)\n        &gt;&gt;&gt; transform_sentence(And(And(A)), reduce_singleton)\n        A\n        &gt;&gt;&gt; transform_sentence(And(A, Or(Or(B)), And(Or(And(C)))), reduce_singleton)\n        And(A, B, C)\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, And) and len(sentence.operands) == 1:\n        return sentence.operands[0]\n    if isinstance(sentence, Or) and len(sentence.operands) == 1:\n        return sentence.operands[0]\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.simplify","title":"<code>simplify(sentence)</code>","text":"<p>Simplify a sentence by reducing nested conjunctions and disjunctions.</p> <p>from typedlogic import And, Or, Variable, Term, Forall A = Term(\"A\") B = Term(\"B\") C = Term(\"C\") D = Term(\"D\") simplify(And(A, And(B, And(C, D)))) And(A, B, C, D) simplify(And(And(A))) A</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def simplify(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Simplify a sentence by reducing nested conjunctions and disjunctions.\n\n    &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n    &gt;&gt;&gt; A = Term(\"A\")\n    &gt;&gt;&gt; B = Term(\"B\")\n    &gt;&gt;&gt; C = Term(\"C\")\n    &gt;&gt;&gt; D = Term(\"D\")\n    &gt;&gt;&gt; simplify(And(A, And(B, And(C, D))))\n    And(A, B, C, D)\n    &gt;&gt;&gt; simplify(And(And(A)))\n    A\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, (And, Or)):\n        operands = [simplify(op) for op in sentence.operands]\n        if len(operands) == 1:\n            return simplify(operands[0])\n        op_type = type(sentence)\n        new_operands: List[Sentence] = []\n        for op in operands:\n            if isinstance(op, op_type):\n                if not isinstance(op, (And, Or)):\n                    raise AssertionError\n                new_operands.extend(op.operands)\n            else:\n                new_operands.append(op)\n        sentence = op_type(*new_operands)\n    if isinstance(sentence, (Exists, Forall)):\n        typ = type(sentence)\n        qs = sentence.sentence\n        if typ == type(qs):\n            if not isinstance(qs, (Exists, Forall)):\n                raise AssertionError\n            return typ(sentence.variables + qs.variables, simplify(qs.sentence))\n    if isinstance(sentence, Not):\n        negated = simplify(sentence.negated)\n        if isinstance(negated, Not):\n            return negated.negated\n        return Not(negated)\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.distribute_and_over_or","title":"<code>distribute_and_over_or(sentence)</code>","text":"<p>Distribute AND over OR in a sentence.</p> <p>A \u2228 (B1 \u2227 B2 \u2227 ... \u2227 Bn) \u2261 (A \u2228 B1) \u2227 (A \u2228 B2) \u2227 ... \u2227 (A \u2228 Bn)</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; A = Term(\"A\")\n&gt;&gt;&gt; B = Term(\"B\")\n&gt;&gt;&gt; C = Term(\"C\")\n&gt;&gt;&gt; D = Term(\"D\")\n&gt;&gt;&gt; distribute_and_over_or(A | (B &amp; C))\nAnd(Or(B, A), Or(C, A))\n&gt;&gt;&gt; distribute_and_over_or((A &amp; B) | (C &amp; D))\nAnd(Or(C, A), Or(D, A), Or(C, B), Or(D, B))\n\n&gt;&gt;&gt; distribute_and_over_or(A | And(B, C, D))\nAnd(Or(B, A), Or(C, A), Or(D, A))\n\n&gt;&gt;&gt; distribute_and_over_or(A | B)\nOr(A, B)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def distribute_and_over_or(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Distribute AND over OR in a sentence.\n\n    A \u2228 (B1 \u2227 B2 \u2227 ... \u2227 Bn) \u2261 (A \u2228 B1) \u2227 (A \u2228 B2) \u2227 ... \u2227 (A \u2228 Bn)\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; A = Term(\"A\")\n        &gt;&gt;&gt; B = Term(\"B\")\n        &gt;&gt;&gt; C = Term(\"C\")\n        &gt;&gt;&gt; D = Term(\"D\")\n        &gt;&gt;&gt; distribute_and_over_or(A | (B &amp; C))\n        And(Or(B, A), Or(C, A))\n        &gt;&gt;&gt; distribute_and_over_or((A &amp; B) | (C &amp; D))\n        And(Or(C, A), Or(D, A), Or(C, B), Or(D, B))\n\n        &gt;&gt;&gt; distribute_and_over_or(A | And(B, C, D))\n        And(Or(B, A), Or(C, A), Or(D, A))\n\n        &gt;&gt;&gt; distribute_and_over_or(A | B)\n        Or(A, B)\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Or):\n        return sentence\n    sentence = _distribute_sentence(sentence, And, Or)\n    # sentence = transform_sentence(sentence, reduce_singleton)\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.flatten_nested_conjunctions_and_disjunctions","title":"<code>flatten_nested_conjunctions_and_disjunctions(sentence)</code>","text":"<p>Flatten nested conjunctions and disjunctions in a sentence.</p> <p>Replace (A \u2227 B) \u2227 C with A \u2227 B \u2227 C Replace (A \u2228 B) \u2228 C with A \u2228 B \u2228 C</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; sentence = And(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n&gt;&gt;&gt; flatten_nested_conjunctions_and_disjunctions(sentence)\nAnd(Q(?X), R(?Y), S(?Z))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def flatten_nested_conjunctions_and_disjunctions(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Flatten nested conjunctions and disjunctions in a sentence.\n\n    Replace (A \u2227 B) \u2227 C with A \u2227 B \u2227 C\n    Replace (A \u2228 B) \u2228 C with A \u2228 B \u2228 C\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; sentence = And(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n        &gt;&gt;&gt; flatten_nested_conjunctions_and_disjunctions(sentence)\n        And(Q(?X), R(?Y), S(?Z))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, (And, Or)):\n        new_ops = []\n        for op in sentence.operands:\n            if isinstance(op, type(sentence)):\n                new_ops.extend(op.operands)\n            else:\n                new_ops.append(op)\n        return type(sentence)(*new_ops)\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.skolemize","title":"<code>skolemize(sentence, universal_vars=None, substitution_map=None)</code>","text":"<p>Skolemize a sentence.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall, Exists\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; # no universal quantifiers\n&gt;&gt;&gt; skolemize(Exists([X], Term(\"P\", X)))\nP(sk__1)\n&gt;&gt;&gt; skolemize(Forall([X], Exists([Y], Term(\"P\", X, Y))))\nForall([X: str] : P(?X, sk__1(?X)))\n&gt;&gt;&gt; skolemize(Forall([X], Exists([Y, Z], Term(\"P\", X, Y, Z))))\nForall([X: str] : P(?X, sk__1(?X), sk__2(?X)))\n&gt;&gt;&gt; skolemize(Forall([X], And(Exists([Y, Z], Term(\"P\", X, Y, Z)), Exists([Y], Term(\"Q\", X, Y)))))\nForall([X: str] : And(P(?X, sk__1(?X), sk__2(?X)), Q(?X, sk__3(?X))))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>universal_vars</code> <code>Optional[List[Variable]]</code> <code>None</code> <code>substitution_map</code> <code>Optional[Dict[str, Term]]</code> <code>None</code> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def skolemize(sentence: Sentence, universal_vars: Optional[List[Variable]] = None, substitution_map: Optional[Dict[str, Term]] = None) -&gt; Sentence:\n    \"\"\"\n    Skolemize a sentence.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall, Exists\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; # no universal quantifiers\n        &gt;&gt;&gt; skolemize(Exists([X], Term(\"P\", X)))\n        P(sk__1)\n        &gt;&gt;&gt; skolemize(Forall([X], Exists([Y], Term(\"P\", X, Y))))\n        Forall([X: str] : P(?X, sk__1(?X)))\n        &gt;&gt;&gt; skolemize(Forall([X], Exists([Y, Z], Term(\"P\", X, Y, Z))))\n        Forall([X: str] : P(?X, sk__1(?X), sk__2(?X)))\n        &gt;&gt;&gt; skolemize(Forall([X], And(Exists([Y, Z], Term(\"P\", X, Y, Z)), Exists([Y], Term(\"Q\", X, Y)))))\n        Forall([X: str] : And(P(?X, sk__1(?X), sk__2(?X)), Q(?X, sk__3(?X))))\n\n\n    :param sentence:\n    :param universal_vars:\n    :param substitution_map:\n    :return:\n    \"\"\"\n    if substitution_map is None:\n        substitution_map = {}\n    if not universal_vars:\n        universal_vars = []\n    if isinstance(sentence, Forall):\n        return Forall(sentence.variables, skolemize(sentence.sentence, universal_vars + sentence.variables, substitution_map))\n    if isinstance(sentence, Exists):\n        vars_to_skolemize = [v for v in sentence.variables if v not in universal_vars]\n        n = len(substitution_map)\n        for v in vars_to_skolemize:\n            n += 1\n            skolem_term = Term(f\"sk__{n}\", *universal_vars)\n            substitution_map[v.name] = skolem_term\n        return skolemize(sentence.sentence, universal_vars, substitution_map)\n    if isinstance(sentence, BooleanSentence):\n        return type(sentence)(*[skolemize(op, universal_vars, substitution_map) for op in sentence.operands])\n    elif isinstance(sentence, Term):\n        return Term(sentence.predicate,\n                    {\n                        k: substitution_map[v.name] if isinstance(v, Variable) and v.name in substitution_map else v\n                        for k, v in sentence.bindings.items()\n                    })\n    else:\n        raise ValueError(f\"Unknown sentence type {type(sentence)} // {sentence}\")\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.to_cnf","title":"<code>to_cnf(sentence, skip_skolemization=False)</code>","text":"<p>Convert a sentence to conjunctive normal form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic.profiles import SortedLogic\n&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; S = Term(\"S\")\n&gt;&gt;&gt; T = Term(\"T\")\n&gt;&gt;&gt; to_cnf(P)\nP\n&gt;&gt;&gt; to_cnf(P &amp; Q)\nAnd(P, Q)\n&gt;&gt;&gt; to_cnf(P | Q)\nOr(P, Q)\n&gt;&gt;&gt; to_cnf(P &gt;&gt; Q)\nOr(Not(P), Q)\n&gt;&gt;&gt; to_cnf(~(P | Q) | R)\nAnd(Or(Not(P), R), Or(Not(Q), R))\n&gt;&gt;&gt; to_cnf((P &amp; Q) &gt;&gt; R)\nOr(Not(P), Not(Q), R)\n&gt;&gt;&gt; to_cnf(((P &amp; Q) | (R &amp; S)))\nAnd(Or(R, P), Or(S, P), Or(R, Q), Or(S, Q))\n&gt;&gt;&gt; to_cnf((P | Q) &amp; (R | S))\nAnd(Or(P, Q), Or(R, S))\n&gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n&gt;&gt;&gt; to_cnf(sentence)\nAnd(Or(Q(?X), S(?Z)), Or(R(?Y), S(?Z)))\n&gt;&gt;&gt; to_cnf(P &gt;&gt; (Q | R))\nOr(Not(P), Q, R)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>skip_skolemization</code> <code>False</code> <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def to_cnf(sentence: Sentence, skip_skolemization=False) -&gt; Sentence:\n    \"\"\"\n    Convert a sentence to conjunctive normal form.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic.profiles import SortedLogic\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; S = Term(\"S\")\n        &gt;&gt;&gt; T = Term(\"T\")\n        &gt;&gt;&gt; to_cnf(P)\n        P\n        &gt;&gt;&gt; to_cnf(P &amp; Q)\n        And(P, Q)\n        &gt;&gt;&gt; to_cnf(P | Q)\n        Or(P, Q)\n        &gt;&gt;&gt; to_cnf(P &gt;&gt; Q)\n        Or(Not(P), Q)\n        &gt;&gt;&gt; to_cnf(~(P | Q) | R)\n        And(Or(Not(P), R), Or(Not(Q), R))\n        &gt;&gt;&gt; to_cnf((P &amp; Q) &gt;&gt; R)\n        Or(Not(P), Not(Q), R)\n        &gt;&gt;&gt; to_cnf(((P &amp; Q) | (R &amp; S)))\n        And(Or(R, P), Or(S, P), Or(R, Q), Or(S, Q))\n        &gt;&gt;&gt; to_cnf((P | Q) &amp; (R | S))\n        And(Or(P, Q), Or(R, S))\n        &gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n        &gt;&gt;&gt; to_cnf(sentence)\n        And(Or(Q(?X), S(?Z)), Or(R(?Y), S(?Z)))\n        &gt;&gt;&gt; to_cnf(P &gt;&gt; (Q | R))\n        Or(Not(P), Q, R)\n\n    :param sentence:\n    :param skip_skolemization:\n    :return:\n    \"\"\"\n    # Eliminate XORs\n    sentence = transform_sentence_chained(sentence, [expand_xor, expand_exactly_one])\n    # Eliminate implications and equivalences\n    sentence = eliminate_all_implications_recursive(sentence)\n    # Move negations inward\n    sentence = transform_sentence_chained(sentence, [apply_demorgans, apply_quantifier_negation])\n    # Standardize variables - TODO\n    # Skolemize\n    if not skip_skolemization:\n        sentence = skolemize(sentence)\n    #def raise_if_exists(s: Sentence) -&gt; Sentence:\n    #    if isinstance(s, Exists):\n    #        raise NotInProfileError(\"Exists not allowed in CNF\")\n    #    return s\n\n    #transform_sentence(sentence, raise_if_exists)\n    # Drop universal quantifiers\n    sentence = transform_sentence(sentence, lambda s: s.sentence if isinstance(s, Forall) else s)\n    # Distribute OR over AND\n    sentence = transform_sentence(sentence, distribute_and_over_or)\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.to_cnf_lol","title":"<code>to_cnf_lol(sentence, **kwargs)</code>","text":"<p>Convert a sentence to a list of lists of sentences in conjunctive normal form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n&gt;&gt;&gt; to_cnf_lol(sentence)\n[[Q(?X), S(?Z)], [R(?Y), S(?Z)]]\n\n&gt;&gt;&gt; to_cnf_lol(Term(\"P\"))\n[[P]]\n\n&gt;&gt;&gt; to_cnf_lol(Or(Term(\"P\"), Term(\"Q\")))\n[[P, Q]]\n&gt;&gt;&gt; to_cnf_lol(And(Term(\"P\"), Term(\"Q\")))\n[[P], [Q]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>kwargs</code> <code>{}</code> <p>Returns:</p> Type Description <code>List[List[Sentence]]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def to_cnf_lol(sentence: Sentence, **kwargs) -&gt; List[List[Sentence]]:\n    \"\"\"\n    Convert a sentence to a list of lists of sentences in conjunctive normal form.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; sentence = Or(And(Term(\"Q\", X), Term(\"R\", Y)), Term(\"S\", Z))\n        &gt;&gt;&gt; to_cnf_lol(sentence)\n        [[Q(?X), S(?Z)], [R(?Y), S(?Z)]]\n\n        &gt;&gt;&gt; to_cnf_lol(Term(\"P\"))\n        [[P]]\n\n        &gt;&gt;&gt; to_cnf_lol(Or(Term(\"P\"), Term(\"Q\")))\n        [[P, Q]]\n        &gt;&gt;&gt; to_cnf_lol(And(Term(\"P\"), Term(\"Q\")))\n        [[P], [Q]]\n\n    :param sentence:\n    :param kwargs:\n    :return:\n    \"\"\"\n    sentence = to_cnf(sentence, **kwargs)\n    sentence = simplify(sentence)\n    if not isinstance(sentence, And):\n        sentence = And(sentence)\n    return [\n        list(op.operands) if isinstance(op, Or) else [op] for op in sentence.operands\n    ]\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.to_horn_rules","title":"<code>to_horn_rules(sentence, allow_disjunctions_in_head=False, allow_goal_clauses=None)</code>","text":"<p>Convert a sentence to a list of Horn rules.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; S = Term(\"S\")\n&gt;&gt;&gt; print(as_prolog(to_horn_rules(R &gt;&gt; (Q &amp; P))))\nq :- r.\np :- r.\n&gt;&gt;&gt; print(as_prolog(to_horn_rules((R &amp; S) &gt;&gt; P)))\np :- r, s.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <code>allow_disjunctions_in_head</code> <code>False</code> <p>Returns:</p> Type Description <code>List[Sentence]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def to_horn_rules(sentence: Sentence, allow_disjunctions_in_head=False, allow_goal_clauses=None) -&gt; List[Sentence]:\n    \"\"\"\n    Convert a sentence to a list of Horn rules.\n\n    Examples:\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; Z = Variable(\"Z\", \"str\")\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; S = Term(\"S\")\n        &gt;&gt;&gt; print(as_prolog(to_horn_rules(R &gt;&gt; (Q &amp; P))))\n        q :- r.\n        p :- r.\n        &gt;&gt;&gt; print(as_prolog(to_horn_rules((R &amp; S) &gt;&gt; P)))\n        p :- r, s.\n\n    :param sentence:\n    :param allow_disjunctions_in_head:\n    :return:\n    \"\"\"\n    if allow_goal_clauses is None:\n        allow_goal_clauses = allow_disjunctions_in_head\n    sentence = transform_sentence(sentence, lambda s: s.to_model_object() if isinstance(s, Extension) else s)\n    sentence = simplify(sentence)\n    # TODO: check if already in horn profile\n    cnf_lol = to_cnf_lol(sentence, skip_skolemization=True)\n    rules: List[Sentence] = []\n    for dnf_sentence in cnf_lol:\n        # separate into positive and negative literals\n        positive = [] # head\n        negative = [] # body\n        for lit in dnf_sentence:\n            if isinstance(lit, Not):\n                negative.append(lit.negated)\n            else:\n                positive.append(lit)\n        if not positive and not negative:\n            # The empty clause, consisting of no literals (which is equivalent to false) is a goal clause\n            rules.append(Or())\n            continue\n        # a horn clause is a disjunction of literals with at most one positive literal.\n        if len(positive) &gt; 1 and not allow_disjunctions_in_head:\n            # not a horn clause (and not disjunctive datalog).\n            # we could potentially generate multiple rules here, but this could\n            # lead to stratified negation issues. We choose the last to be order preserving\n            pos = positive[-1]\n            other_pos = positive[:-1]\n            anded = negative + [Not(other) for other in other_pos]\n            rules.append(Implies(And(*anded), pos))\n            # TODO: uncomment this to generate multiple rules\n            #for pos in positive:\n            #    other_pos = [p for p in positive if p != pos]\n            #    anded = negative + [Not(other) for other in other_pos]\n            #    rules.append(Implies(And(*anded), pos))\n            continue\n        # a unit clause is a disjunction of literals with no negative literals\n        body = And(*negative) if len(negative) != 1 else negative[0]\n        if not positive and allow_goal_clauses:\n            # A Horn clause without a positive literal is a goal clause.\n            # Or() == False\n            rules.append(Implies(body, Or()))\n        if len(positive) == 1:\n            head = positive[0]\n            rules.append(Implies(body, head))\n        if len(positive) &gt; 1:\n            # we must be in disjunctive datalog at this pont\n            head = Or(*positive)\n            rules.append(Implies(body, head))\n    return rules\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.expand_xor","title":"<code>expand_xor(sentence)</code>","text":"<p>Expand XOR in a sentence.</p> <p>Replace A \u2295 B with (A \u2228 B) \u2227 \u00ac(A \u2227 B)</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; expand_xor(P ^ Q)\nAnd(Or(P, Q), Not(And(P, Q)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def expand_xor(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Expand XOR in a sentence.\n\n    Replace A \u2295 B with (A \u2228 B) \u2227 \u00ac(A \u2227 B)\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Variable, Term, Forall\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; expand_xor(P ^ Q)\n        And(Or(P, Q), Not(And(P, Q)))\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Xor):\n        return sentence\n    # expand XOR to an OR plus an AND, where len(operands) may be &gt; 2\n    operands = sentence.operands\n    if len(operands) == 1:\n        return operands[0]\n    return And(Or(*operands), Not(And(*operands)))\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.eliminate_all_implications_recursive","title":"<code>eliminate_all_implications_recursive(sentence)</code>","text":"<p>Replace A \u2192 B with \u00acA \u2228 B Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A), then apply the above rule</p> <p>Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)</p> <pre><code>&gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; print(eliminate_all_implications_recursive(P &gt;&gt; Q))\n(~P) | (Q)\n&gt;&gt;&gt; print(eliminate_all_implications_recursive(Iff(P, Q)))\n((~P) | (Q)) &amp; ((~Q) | (P))\n&gt;&gt;&gt; print(eliminate_all_implications_recursive(P &amp; ( Q &gt;&gt; R)))\n(P) &amp; ((~Q) | (R))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_all_implications_recursive(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Replace A \u2192 B with \u00acA \u2228 B\n    Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A), then apply the above rule\n\n    Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)\n\n        &gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; print(eliminate_all_implications_recursive(P &gt;&gt; Q))\n        (~P) | (Q)\n        &gt;&gt;&gt; print(eliminate_all_implications_recursive(Iff(P, Q)))\n        ((~P) | (Q)) &amp; ((~Q) | (P))\n        &gt;&gt;&gt; print(eliminate_all_implications_recursive(P &amp; ( Q &gt;&gt; R)))\n        (P) &amp; ((~Q) | (R))\n\n    :param sentence:\n    :return:\n    \"\"\"\n\n    def eliminate_implies(sentence: Sentence) -&gt; Sentence:\n        if isinstance(sentence, Implies):\n            return Or(Not(sentence.antecedent), sentence.consequent)\n        return sentence\n\n    def eliminate_implied(sentence: Sentence) -&gt; Sentence:\n        if isinstance(sentence, Implied):\n            return Implies(sentence.antecedent, sentence.consequent)\n        return sentence\n\n    def eliminate_iff(sentence: Sentence) -&gt; Sentence:\n        if isinstance(sentence, Iff):\n            return And(\n                Implies(sentence.left, sentence.right),\n                Implies(sentence.right, sentence.left),\n            )\n        return sentence\n\n    return transform_sentence_chained(sentence, [eliminate_iff, eliminate_implied, eliminate_implies])\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.eliminate_iff","title":"<code>eliminate_iff(sentence)</code>","text":"<p>Eliminate iff from a sentence.</p> <p>Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)</p> <pre><code>&gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Iff(Term(\"Q\", X), Term(\"R\", Y))\n&gt;&gt;&gt; eliminate_iff(sentence)\nAnd(Implies(Q(?X), R(?Y)), Implies(R(?Y), Q(?X)))\n\n&gt;&gt;&gt; sentence = Forall([X], Iff(Term(\"Q\", X), Term(\"R\", Y)))\n&gt;&gt;&gt; eliminate_iff(sentence)\nForall([X: str] : Iff(Q(?X), R(?Y)))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_iff(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Eliminate iff from a sentence.\n\n    Replace A \u2194 B with (A \u2192 B) \u2227 (B \u2192 A)\n\n        &gt;&gt;&gt; from typedlogic import Iff, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Iff(Term(\"Q\", X), Term(\"R\", Y))\n        &gt;&gt;&gt; eliminate_iff(sentence)\n        And(Implies(Q(?X), R(?Y)), Implies(R(?Y), Q(?X)))\n\n        &gt;&gt;&gt; sentence = Forall([X], Iff(Term(\"Q\", X), Term(\"R\", Y)))\n        &gt;&gt;&gt; eliminate_iff(sentence)\n        Forall([X: str] : Iff(Q(?X), R(?Y)))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Iff):\n        return sentence\n    return And(\n        Implies(sentence.left, sentence.right),\n        Implies(sentence.right, sentence.left),\n    )\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.eliminate_implied","title":"<code>eliminate_implied(sentence)</code>","text":"<p>Eliminate implied from a sentence.</p> <p>This simply reverses the direction of the implication.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Implied, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Implied(Term(\"Q\", X), Term(\"R\", Y))\n&gt;&gt;&gt; eliminate_implied(sentence)\nImplies(R(?Y), Q(?X))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_implied(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Eliminate implied from a sentence.\n\n    This simply reverses the direction of the implication.\n\n        &gt;&gt;&gt; from typedlogic import Implied, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Implied(Term(\"Q\", X), Term(\"R\", Y))\n        &gt;&gt;&gt; eliminate_implied(sentence)\n        Implies(R(?Y), Q(?X))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Implied):\n        return sentence\n    return Implies(sentence.operands[1], sentence.operands[0])\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.eliminate_implies","title":"<code>eliminate_implies(sentence)</code>","text":"<p>Eliminate implies from a sentence in translation to CNF</p> <p>Replace A \u2192 B with \u00acA \u2228 B</p> <pre><code>&gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Implies(Term(\"Q\", X), Term(\"R\", Y))\n&gt;&gt;&gt; eliminate_implies(sentence)\nOr(Not(Q(?X)), R(?Y))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def eliminate_implies(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Eliminate implies from a sentence in translation to CNF\n\n    Replace A \u2192 B with \u00acA \u2228 B\n\n        &gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Implies(Term(\"Q\", X), Term(\"R\", Y))\n        &gt;&gt;&gt; eliminate_implies(sentence)\n        Or(Not(Q(?X)), R(?Y))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n    \"\"\"\n    if not isinstance(sentence, Implies):\n        return sentence\n    return Or(Not(sentence.operands[0]), sentence.operands[1])\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.apply_demorgans","title":"<code>apply_demorgans(sentence)</code>","text":"<p>Apply De Morgan's laws to a sentence.</p> <p>Replace \u00ac(A \u2227 B) with \u00acA \u2228 \u00acB Replace \u00ac(A \u2228 B) with \u00acA \u2227 \u00acB</p> <pre><code>&gt;&gt;&gt; from typedlogic import And, Or, Not, Variable, Term, Forall\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; sentence = Not(And(Term(\"Q\", X), Term(\"R\", Y)))\n&gt;&gt;&gt; apply_demorgans(sentence)\nOr(Not(Q(?X)), Not(R(?Y)))\n</code></pre> <p>Note: does not recurse, use :ref:<code>transform_sentence</code> to apply to all sub-sentences.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def apply_demorgans(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Apply De Morgan's laws to a sentence.\n\n    Replace \u00ac(A \u2227 B) with \u00acA \u2228 \u00acB\n    Replace \u00ac(A \u2228 B) with \u00acA \u2227 \u00acB\n\n        &gt;&gt;&gt; from typedlogic import And, Or, Not, Variable, Term, Forall\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; sentence = Not(And(Term(\"Q\", X), Term(\"R\", Y)))\n        &gt;&gt;&gt; apply_demorgans(sentence)\n        Or(Not(Q(?X)), Not(R(?Y)))\n\n    Note: does not recurse, use :ref:`transform_sentence` to apply to all sub-sentences.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Not):\n        return sentence\n    negated = sentence.negated\n    if isinstance(negated, And):\n        return Or(*[Not(op) for op in negated.operands])\n    if isinstance(negated, Or):\n        return And(*[Not(op) for op in negated.operands])\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.apply_quantifier_negation","title":"<code>apply_quantifier_negation(sentence)</code>","text":"<p>Apply negation of quantifiers to a sentence.</p> <p>Replace \u00ac\u2200x P(x) with \u2203x \u00acP(x) Replace \u00ac\u2203x P(x) with \u2200x \u00acP(x)</p> <pre><code>&gt;&gt;&gt; from typedlogic import Forall, Variable, Term\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; sentence = Not(Forall([X], Term(\"P\", X)))\n&gt;&gt;&gt; apply_quantifier_negation(sentence)\nExists(X: str : Not(P(?X)))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Sentence</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def apply_quantifier_negation(sentence: Sentence) -&gt; Sentence:\n    \"\"\"\n    Apply negation of quantifiers to a sentence.\n\n    Replace \u00ac\u2200x P(x) with \u2203x \u00acP(x)\n    Replace \u00ac\u2203x P(x) with \u2200x \u00acP(x)\n\n        &gt;&gt;&gt; from typedlogic import Forall, Variable, Term\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; sentence = Not(Forall([X], Term(\"P\", X)))\n        &gt;&gt;&gt; apply_quantifier_negation(sentence)\n        Exists(X: str : Not(P(?X)))\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if not isinstance(sentence, Not):\n        return sentence\n    negated = sentence.negated\n    if isinstance(negated, Forall):\n        return Exists(negated.variables, Not(negated.sentence))\n    if isinstance(negated, Exists):\n        return Forall(negated.variables, Not(negated.sentence))\n    return sentence\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.force_stratification","title":"<code>force_stratification(horn_rules)</code>","text":"<p>Force stratification of a list of horn rules.</p> <p>If the program is not stratified, remove a rule using negation that causes the issue and recurse.</p> <p>Note that this will weaken the program, but it will be stratified.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n&gt;&gt;&gt; P = Term(\"P\")\n&gt;&gt;&gt; Q = Term(\"Q\")\n&gt;&gt;&gt; R = Term(\"R\")\n&gt;&gt;&gt; sentence = Iff(P&amp;Q, R)\n&gt;&gt;&gt; rules = to_horn_rules(sentence)\n&gt;&gt;&gt; force_stratification(rules)\n[Implies(And(P, Q), R), Implies(R, P), Implies(R, Q)]\n&gt;&gt;&gt; sentence = And(Iff(P|Q, R), Iff(P, ~Q))\n&gt;&gt;&gt; rules = to_horn_rules(sentence)\n&gt;&gt;&gt; rules\n[Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q), Implies(And(Not(Q)), P)]\n&gt;&gt;&gt; force_stratification(rules)\n[Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q)]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>horn_rules</code> <code>List[Sentence]</code> required <p>Returns:</p> Type Description <code>List[Sentence]</code> Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def force_stratification(horn_rules: List[Sentence]) -&gt; List[Sentence]:\n    \"\"\"\n    Force stratification of a list of horn rules.\n\n    If the program is not stratified, remove a rule using negation that causes the issue\n    and recurse.\n\n    Note that this will weaken the program, but it will be stratified.\n\n        &gt;&gt;&gt; from typedlogic import Implies, Variable, Term, Forall\n        &gt;&gt;&gt; P = Term(\"P\")\n        &gt;&gt;&gt; Q = Term(\"Q\")\n        &gt;&gt;&gt; R = Term(\"R\")\n        &gt;&gt;&gt; sentence = Iff(P&amp;Q, R)\n        &gt;&gt;&gt; rules = to_horn_rules(sentence)\n        &gt;&gt;&gt; force_stratification(rules)\n        [Implies(And(P, Q), R), Implies(R, P), Implies(R, Q)]\n        &gt;&gt;&gt; sentence = And(Iff(P|Q, R), Iff(P, ~Q))\n        &gt;&gt;&gt; rules = to_horn_rules(sentence)\n        &gt;&gt;&gt; rules\n        [Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q), Implies(And(Not(Q)), P)]\n        &gt;&gt;&gt; force_stratification(rules)\n        [Implies(P, R), Implies(Q, R), Implies(And(R, Not(P)), Q)]\n\n    :param horn_rules:\n    :return:\n    \"\"\"\n    pmap: Dict[str, List[Tuple[str, bool]]] = defaultdict(list)\n    edge_to_rules = defaultdict(list)\n    for i, rule in enumerate(horn_rules):\n        if isinstance(rule, Implies):\n            head = rule.consequent\n            if not isinstance(head, Term):\n                continue\n            pred = head.predicate\n            body = rule.antecedent\n            if isinstance(body, And):\n                terms = list(body.operands)\n            else:\n                terms = [body]\n            for term in terms:\n                negated = False\n                if isinstance(term, Not):\n                    term = term.negated\n                    negated = True\n                if not isinstance(term, Term):\n                    continue\n                pmap[pred].append((term.predicate, negated))\n                if negated:\n                    edge_to_rules[(pred, term.predicate)].append(i)\n    is_stratified, edge, _ = analyze_datalog_program(list(pmap.items()))\n    if not is_stratified:\n        if not edge:\n            raise AssertionError\n        candidates = edge_to_rules[edge] if edge in edge_to_rules else []\n        if not candidates:\n            raise AssertionError(f\"Stratification failed; cannot find {edge} in {edge_to_rules}\")\n        rule_to_remove = candidates[0]\n        horn_rules = [rule for i, rule in enumerate(horn_rules) if i != rule_to_remove]\n        return force_stratification(horn_rules)\n    return horn_rules\n</code></pre>"},{"location":"concepts/transformations/#typedlogic.transformations.ensure_terms_positional","title":"<code>ensure_terms_positional(theory)</code>","text":"<p>Ensure that all terms in a theory have all positions filled and ordered.</p> <pre><code>&gt;&gt;&gt; from typedlogic import Term, Variable, PredicateDefinition, Theory\n&gt;&gt;&gt; X = Variable(\"X\", \"str\")\n&gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n&gt;&gt;&gt; theory = Theory(predicate_definitions=[PredicateDefinition(\"P\", {\"x\": \"str\", \"y\": \"str\"})])\n&gt;&gt;&gt; s1 = Term(\"P\", X, Y)\n&gt;&gt;&gt; s2 = Term(\"P\", {\"x\": X, \"y\": Y})\n&gt;&gt;&gt; s3 = Term(\"P\", {\"y\": Y, \"x\": X})\n&gt;&gt;&gt; s4 = Term(\"P\", {\"y\": Y})\n&gt;&gt;&gt; s5 = Term(\"P\", {})\n&gt;&gt;&gt; theory.add(s1)\n&gt;&gt;&gt; theory.add(s2)\n&gt;&gt;&gt; theory.add(s3)\n&gt;&gt;&gt; theory.add(s4)\n&gt;&gt;&gt; theory.add(s5)\n&gt;&gt;&gt; ensure_terms_positional(theory)\n&gt;&gt;&gt; for s in theory.sentences:\n...     print(s)\nP(?X, ?Y)\nP(?X, ?Y)\nP(?X, ?Y)\nP(None, ?Y)\nP(None, None)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>theory</code> <code>Theory</code> required <p>Returns:</p> Type Description Source code in <code>src/typedlogic/transformations.py</code> <pre><code>def ensure_terms_positional(theory: Theory):\n    \"\"\"\n    Ensure that all terms in a theory have all positions filled and ordered.\n\n        &gt;&gt;&gt; from typedlogic import Term, Variable, PredicateDefinition, Theory\n        &gt;&gt;&gt; X = Variable(\"X\", \"str\")\n        &gt;&gt;&gt; Y = Variable(\"Y\", \"str\")\n        &gt;&gt;&gt; theory = Theory(predicate_definitions=[PredicateDefinition(\"P\", {\"x\": \"str\", \"y\": \"str\"})])\n        &gt;&gt;&gt; s1 = Term(\"P\", X, Y)\n        &gt;&gt;&gt; s2 = Term(\"P\", {\"x\": X, \"y\": Y})\n        &gt;&gt;&gt; s3 = Term(\"P\", {\"y\": Y, \"x\": X})\n        &gt;&gt;&gt; s4 = Term(\"P\", {\"y\": Y})\n        &gt;&gt;&gt; s5 = Term(\"P\", {})\n        &gt;&gt;&gt; theory.add(s1)\n        &gt;&gt;&gt; theory.add(s2)\n        &gt;&gt;&gt; theory.add(s3)\n        &gt;&gt;&gt; theory.add(s4)\n        &gt;&gt;&gt; theory.add(s5)\n        &gt;&gt;&gt; ensure_terms_positional(theory)\n        &gt;&gt;&gt; for s in theory.sentences:\n        ...     print(s)\n        P(?X, ?Y)\n        P(?X, ?Y)\n        P(?X, ?Y)\n        P(None, ?Y)\n        P(None, None)\n\n    :param theory:\n    :return:\n    \"\"\"\n    def tr(s: Sentence):\n        if isinstance(s, Term):\n            pds = [pd for pd in theory.predicate_definitions if pd.predicate == s.predicate]\n            if len(pds) != 1:\n                # could include builtins\n                return\n            pd = pds[0]\n            if not s.positional:\n                s.bindings = {k: s.bindings.get(k) for k, v in pd.arguments.items()}\n    for s in theory.sentences:\n        transform_sentence(s, tr)\n</code></pre>"},{"location":"integrations/frameworks/pydantic/","title":"Pydantic","text":"<pre><code>from typedlogic.integrations.frameworks.pydantic import FactBaseModel\nfrom pydantic import Field\n\nclass Person(FactBaseModel):\n    name: str = Field(..., description=\"unique name of the person\")\n    age: int = Field(..., description=\"age in years\", ge=0)\n</code></pre> <pre><code>Person(\"Akira\", 20)\n</code></pre> <pre>\n<code>Person(name='Akira', age=20)</code>\n</pre> <pre><code>from pydantic import Field, ValidationError\n\ntry:\n    Person(\"Akira\", \"20 years\")\nexcept ValidationError as e:\n    print(\"Got in error (this is expected!)\")\n    print(e)\n</code></pre> <pre>\n<code>Got in error (this is expected!)\n1 validation error for Person\nage\n  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='20 years', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.9/v/int_parsing\n</code>\n</pre> <pre><code>from utils import show\nshow(\"examples/pydantic_example.py\")\n</code></pre> <pre>from typedlogic.integrations.frameworks.pydantic import FactBaseModel\nfrom pydantic import Field\n\nclass Person(FactBaseModel):\n    name: str = Field(..., description=\"unique name of the person\")\n    age: int = Field(..., description=\"age in years\", ge=0)\n</pre> <pre><code>import examples.pydantic_example\n</code></pre> <pre><code>from typedlogic.parsers.pyparser import PythonParser\npp = PythonParser()\ntheory = pp.parse(open(\"examples/pydantic_example.py\"))\n</code></pre> <pre><code>theory.predicate_definitions[0]\n</code></pre> <pre>\n<code>PredicateDefinition(predicate='FactBaseModel', arguments={}, description=None, metadata=None, parents=[], python_class=None)</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"integrations/frameworks/pydantic/#pydantic-integration","title":"Pydantic Integration","text":"<p>With typed-logic, you can use whatever framework you like to define the classes that specify predicate definitions in your theory:</p> <ul> <li>Python <code>dataclasses</code> (part of the Python standard)</li> <li>Hand-rolled classes</li> <li>Pydantic</li> </ul> <p>The only requirement is that you inherit from <code>Fact</code> or <code>FactMixin</code>, or declare your class to be a predicate definition with <code>@predicate</code>. For convenience, there is a ready-made base class for you to use.</p> <p>However, there are some specific considerations for Pydantic due to its aversion to positional arguments.</p>"},{"location":"integrations/frameworks/pydantic/#using-the-pydantic-bridge","title":"Using the Pydantic bridge","text":""},{"location":"integrations/frameworks/owldl/","title":"OWL Integration","text":"<ul> <li>OWL Top Level Classes</li> <li>OWL Reasoning</li> </ul>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/","title":"Owldl tutorial","text":"<pre><code>from typedlogic.integrations.frameworks.owldl import (Thing,\n                                                      TopDataProperty,\n                                                      TopObjectProperty)\n</code></pre> <pre><code>class Person(Thing):\n    \"\"\"A person, living or dead.\"\"\"\n</code></pre> <p>This works just as a normal Python class -- but note that this class is somewhat unusual in that it only has a single attribute, <code>iri</code>, which is the IRI of the individual in the OWL ontology. Actual attributes of a Person, such as their age or list of friends would be represented as instances of properties.</p> <p>Let's instantiate a person:</p> <pre><code>AKIRA = Person(\"Akira\")\n</code></pre> <p>The only direct property is the IRI. We can examine it:</p> <pre><code>AKIRA.iri\n</code></pre> <pre>\n<code>'Akira'</code>\n</pre> <p>For conversion to OWL serializations this will need to be an actual IRI - for now we treat it as having an implicit base prefix. The OWL-DL integration is not concerned with serializations, only with logical aspects.</p> <pre><code>class HasParent(TopObjectProperty):\n    \"\"\"A property that relates a person to their parent.\"\"\"\n    domain = Person\n    range = Person\n</code></pre> <p>Note that we are setting two class variables here. These are class variables and fixed for all instances of <code>HasParent</code>.</p> <p>Next we'll start collecting some ObjectPropertyAssertions</p> <pre><code>BIANCA = Person(\"Bianca\")\na2b = HasParent(AKIRA.iri, BIANCA.iri)\na2b\n</code></pre> <pre>\n<code>HasParent(subject='Akira', object='Bianca')</code>\n</pre> <p>All TopObjectProperty classes are treated as typed-logic Predicate Definitions for binary predicates, where the domain and range are individuals.</p> <p>We can examine these:</p> <pre><code>a2b.subject, a2b.object\n</code></pre> <pre>\n<code>('Akira', 'Bianca')</code>\n</pre> <p>Each such object has a FOL representation. We can examine this using<code>to_sentences</code>:</p> <pre><code>for s in HasParent.to_sentences():\n    print(s)\n</code></pre> <pre>\n<code>\u2200P: None, I: None, J: None : (HasParent(?I, ?J) -&gt; TopObjectProperty(?I, ?J))\n\u2200I: None, J: None : (HasParent(?I, ?J) -&gt; Person(?I))\n\u2200I: None, J: None : (HasParent(?I, ?J) -&gt; Person(?J))\n</code>\n</pre> <p>Normally there is no need to examine these assertions, they will be accessed for us by a reasoning mechanism, but for now they can be a useful way of examining the semantics (at the ABox level) of the ontology. </p> <p>Here we can see that in addition to the trivial inference that all <code>HasParent</code> assertions are of type <code>HasParent</code>, we also see that the subject and object are of type <code>Person</code> (from the domain and range constraints).</p> <pre><code>class HasChild(TopObjectProperty):\n    \"\"\"A property that relates a person to their child.\"\"\"\n    inverse_of = HasParent\n</code></pre> <pre><code>from typedlogic.integrations.frameworks.owldl.reasoner import OWLReasoner\nreasoner = OWLReasoner()\n</code></pre> <p>Here the reasoner is just a wrapper onto an existing Solver (by default, Clingo).</p> <p>Next we will load an ontology declared as python. For convenience, we have aggregated the declarations into a single file examples/family_v1.py.</p> <pre><code>from examples.utils import show\nshow(\"examples/family_v1.py\")\n</code></pre> <pre>from typedlogic.integrations.frameworks.owldl import (\n    Thing,\n    TopObjectProperty,\n)\n\n\nclass Person(Thing):\n    \"\"\"A person, living or dead.\"\"\"\n    pass\n\nclass HasParent(TopObjectProperty):\n    \"\"\"A property that relates a person to their parent.\"\"\"\n    domain = Person\n    range = Person\n\nclass HasChild(TopObjectProperty):\n    \"\"\"A property that relates a person to their child.\"\"\"\n    inverse_of = HasParent\n</pre> <p>We can now load this ontology (TBox) into the reasoner:</p> <pre><code>reasoner.init_from_file(\"examples/family_v1.py\")\n</code></pre> <p>Next we will add facts. We will add the single fact we declared earlier.</p> <p>Note that we could feed in the instance declarations from earlier, but we don't need to here as these will be entailed by the domain and range constraints.</p> <pre><code>reasoner.add(a2b)\n</code></pre> <p>Now we'll find a model and all entailments for the predicate <code>HasChild</code>:</p> <pre><code>model = reasoner.model()\n</code></pre> <pre><code>for t in model.iter_retrieve(\"HasChild\"):\n    print(t)\n</code></pre> <pre>\n<code>HasChild(Bianca, Akira)\n</code>\n</pre> <p>We can examine all axioms the reasoner had to work with:</p> <pre><code>for s in reasoner.theory.sentences:\n    print(s)\n</code></pre> <pre>\n<code>\u2200I: None : (Person(?I) -&gt; Thing(?I))\n\u2200P: None, I: None, J: None : (HasChild(?I, ?J) -&gt; TopObjectProperty(?I, ?J))\n\u2200I: None, J: None : (HasChild(?I, ?J) &lt;-&gt; HasParent(?J, ?I))\n\u2200P: None, I: None, J: None : (HasParent(?I, ?J) -&gt; TopObjectProperty(?I, ?J))\n\u2200I: None, J: None : (HasParent(?I, ?J) -&gt; Person(?I))\n\u2200I: None, J: None : (HasParent(?I, ?J) -&gt; Person(?J))\nHasParent(Akira, Bianca)\n</code>\n</pre> <pre><code>show(\"examples/family_v2.py\")\n</code></pre> <pre>from typedlogic.integrations.frameworks.owldl import Thing, TopObjectProperty, SubObjectPropertyOf\n\n\nclass Person(Thing):\n    \"\"\"A person, living or dead.\"\"\"\n    pass\n\n\n\nclass HasAncestor(TopObjectProperty):\n    \"\"\"A property that relates a person to their parent.\"\"\"\n\nclass HasDescendant(TopObjectProperty):\n    \"\"\"A property that relates a person to their child.\"\"\"\n    transitive = True\n    asymmetric = True\n\nclass HasParent(HasAncestor):\n    \"\"\"A property that relates a person to their parent.\"\"\"\n    domain = Person\n    range = Person\n\nclass HasChild(HasDescendant):\n    \"\"\"A property that relates a person to their child.\"\"\"\n    inverse_of = HasParent\n\n__axioms__ = [ SubObjectPropertyOf(HasParent, HasAncestor), SubObjectPropertyOf(HasChild, HasDescendant) ]\n</pre> <p>Here we opted to declare the <code>SubObjectPropertyOf</code> axioms directly at the ontology level, rather than \"Frame-style\" in the predicate definitions. This illustrates how \"Manchester-style\" and \"Functional-style\" can be mixed. The Functional-style can be useful for avoiding forward declarations.</p> <p>We'll now load this ontology into the reasoner:</p> <pre><code>reasoner.init_from_file(\"examples/family_v2.py\")\n</code></pre> <p>Now we can add some facts. First we will add two direct parent-child relationships, that can be chained together to form a grandparent-grandchild relationship:</p> <pre><code>CARRIE = Person(\"Carrie\")\nreasoner.add([HasParent(AKIRA.iri, BIANCA.iri), HasParent(BIANCA.iri, CARRIE.iri)])\n</code></pre> <pre><code>model = reasoner.model()\nfor t in model.iter_retrieve(\"HasDescendant\"):\n    print(t)\n</code></pre> <pre>\n<code>HasDescendant(Carrie, Bianca)\nHasDescendant(Bianca, Akira)\nHasDescendant(Carrie, Akira)\n</code>\n</pre> <pre><code>assert len(list(model.iter_retrieve(\"HasDescendant\"))) == 3\n</code></pre> <p>As expected we have 3 descendant relationships - two direct and one indirect.</p> <pre><code>reasoner.add(HasParent(CARRIE.iri, AKIRA.iri))\n</code></pre> <pre><code>assert reasoner.coherent() is False\n</code></pre> <p>The ontology is correctly inferred to be incoherent.</p> <pre><code>reasoner.remove(HasParent(CARRIE.iri, AKIRA.iri))\nassert reasoner.coherent()\n</code></pre> <pre><code>from typedlogic import ExactlyOne\nDEEPA = Person(\"Deepa\")\nDMITRI = Person(\"Dmitri\")\nreasoner.add(ExactlyOne(HasParent(CARRIE.iri, DEEPA.iri), HasParent(CARRIE.iri, DMITRI.iri)))\n</code></pre> <pre><code>for n, model in enumerate(reasoner.model_iter()):\n    print(\"Model\", n)\n    for t in model.iter_retrieve(\"HasAncestor\", AKIRA.iri):\n        print(\" .. \", t)\n</code></pre> <pre>\n<code>Model 0\n ..  HasAncestor(Akira, Bianca)\n ..  HasAncestor(Akira, Carrie)\n ..  HasAncestor(Akira, Dmitri)\nModel 1\n ..  HasAncestor(Akira, Bianca)\n ..  HasAncestor(Akira, Carrie)\n ..  HasAncestor(Akira, Deepa)\n</code>\n</pre> <pre><code>## Classification Example\n</code></pre> <pre><code>from typedlogic.integrations.frameworks.owldl import ObjectIntersectionOf\n\nclass Parent(Thing):\n    \"\"\"A parent of a person.\"\"\"\n    equivalent_to = ObjectIntersectionOf(Person, HasParent.some(Person))\n</code></pre> <pre><code>for s in Parent.to_sentences():\n    print(s)\n</code></pre> <pre>\n<code>\u2200I: None : (Parent(?I) -&gt; Thing(?I))\n\u2200I: None : (Parent(?I) &lt;-&gt; (Person(?I)) &amp; (\u2203(HasParent(?I, ?J)) &amp; (Person(?J))))\n</code>\n</pre> <pre><code>reasoner.register(Parent)\n</code></pre> <pre><code>model = reasoner.model()\nfor t in model.iter_retrieve(\"Parent\"):\n    print(t)\n</code></pre> <pre>\n<code>Parent(Carrie)\nParent(Bianca)\nParent(Akira)\n</code>\n</pre> <pre><code>assert len(list(model.iter_retrieve(\"Parent\"))) == 3\n</code></pre> <pre><code>\n</code></pre>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#owl-dl-integration-tutorial","title":"OWL-DL Integration Tutorial","text":"<p>This tutorial is a brief introduction to the OWL-DL integration in typed-logic. Some basic familiarity with OWL-DL is assumed, see the OWL2 Primer for a good introduction.</p> <p>This tutorial shows how to represent OWL TBoxes (Ontologies) as Python programs, together with representing ABoxes (Individuals and Individual-level facts) as Python objects.</p> <p>The tutorial is a Jupyter notebook - you can run it interactively in a Jupyter environment, or simply read it as a document.</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#initial-imports","title":"Initial imports","text":"<p>We will import the necessary classes from the <code>integrations</code> package:</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#a-simple-class","title":"A simple class","text":"<p>Next we'll define a simple class <code>Person</code>.</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#defining-object-properties","title":"Defining Object Properties","text":"<p>We define object properties by subclassing <code>TopObjectProperty</code>. For example, we can define a property <code>HasParent</code> that relates a person to their parent:</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#entailments-defining-inverses","title":"Entailments: Defining inverses","text":"<p>Next we will introduce the concept of entailing inverses.</p> <p>We will make the <code>HasChild</code> property the inverse of <code>HasParent</code>:</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#finding-entailments-using-a-reasoner","title":"Finding entailments using a reasoner","text":"<p>We have declared some axioms, now it's time to find some entailments. For this we will use a Reasoner object:</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#consistency-checking","title":"Consistency Checking","text":"<p>Next we will extend our ontology. We will:</p> <ul> <li>add transitive predicates for <code>HasAncestor</code> and <code>HasDescendant</code></li> <li>add an <code>Asymmetric</code> constraint that prevents loops in the graph.</li> </ul> <p>We will use this program:</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#adding-a-cycle","title":"Adding a cycle","text":"<p>Now we will see what happens when a cycle is introduced, for example: <code>Alice -&gt; Jie -&gt; Bob -&gt; Alice</code></p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#multiple-models","title":"Multiple Models","text":"<p>Next, we will introduce uncertainty into the knowledge base. We will add an assertion that one of the following is true:</p> <ul> <li><code>HasParent(Carrie, Deepa)</code></li> <li><code>HasParent(Carrie, Dmitri)</code></li> </ul> <p>Formally, this introduces multiple alternate models. The term \"model\" here is used in the sense of model-theoretic semantics, you can think of this as being \"possible worlds\" where the axioms are true.</p> <p>Depending on the underlying Solver, we may be able to enumerate all models. Here we will use the default solver, Clingo, which is based in Answer Set Programming (ASP), which supports this.</p>"},{"location":"integrations/frameworks/owldl/owldl-tutorial/#next-steps","title":"Next Steps","text":"<p>Consult the documentation for the various OWL constructs. These all follow the OWL2 Functional Syntax, and for attribute names we follow py-horned-owl as far as possible.</p>"},{"location":"integrations/frameworks/owldl/owltop/","title":"OWL Top Level Classes","text":"<p>OWL-DL Top Level Classes and Axioms.</p> <p>In this integration, OWL-DL is treated as a subset of FOL, consisting of (a) Unary predicate definitions (classes) and (b) Binary predicate definitions (Object and Data Properties).</p> <p>This module also provides Pythonic integration through top-level classes that can be inherited to defined OWL ontologies through Python classes. These Python classes can be treated as normal python classes, they can be instantiated to create an ABox. They can also be translated into FOL axioms, where they can be used for reasoning over ABoxes using a Solver.</p> <p>This module is pure python and does not attempt to parse or serialize OWL - for that, an integration with a framework such as Py-horned-owl is recommended.</p>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.Thing","title":"<code>Thing</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Fact</code></p> <p>The top level class in OWL-DL. Everything is a Thing.</p> <p>For your object model to be included in the OWL-DL mapping, all your classes representing individuals should inherit from Thing.</p> <p>Basic Example:</p> <pre><code>class Person(Thing):\n    '''A person'''\n\nclass Pet(Thing):\n    '''A pet'''\n</code></pre> <p>Formally, OWL Classes are unary predicates, and instances are unary ground terms:</p> <pre><code>facts = [Person(\"P1\"), Pet(\"Fido\")]\n</code></pre> <p>You can create more complex defined classes, using OWL Frame-style class definitions:</p> <pre><code>class HasPet(TopObjectProperty):\n    '''A property that relates a person to a pet'''\n    domain = Person\n    range = Pet\n\nclass PetOwner(Person):\n    '''A person that owns a pet'''\n    equivalent_to = Person &amp; ObjectSomeValuesFrom(HasPet, Pet)\n</code></pre> <p>A thing class can have ClassVars <code>equivalent_to</code>, <code>subclass_of</code>, ... Note these are class-level.</p> <p>We can create and reason over instances and facts:</p> <pre><code>facts = [Person(\"P1\"), Pet(\"Fido\"), HasPet(\"P1\", \"Fido\")]\nreasoner = OWLReasoner()\nreasoner.init_from_file(Path(__file__))\nfor f in facts:\n    reasoner.add(f)\nmodel = reasoner.model()\nfor t in model.ground_terms:\n    print(t)\n</code></pre> <p>Results will include:</p> <pre><code>PetOwner(P1)\n</code></pre> <p>Formally, the Thing class is a subclass of a typed-logic Fact, which instantiates an OWLCLass python metaclass:</p> <pre><code>classDiagram\nclass Thing {\n    IRI iri\n}\nFact &lt;|-- Thing\nThing --&gt; `OWLCLass[[metaclass]]` : instance_of\n`OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : subclass_of\n`OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : equivalent_to\n`OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : disjoint_with\n`OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : disjoint_union_of</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass(frozen=True)\nclass Thing(Fact):\n    \"\"\"\n    The top level class in OWL-DL. Everything is a Thing.\n\n    For your object model to be included in the OWL-DL mapping, all your classes\n    representing individuals should inherit from Thing.\n\n    Basic Example:\n\n    ```python\n    class Person(Thing):\n        '''A person'''\n\n    class Pet(Thing):\n        '''A pet'''\n    ```\n\n    Formally, OWL Classes are unary predicates, and instances are unary ground terms:\n\n    ```python\n    facts = [Person(\"P1\"), Pet(\"Fido\")]\n    ```\n\n    You can create more complex defined classes, using OWL Frame-style class definitions:\n\n    ```python\n    class HasPet(TopObjectProperty):\n        '''A property that relates a person to a pet'''\n        domain = Person\n        range = Pet\n\n    class PetOwner(Person):\n        '''A person that owns a pet'''\n        equivalent_to = Person &amp; ObjectSomeValuesFrom(HasPet, Pet)\n    ```\n\n    A thing class can have ClassVars `equivalent_to`, `subclass_of`, ...\n    Note these are class-level.\n\n    We can create and reason over instances and facts:\n\n    ```python\n    facts = [Person(\"P1\"), Pet(\"Fido\"), HasPet(\"P1\", \"Fido\")]\n    reasoner = OWLReasoner()\n    reasoner.init_from_file(Path(__file__))\n    for f in facts:\n        reasoner.add(f)\n    model = reasoner.model()\n    for t in model.ground_terms:\n        print(t)\n    ```\n\n    Results will include:\n\n    ```\n    PetOwner(P1)\n    ```\n\n    Formally, the Thing class is a subclass of a typed-logic Fact, which instantiates an\n    OWLCLass python metaclass:\n\n    ```mermaid\n    classDiagram\n    class Thing {\n        IRI iri\n    }\n    Fact &lt;|-- Thing\n    Thing --&gt; `OWLCLass[[metaclass]]` : instance_of\n    `OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : subclass_of\n    `OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : equivalent_to\n    `OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : disjoint_with\n    `OWLCLass[[metaclass]]` --&gt; \"*\" ClassExpression : disjoint_union_of\n    ```\n\n    \"\"\"\n\n    iri: IRI\n\n    subclass_of: ClassVar[Optional[\"ClassExpression\"]] = None\n    equivalent_to: ClassVar[Optional[\"ClassExpression\"]] = None\n    disjoint_with: ClassVar[Optional[\"ClassExpression\"]] = None\n    disjoint_union_of: ClassVar[Optional[List[\"ClassExpression\"]]] = None\n\n    @classmethod\n    def axioms_iter(cls) -&gt; Iterator[\"Axiom\"]:\n        for parent in cls.__bases__:\n            if issubclass(parent, Thing):\n                yield SubClassOf(cls, parent)\n        yield from [SubClassOf(cls, e) for e in as_list(cls.subclass_of)]\n        yield from [DisjointClasses(cls, e) for e in as_list(cls.disjoint_with)]\n        yield from [EquivalentClasses(cls, e) for e in as_list(cls.equivalent_to)]\n        if cls.disjoint_union_of:\n            yield DisjointUnion(cls, *cls.disjoint_union_of)\n\n    @classmethod\n    def axioms(cls) -&gt; List[\"Axiom\"]:\n        return list(cls.axioms_iter())\n\n    @classmethod\n    def to_sentences(cls) -&gt; List[Sentence]:\n        return [a for a in [axiom.as_fol() for axiom in cls.axioms()] if a is not None]\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.TopObjectProperty","title":"<code>TopObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Fact</code></p> <p>The top object property.</p>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.TopObjectProperty--example","title":"Example:","text":"<pre><code>class Person(Thing):\n    '''A person'''\n\nclass HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasAncestor(HasParent):\n    '''A property that relates a person to their ancestor'''\n    transitive = True\n</code></pre> <p>Formally, OWL Object Properties are binary predicates, and instances are binary ground terms:</p> <pre><code>facts = [HasParent(\"P1\", \"P2\"), HasAncestor(\"P1\", \"P3\")]\n</code></pre> <p>Formally, the TopObjectProperty class is a subclass of a 2-ary typed-logic Fact, which instantiates an OWLObjectProperty python metaclass:</p> <pre><code>classDiagram\nclass TopObjectProperty {\n    IRI subject\n    IRI object\n}\nFact &lt;|-- TopObjectProperty\nTopObjectProperty --&gt; `OWLObjectProperty[[metaclass]]` : instance_of\n`OWLObjectProperty[[metaclass]]` --&gt; \"*\" ObjectPropertyExpression : subproperty_of\n`OWLObjectProperty[[metaclass]]` --&gt; \"*\" PropertyExpressionChain : subproperty_chain\n`OWLObjectProperty[[metaclass]]` --&gt; \"*\" ClassExpression : domain\n`OWLObjectProperty[[metaclass]]` --&gt; \"*\" ClassExpression : range\n\nclass `OWLObjectProperty[[metaclass]]` {\n   Boolean transitive\n   Boolean symmetric\n   Boolean asymmetric\n   Boolean reflexive\n  Boolean irreflexive\n  Boolean functional\n  Boolean inverse_functional\n}</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass(frozen=True)\nclass TopObjectProperty(Fact):\n    \"\"\"\n    The top object property.\n\n    Example:\n    -------\n    ```python\n    class Person(Thing):\n        '''A person'''\n\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasAncestor(HasParent):\n        '''A property that relates a person to their ancestor'''\n        transitive = True\n    ```\n\n    Formally, OWL Object Properties are binary predicates, and instances are binary ground terms:\n\n    ```python\n    facts = [HasParent(\"P1\", \"P2\"), HasAncestor(\"P1\", \"P3\")]\n    ```\n\n    Formally, the TopObjectProperty class is a subclass of a 2-ary typed-logic Fact, which instantiates an\n    OWLObjectProperty python metaclass:\n\n    ```mermaid\n    classDiagram\n    class TopObjectProperty {\n        IRI subject\n        IRI object\n    }\n    Fact &lt;|-- TopObjectProperty\n    TopObjectProperty --&gt; `OWLObjectProperty[[metaclass]]` : instance_of\n    `OWLObjectProperty[[metaclass]]` --&gt; \"*\" ObjectPropertyExpression : subproperty_of\n    `OWLObjectProperty[[metaclass]]` --&gt; \"*\" PropertyExpressionChain : subproperty_chain\n    `OWLObjectProperty[[metaclass]]` --&gt; \"*\" ClassExpression : domain\n    `OWLObjectProperty[[metaclass]]` --&gt; \"*\" ClassExpression : range\n\n    class `OWLObjectProperty[[metaclass]]` {\n       Boolean transitive\n       Boolean symmetric\n       Boolean asymmetric\n       Boolean reflexive\n      Boolean irreflexive\n      Boolean functional\n      Boolean inverse_functional\n    }\n    ```\n\n\n\n    \"\"\"\n\n    subject: IRI\n    object: IRI\n\n    transitive: ClassVar[Optional[bool]] = None\n    symmetric: ClassVar[Optional[bool]] = None\n    asymmetric: ClassVar[Optional[bool]] = None\n    reflexive: ClassVar[Optional[bool]] = None\n    irreflexive: ClassVar[Optional[bool]] = None\n    functional: ClassVar[Optional[bool]] = None\n    inverse_functional: ClassVar[Optional[bool]] = None\n    subproperty_of: ClassVar[Optional[\"ObjectPropertyExpression\"]] = None\n    subproperty_chain: ClassVar[Optional[\"PropertyExpressionChain\"]] = None\n    equivalent_to: ClassVar[Optional[\"ObjectPropertyExpression\"]] = None\n    disjoint_with: ClassVar[Optional[\"ObjectPropertyExpression\"]] = None\n    inverse_of: ClassVar[Optional[\"ObjectPropertyExpression\"]] = None\n    domain: ClassVar[Optional[\"ClassExpression\"]] = None\n    range: ClassVar[Optional[\"ClassExpression\"]] = None\n\n    @classmethod\n    def some(cls, ce: \"ClassExpression\") -&gt; \"ObjectSomeValuesFrom\":\n        return ObjectSomeValuesFrom(cls, ce)\n\n    @classmethod\n    def only(cls, ce: \"ClassExpression\") -&gt; \"ObjectAllValuesFrom\":\n        return ObjectAllValuesFrom(cls, ce)\n\n    @classmethod\n    def value(cls, i: \"Individual\") -&gt; \"ObjectHasValue\":\n        return ObjectHasValue(cls, i)\n\n    @classmethod\n    def axioms_iter(cls) -&gt; Iterator[\"Axiom\"]:\n        for parent in cls.__bases__:\n            if issubclass(parent, TopObjectProperty):\n                yield SubObjectPropertyOf(cls, parent)\n        yield from [SubObjectPropertyOf(cls, e) for e in as_list(cls.subproperty_of)]\n        yield from [SubObjectPropertyOf(chain, cls) for chain in as_list(cls.subproperty_chain)]\n        yield from [ObjectPropertyDomain(cls, e) for e in as_list(cls.domain)]\n        yield from [ObjectPropertyRange(cls, e) for e in as_list(cls.range)]\n        if cls.transitive:\n            yield from [TransitiveObjectProperty(cls)]\n        if cls.symmetric:\n            yield from [SymmetricObjectProperty(cls)]\n        if cls.asymmetric:\n            yield from [AsymmetricObjectProperty(cls)]\n        if cls.reflexive:\n            yield from [ReflexiveObjectProperty(cls)]\n        if cls.irreflexive:\n            yield from [IrreflexiveObjectProperty(cls)]\n        if cls.functional:\n            yield from [FunctionalObjectProperty(cls)]\n        if cls.inverse_functional:\n            yield from [InverseFunctionalObjectProperty(cls)]\n        yield from [EquivalentObjectProperties(cls, e) for e in as_list(cls.equivalent_to)]\n        yield from [DisjointObjectProperties(cls, e) for e in as_list(cls.disjoint_with)]\n        if cls.inverse_of:\n            yield from [InverseObjectProperties(cls, cls.inverse_of)]\n\n    @classmethod\n    def axioms(cls) -&gt; List[\"Axiom\"]:\n        return list(cls.axioms_iter())\n\n    @classmethod\n    def to_sentences(cls) -&gt; List[Sentence]:\n        return [a for a in [axiom.as_fol() for axiom in cls.axioms()] if a is not None]\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.TopDataProperty","title":"<code>TopDataProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Fact</code></p> <p>The top data property.</p>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.TopDataProperty--example","title":"Example:","text":"<pre><code>class Person(Thing):\n    '''A person'''\n\nclass HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    domain = Person\n    range = int\n</code></pre> <p>Formally, OWL Data Properties are binary predicates, and instances are binary ground terms:</p> <pre><code>facts = [HasAge(\"P1\", 25)]\n</code></pre> <p>Formally, the TopDataProperty class is a subclass of a 2-ary typed-logic Fact, which instantiates an OWLDataProperty python metaclass:</p> <p><code>mermaid classDiagram class TopDataProperty {     IRI subject     Union[str, int, float, bool, Decimal] object } Fact &lt;|-- TopDataProperty TopDataProperty --&gt; `OWLDataProperty[[metaclass]]` : instance_of `OWLDataProperty[[metaclass]]` --&gt; \"*\" DataPropertyExpression : subproperty_of `OWLDataProperty[[metaclass]]` --&gt; \"*\" ClassExpression : domain `OWLDataProperty[[metaclass]]` --&gt; \"*\" DataRange : range class `OWLDataProperty[[metaclass]]` {      Boolean functional  }</code></p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass(frozen=True)\nclass TopDataProperty(Fact):\n    \"\"\"\n    The top data property.\n\n    Example:\n    -------\n    ```python\n    class Person(Thing):\n        '''A person'''\n\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        domain = Person\n        range = int\n    ```\n\n    Formally, OWL Data Properties are binary predicates, and instances are binary ground terms:\n\n    ```python\n    facts = [HasAge(\"P1\", 25)]\n    ```\n\n    Formally, the TopDataProperty class is a subclass of a 2-ary typed-logic Fact, which instantiates an\n    OWLDataProperty python metaclass:\n\n    ```mermaid\n    classDiagram\n    class TopDataProperty {\n        IRI subject\n        Union[str, int, float, bool, Decimal] object\n    }\n    Fact &lt;|-- TopDataProperty\n    TopDataProperty --&gt; `OWLDataProperty[[metaclass]]` : instance_of\n    `OWLDataProperty[[metaclass]]` --&gt; \"*\" DataPropertyExpression : subproperty_of\n    `OWLDataProperty[[metaclass]]` --&gt; \"*\" ClassExpression : domain\n    `OWLDataProperty[[metaclass]]` --&gt; \"*\" DataRange : range\n    class `OWLDataProperty[[metaclass]]` {\n         Boolean functional\n     }\n     ```\n\n    \"\"\"\n\n    subject: IRI\n    object: Union[str, int, float, bool, Decimal]\n\n    functional: ClassVar[Optional[bool]] = None\n    subproperty_of: ClassVar[Optional[\"DataPropertyExpression\"]] = None\n    equivalent_to: ClassVar[Optional[\"DataPropertyExpression\"]] = None\n    disjoint_with: ClassVar[Optional[\"DataPropertyExpression\"]] = None\n    domain: ClassVar[Optional[\"ClassExpression\"]] = None\n    range: ClassVar[Optional[\"DataRange\"]] = None\n\n    @classmethod\n    def axioms_iter(cls) -&gt; Iterator[\"Axiom\"]:\n        for parent in cls.__bases__:\n            if issubclass(parent, TopDataProperty):\n                yield SubDataPropertyOf(cls, parent)\n        yield from [SubDataPropertyOf(cls, e) for e in as_list(cls.subproperty_of)]\n        yield from [DataPropertyDomain(cls, e) for e in as_list(cls.domain)]\n        yield from [DataPropertyRange(cls, e) for e in as_list(cls.range)]\n        if cls.functional:\n            yield from [FunctionalDataProperty(cls)]\n        yield from [EquivalentDataProperties(cls, e) for e in as_list(cls.equivalent_to)]\n        yield from [DisjointDataProperties(cls, e) for e in as_list(cls.disjoint_with)]\n\n    @classmethod\n    def axioms(cls) -&gt; List[\"Axiom\"]:\n        return list(cls.axioms_iter())\n\n    @classmethod\n    def to_sentences(cls) -&gt; List[Sentence]:\n        return [a for a in [axiom.as_fol() for axiom in cls.axioms()] if a is not None]\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.Literal","title":"<code>Literal</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A literal.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass Literal(ABC):\n    \"\"\"\n    A literal.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.SimpleLiteral","title":"<code>SimpleLiteral</code>  <code>dataclass</code>","text":"<p>A simple literal.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass SimpleLiteral:\n    \"\"\"\n    A simple literal.\n    \"\"\"\n\n    literal: str\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.LanguageLiteral","title":"<code>LanguageLiteral</code>  <code>dataclass</code>","text":"<p>A language literal.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass LanguageLiteral:\n    \"\"\"\n    A language literal.\n    \"\"\"\n\n    literal: str\n    lang: str\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DatatypeLiteral","title":"<code>DatatypeLiteral</code>  <code>dataclass</code>","text":"<p>A datatype literal.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DatatypeLiteral:\n    \"\"\"\n    A datatype literal.\n    \"\"\"\n\n    literal: str\n    datatype_iri: IRI\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.Axiom","title":"<code>Axiom</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for axioms.</p> <p>Axioms can be declared implicitly, in \"Frame-style\" class definitions, or in an <code>__axioms__</code> module variable</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass Axiom(ABC):\n    \"\"\"\n    Abstract base class for axioms.\n\n    Axioms can be declared implicitly, in \"Frame-style\" class definitions, or in\n    an `__axioms__` module variable\n    \"\"\"\n\n    annotations: ClassVar[Optional[Mapping[str, Any]]] = None\n\n    #@abstractmethod\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return None\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.SubClassOf","title":"<code>SubClassOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A sub-class-of axiom.</p> <p>Axioms can be declared explicitly:</p> <pre><code>class Person(Thing):\n    '''A person'''\n\nclass Employee(Thing):\n    '''A person that is employed'''\n\n__axioms__ = [ SubClassOf(Employee, Person) ]\n</code></pre> <p>However, it is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class Person(Thing):\n    '''A person'''\n\nclass Employee(Thing):\n    '''A person that is employed'''\n    subclass_of = Person\n</code></pre> <p>Note that when the superclass is a named class, the more pythonic equivalent is preferred:</p> <pre><code>class Employee(Person):\n    '''A person that is employed'''\n</code></pre> <p>Using an explicit class var is necessary when the superclass is an expression:</p> <pre><code>class Organization(Thing):\n    '''An organization'''\n\nclass EmployedBy(TopObjectProperty):\n    domain = Employee\n    range = Organization\n\nclass Employee(Person):\n    '''A person that is employed'''\n    subclass_of = ObjectSomeValuesFrom(EmployedBy, Organization)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- SubClassOf\nSubClassOf --&gt; \"*\" ClassExpression : sub\nSubClassOf --&gt; \"*\" ClassExpression : sup</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass SubClassOf(Axiom):\n    \"\"\"\n    A sub-class-of axiom.\n\n    Axioms can be declared explicitly:\n\n    ```python\n    class Person(Thing):\n        '''A person'''\n\n    class Employee(Thing):\n        '''A person that is employed'''\n\n    __axioms__ = [ SubClassOf(Employee, Person) ]\n    ```\n\n    However, it is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class Person(Thing):\n        '''A person'''\n\n    class Employee(Thing):\n        '''A person that is employed'''\n        subclass_of = Person\n    ```\n\n    Note that when the superclass is a named class, the more pythonic equivalent is preferred:\n\n    ```python\n    class Employee(Person):\n        '''A person that is employed'''\n    ```\n\n    Using an explicit class var is necessary when the superclass is an expression:\n\n    ```python\n    class Organization(Thing):\n        '''An organization'''\n\n    class EmployedBy(TopObjectProperty):\n        domain = Employee\n        range = Organization\n\n    class Employee(Person):\n        '''A person that is employed'''\n        subclass_of = ObjectSomeValuesFrom(EmployedBy, Organization)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- SubClassOf\n    SubClassOf --&gt; \"*\" ClassExpression : sub\n    SubClassOf --&gt; \"*\" ClassExpression : sup\n    ```\n\n    \"\"\"\n\n    sub: ClassExpression\n    sup: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I], Implies(instance_of(I, self.sub), instance_of(I, self.sup)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.PropertyExpressionChain","title":"<code>PropertyExpressionChain</code>  <code>dataclass</code>","text":"<p>A chain of property expressions.</p>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.PropertyExpressionChain--example","title":"Example:","text":"<pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasGrandparent(TopObjectProperty):\n    '''A property that relates a person to their grandparent'''\n    subproperty_chain = PropertyExpressionChain(HasParent, HasParent)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nPropertyExpressionChain --&gt; \"*\" ObjectPropertyExpression : chain\n</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass PropertyExpressionChain:\n    \"\"\"\n    A chain of property expressions.\n\n    Example:\n    -------\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasGrandparent(TopObjectProperty):\n        '''A property that relates a person to their grandparent'''\n        subproperty_chain = PropertyExpressionChain(HasParent, HasParent)\n    ```\n\n    UML:\n\n    ```\n    classDiagram\n    PropertyExpressionChain --&gt; \"*\" ObjectPropertyExpression : chain\n    ```\n\n    \"\"\"\n\n    chain: Tuple[ObjectPropertyExpression, ...]\n\n    def __init__(self, *chain: ObjectPropertyExpression):\n        self.chain = chain\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.SubObjectPropertyOf","title":"<code>SubObjectPropertyOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A sub-object-property-of axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasGrandparent(TopObjectProperty):\n    '''A property that relates a person to their grandparent'''\n\n__axioms__ = [ SubObjectPropertyOf(HasGrandparent, HasParent) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasGrandparent(TopObjectProperty):\n    '''A property that relates a person to their grandparent'''\n    subproperty_of = HasParent\n</code></pre> <p>When the parent is a named class, the more pythonic equivalent is preferred:</p> <pre><code>class HasGrandparent(HasParent):\n    '''A property that relates a person to their grandparent'''\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- SubObjectPropertyOf\nSubObjectPropertyOf --&gt; \"*\" ObjectPropertyExpressionOrPropertyExpressionChain : sub\nSubObjectPropertyOf --&gt; \"*\" ObjectPropertyExpression : sup</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass SubObjectPropertyOf(Axiom):\n    \"\"\"\n    A sub-object-property-of axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasGrandparent(TopObjectProperty):\n        '''A property that relates a person to their grandparent'''\n\n    __axioms__ = [ SubObjectPropertyOf(HasGrandparent, HasParent) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasGrandparent(TopObjectProperty):\n        '''A property that relates a person to their grandparent'''\n        subproperty_of = HasParent\n    ```\n\n    When the parent is a named class, the more pythonic equivalent is preferred:\n\n    ```python\n    class HasGrandparent(HasParent):\n        '''A property that relates a person to their grandparent'''\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- SubObjectPropertyOf\n    SubObjectPropertyOf --&gt; \"*\" ObjectPropertyExpressionOrPropertyExpressionChain : sub\n    SubObjectPropertyOf --&gt; \"*\" ObjectPropertyExpression : sup\n    ```\n\n    \"\"\"\n\n    sub: Union[ObjectPropertyExpression, PropertyExpressionChain]\n    sup: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        if isinstance(self.sup, PropertyExpressionChain):\n            raise ValueError(f\"Cannot have a chain as a super property - did you accidentally invert? {self}\")\n        if isinstance(self.sub, PropertyExpressionChain):\n            chain_len = len(self.sub.chain)\n            inst_vars = [Variable(f\"J{i}\") for i in range(chain_len + 1)]\n            conjs = []\n            for i in range(chain_len):\n                conjs.append(instance_of_op(inst_vars[i], inst_vars[i + 1], self.sub.chain[i]))\n            return Forall(inst_vars, Implies(And(*conjs), instance_of_op(inst_vars[0], inst_vars[-1], self.sup)))\n        else:\n            return Forall([P, I, J], Implies(instance_of_op(I, J, self.sub), instance_of_op(I, J, self.sup)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.TransitiveObjectProperty","title":"<code>TransitiveObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A transitive-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasAncestor(TopObjectProperty):\n    pass\n\n__axioms__ = [ TransitiveObjectProperty(HasAncestor) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasAncestor(TopObjectProperty):\n    transitive = True\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- TransitiveObjectProperty\nTransitiveObjectProperty --&gt; \"1\" ObjectPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass TransitiveObjectProperty(Axiom):\n    \"\"\"\n    A transitive-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasAncestor(TopObjectProperty):\n        pass\n\n    __axioms__ = [ TransitiveObjectProperty(HasAncestor) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasAncestor(TopObjectProperty):\n        transitive = True\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- TransitiveObjectProperty\n    TransitiveObjectProperty --&gt; \"1\" ObjectPropertyExpression : first\n    ```\n\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J, K], Implies(And(instance_of_op(I, J, self.first), instance_of_op(J, K, self.first)), instance_of_op(I, K, self.first)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.InverseObjectProperties","title":"<code>InverseObjectProperties</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An inverse-object-properties axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasChild(TopObjectProperty):\n    '''A property that relates a person to their child'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ InverseObjectProperties(HasParent, HasChild) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n    inverse_of = HasChild\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- InverseObjectProperties\nInverseObjectProperties --&gt; \"1\" ObjectPropertyExpression : first\nInverseObjectProperties --&gt; \"1\" ObjectPropertyExpression : second</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass InverseObjectProperties(Axiom):\n    \"\"\"\n    An inverse-object-properties axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasChild(TopObjectProperty):\n        '''A property that relates a person to their child'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ InverseObjectProperties(HasParent, HasChild) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n        inverse_of = HasChild\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- InverseObjectProperties\n    InverseObjectProperties --&gt; \"1\" ObjectPropertyExpression : first\n    InverseObjectProperties --&gt; \"1\" ObjectPropertyExpression : second\n    ```\n    \"\"\"\n\n    first: ObjectPropertyExpression\n    second: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J], Iff(instance_of_op(I, J, self.first), instance_of_op(J, I, self.second)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.SymmetricObjectProperty","title":"<code>SymmetricObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A symmetric-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasSibling(TopObjectProperty):\n    '''A property that relates a person to their sibling'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ SymmetricObjectProperty(HasSibling) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasSibling(TopObjectProperty):\n    '''A property that relates a person to their sibling'''\n    domain = Person\n    range = Person\n    symmetric = True\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- SymmetricObjectProperty\nSymmetricObjectProperty --&gt; \"1\" ObjectPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass SymmetricObjectProperty(Axiom):\n    \"\"\"\n    A symmetric-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasSibling(TopObjectProperty):\n        '''A property that relates a person to their sibling'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ SymmetricObjectProperty(HasSibling) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasSibling(TopObjectProperty):\n        '''A property that relates a person to their sibling'''\n        domain = Person\n        range = Person\n        symmetric = True\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- SymmetricObjectProperty\n    SymmetricObjectProperty --&gt; \"1\" ObjectPropertyExpression : first\n    ```\n\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J], Iff(instance_of_op(I, J, self.first), instance_of_op(J, I, self.first)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.AsymmetricObjectProperty","title":"<code>AsymmetricObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An asymmetric-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ AsymmetricObjectProperty(HasParent) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n    asymmetric = True\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- AsymmetricObjectProperty\nAsymmetricObjectProperty --&gt; \"1\" ObjectPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass AsymmetricObjectProperty(Axiom):\n    \"\"\"\n    An asymmetric-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ AsymmetricObjectProperty(HasParent) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n        asymmetric = True\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- AsymmetricObjectProperty\n    AsymmetricObjectProperty --&gt; \"1\" ObjectPropertyExpression : first\n    ```\n\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J], Implies(instance_of_op(I, J, self.first), Not(instance_of_op(J, I, self.first))))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ReflexiveObjectProperty","title":"<code>ReflexiveObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A reflexive-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class RelatedTo(TopObjectProperty):\n    '''A property that relates a thing to itself'''\n    domain = Thing\n    range = Thing\n\n__axioms__ = [ ReflexiveObjectProperty(RelatedTo) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class RelatedTo(TopObjectProperty):\n    '''A property that relates a thing to itself'''\n    domain = Thing\n    range = Thing\n    reflexive = True\n</code></pre> <p>In practice, relfexive axioms are too strong, but we include them for completeness.</p> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- ReflexiveObjectProperty\nReflexiveObjectProperty --&gt; \"1\" ObjectPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ReflexiveObjectProperty(Axiom):\n    \"\"\"\n    A reflexive-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class RelatedTo(TopObjectProperty):\n        '''A property that relates a thing to itself'''\n        domain = Thing\n        range = Thing\n\n    __axioms__ = [ ReflexiveObjectProperty(RelatedTo) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class RelatedTo(TopObjectProperty):\n        '''A property that relates a thing to itself'''\n        domain = Thing\n        range = Thing\n        reflexive = True\n    ```\n\n    In practice, relfexive axioms are too strong, but we include them for completeness.\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- ReflexiveObjectProperty\n    ReflexiveObjectProperty --&gt; \"1\" ObjectPropertyExpression : first\n    ```\n\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, C], Implies(instance_of(I, Thing), instance_of_op(I, I, self.first)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.IrreflexiveObjectProperty","title":"<code>IrreflexiveObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An irreflexive-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ IrreflexiveObjectProperty(HasParent) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n    irreflexive = True\n</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass IrreflexiveObjectProperty(Axiom):\n    \"\"\"\n    An irreflexive-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ IrreflexiveObjectProperty(HasParent) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n        irreflexive = True\n    ```\n\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        refl_s = instance_of_op(I, I, self.first)\n        if refl_s:\n            return Not(Exists([I], refl_s))\n        return None\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.FunctionalObjectProperty","title":"<code>FunctionalObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A functional-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasBiologicalMother(TopObjectProperty):\n    '''A property that relates a person to their biological mother'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ FunctionalObjectProperty(HasBiologicalMother) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasBiologicalMother(TopObjectProperty):\n    '''A property that relates a person to their biological mother'''\n    domain = Person\n    range = Person\n    functional = True\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- FunctionalObjectProperty\nFunctionalObjectProperty --&gt; \"1\" ObjectPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass FunctionalObjectProperty(Axiom):\n    \"\"\"\n    A functional-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n\n    class HasBiologicalMother(TopObjectProperty):\n        '''A property that relates a person to their biological mother'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ FunctionalObjectProperty(HasBiologicalMother) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasBiologicalMother(TopObjectProperty):\n        '''A property that relates a person to their biological mother'''\n        domain = Person\n        range = Person\n        functional = True\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- FunctionalObjectProperty\n    FunctionalObjectProperty --&gt; \"1\" ObjectPropertyExpression : first\n    ```\n\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J, K], Implies(And(instance_of_op(I, J, self.first), instance_of_op(I, K, self.first)), Term(\"eq\", J, K)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.InverseFunctionalObjectProperty","title":"<code>InverseFunctionalObjectProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An inverse-functional-object-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class BiologicalMotherOf(TopObjectProperty):\n    '''A property that relates a person to their biological mother'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ InverseFunctionalObjectProperty(BiologicalMotherOf) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class BiologicalMotherOf(TopObjectProperty):\n    '''A property that relates a person to their biological mother'''\n    domain = Person\n    range = Person\n    inverse_functional = True\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- InverseFunctionalObjectProperty\nInverseFunctionalObjectProperty --&gt; \"1\" ObjectPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass InverseFunctionalObjectProperty(Axiom):\n    \"\"\"\n    An inverse-functional-object-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class BiologicalMotherOf(TopObjectProperty):\n        '''A property that relates a person to their biological mother'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ InverseFunctionalObjectProperty(BiologicalMotherOf) ]\n\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class BiologicalMotherOf(TopObjectProperty):\n        '''A property that relates a person to their biological mother'''\n        domain = Person\n        range = Person\n        inverse_functional = True\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- InverseFunctionalObjectProperty\n    InverseFunctionalObjectProperty --&gt; \"1\" ObjectPropertyExpression : first\n    ```\n    \"\"\"\n\n    first: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J, K], Implies(And(instance_of_op(I, J, self.first), instance_of_op(K, J, self.first)), Term(\"eq\", I, K)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.FunctionalDataProperty","title":"<code>FunctionalDataProperty</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A functional-data-property axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    domain = Person\n    range = int\n\n__axioms__ = [ FunctionalDataProperty(HasAge) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    domain = Person\n    range = int\n    functional = True\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- FunctionalDataProperty\nFunctionalDataProperty --&gt; \"1\" DataPropertyExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass FunctionalDataProperty(Axiom):\n    \"\"\"\n    A functional-data-property axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        domain = Person\n        range = int\n\n    __axioms__ = [ FunctionalDataProperty(HasAge) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        domain = Person\n        range = int\n        functional = True\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- FunctionalDataProperty\n    FunctionalDataProperty --&gt; \"1\" DataPropertyExpression : first\n    ```\n\n    \"\"\"\n\n    first: DataPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J, K], Implies(And(instance_of_dp(I, J, self.first), instance_of_dp(I, K, self.first)), Term(\"eq\", J, K)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.SubDataPropertyOf","title":"<code>SubDataPropertyOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A sub-data-property-of axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a thing to their age'''\n    range = int\n\nclass PersonAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    domain = Person\n\n__axioms__ = [ SubDataPropertyOf(PersonAge, HasAge) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class PersonAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    domain = Person\n    range = int\n    subproperty_of = HasAge\n</code></pre> <p>When the parent is a named class, the more pythonic equivalent is preferred:</p> <pre><code>class PersonAge(HasAge):\n    '''A property that relates a person to their age'''\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- SubDataPropertyOf\nSubDataPropertyOf --&gt; \"*\" DataPropertyExpression : sub\nSubDataPropertyOf --&gt; \"*\" DataPropertyExpression : sup</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass SubDataPropertyOf(Axiom):\n    \"\"\"\n    A sub-data-property-of axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a thing to their age'''\n        range = int\n\n    class PersonAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        domain = Person\n\n    __axioms__ = [ SubDataPropertyOf(PersonAge, HasAge) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class PersonAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        domain = Person\n        range = int\n        subproperty_of = HasAge\n    ```\n\n    When the parent is a named class, the more pythonic equivalent is preferred:\n\n    ```python\n    class PersonAge(HasAge):\n        '''A property that relates a person to their age'''\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- SubDataPropertyOf\n    SubDataPropertyOf --&gt; \"*\" DataPropertyExpression : sub\n    SubDataPropertyOf --&gt; \"*\" DataPropertyExpression : sup\n    ```\n    \"\"\"\n\n    sub: DataPropertyExpression\n    sup: DataPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([P, I, J], Implies(instance_of_dp(I, J, self.sub), instance_of_dp(I, J, self.sup)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.EquivalentClasses","title":"<code>EquivalentClasses</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An equivalent-classes axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class Food(Thing):\n    pass\n\nclass Beverage(Thing):\n    pass\n\nclass MenuItem(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(MenuItem, ObjectUnionOf(Food, Beverage)) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class MenuItem(Thing):\n    equivalent_to = ObjectUnionOf(Food, Beverage)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- EquivalentClasses\nEquivalentClasses --&gt; \"*\" ClassExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass EquivalentClasses(Axiom):\n    \"\"\"\n    An equivalent-classes axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class Food(Thing):\n        pass\n\n    class Beverage(Thing):\n        pass\n\n    class MenuItem(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(MenuItem, ObjectUnionOf(Food, Beverage)) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class MenuItem(Thing):\n        equivalent_to = ObjectUnionOf(Food, Beverage)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- EquivalentClasses\n    EquivalentClasses --&gt; \"*\" ClassExpression : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[ClassExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: ClassExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        num_ops = len(self.operands)\n        sentences: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                sentences.append(Iff(instance_of(I, self.operands[i]), instance_of(I, self.operands[j])))\n        return Forall([I], _conjunction(sentences))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.EquivalentObjectProperties","title":"<code>EquivalentObjectProperties</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An equivalent-object-properties axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasChild(TopObjectProperty):\n    '''A property that relates a person to their child'''\n    domain = Person\n    range = Person\n\n__axioms__ = [ EquivalentObjectProperties(HasParent, ObjectInverseOf(HasChild)) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasChild(TopObjectProperty):\n    equivalent_to = ObjectInverseOf(HasParent)\n</code></pre> <p>In this particular case, a simpler more conventional way to declare the inverse is:</p> <pre><code>class HasChild(TopObjectProperty):\n    range = Person\n    domain = Person\n    inverse_of = HasParent\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- EquivalentObjectProperties\nEquivalentObjectProperties --&gt; \"*\" ObjectPropertyExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass EquivalentObjectProperties(Axiom):\n    \"\"\"\n    An equivalent-object-properties axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasChild(TopObjectProperty):\n        '''A property that relates a person to their child'''\n        domain = Person\n        range = Person\n\n    __axioms__ = [ EquivalentObjectProperties(HasParent, ObjectInverseOf(HasChild)) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasChild(TopObjectProperty):\n        equivalent_to = ObjectInverseOf(HasParent)\n    ```\n\n    In this particular case, a simpler more conventional way to declare the inverse is:\n\n    ```python\n    class HasChild(TopObjectProperty):\n        range = Person\n        domain = Person\n        inverse_of = HasParent\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- EquivalentObjectProperties\n    EquivalentObjectProperties --&gt; \"*\" ObjectPropertyExpression : operands\n    ```\n\n    \"\"\"\n\n    operands: Tuple[ObjectPropertyExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: ObjectPropertyExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        num_ops = len(self.operands)\n        sentences: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                sentences.append(Iff(instance_of_op(I, J, self.operands[i]), instance_of_op(I, J, self.operands[j])))\n        return Forall([I, J], _conjunction(sentences))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.EquivalentDataProperties","title":"<code>EquivalentDataProperties</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An equivalent-data-properties axiom.</p> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- EquivalentDataProperties\nEquivalentDataProperties --&gt; \"*\" DataPropertyExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass EquivalentDataProperties(Axiom):\n    \"\"\"\n    An equivalent-data-properties axiom.\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- EquivalentDataProperties\n    EquivalentDataProperties --&gt; \"*\" DataPropertyExpression : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[DataPropertyExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: DataPropertyExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        num_ops = len(self.operands)\n        sentences: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                sentences.append(Iff(instance_of_dp(I, J, self.operands[i]), instance_of_dp(I, J, self.operands[j])))\n        return Forall([I, J], _conjunction(sentences))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DisjointObjectProperties","title":"<code>DisjointObjectProperties</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A disjoint-object-properties axiom.</p> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- DisjointObjectProperties\nDisjointObjectProperties --&gt; \"*\" ObjectPropertyExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DisjointObjectProperties(Axiom):\n    \"\"\"\n    A disjoint-object-properties axiom.\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- DisjointObjectProperties\n    DisjointObjectProperties --&gt; \"*\" ObjectPropertyExpression : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[ObjectPropertyExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: ObjectPropertyExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        num_ops = len(self.operands)\n        sentences: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                sentences.append(Not(And(instance_of_op(I, J, self.operands[i]), instance_of_op(I, J, self.operands[j]))))\n        return Not(Exists([I, J], Or(*sentences)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DisjointDataProperties","title":"<code>DisjointDataProperties</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A disjoint-data-properties axiom.</p> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- DisjointDataProperties\nDisjointDataProperties --&gt; \"*\" DataPropertyExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DisjointDataProperties(Axiom):\n    \"\"\"\n    A disjoint-data-properties axiom.\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- DisjointDataProperties\n    DisjointDataProperties --&gt; \"*\" DataPropertyExpression : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[DataPropertyExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: DataPropertyExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        num_ops = len(self.operands)\n        sentences: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                sentences.append(Not(And(instance_of_dp(I, J, self.operands[i]), instance_of_dp(I, J, self.operands[j]))))\n        return Not(Exists([I, J], Or(*sentences)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DisjointClasses","title":"<code>DisjointClasses</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A disjoint-classes axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class Food(Thing):\n    pass\n\nclass Beverage(Thing):\n    pass\n\n__axioms__ = [ DisjointClasses(Food, Beverage) ]\n</code></pre> <p>Sometimes, the more Frame-style equivalent is preferred:</p> <pre><code>class Food(Thing):\n    pass\n\nclass Beverage(Thing):\n    disjoint_with = Food\n</code></pre> <p>However, the choice of which element of the tuple is the first class is arbitrary, so declaration of a top level axiom may be simpler (especially when more than two classes are members, or class expressions are involved).</p> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- DisjointClasses\nDisjointClasses --&gt; \"*\" ClassExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DisjointClasses(Axiom):\n    \"\"\"\n    A disjoint-classes axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class Food(Thing):\n        pass\n\n    class Beverage(Thing):\n        pass\n\n    __axioms__ = [ DisjointClasses(Food, Beverage) ]\n    ```\n\n    Sometimes, the more Frame-style equivalent is preferred:\n\n    ```python\n    class Food(Thing):\n        pass\n\n    class Beverage(Thing):\n        disjoint_with = Food\n    ```\n\n    However, the choice of which element of the tuple is the first class is arbitrary,\n    so declaration of a top level axiom may be simpler (especially when more than\n    two classes are members, or class expressions are involved).\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- DisjointClasses\n    DisjointClasses --&gt; \"*\" ClassExpression : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[ClassExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: ClassExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        num_ops = len(self.operands)\n        sentences: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                sentences.append(Not(And(instance_of(I, self.operands[i]), instance_of(I, self.operands[j]))))\n        return Not(Exists([I], Or(*sentences)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DisjointUnion","title":"<code>DisjointUnion</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A disjoint-union axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class Food(Thing):\n    pass\n\nclass Beverage(Thing):\n    pass\n\nclass MenuItem(Thing):\n    pass\n\n__axioms__ = [ DisjointUnion(MenuItem, Food, Beverage) ]\n</code></pre> <p>Sometimes, the more Frame-style equivalent is preferred:</p> <pre><code>class Food(Thing):\n    pass\n\nclass Beverage(Thing):\n    disjoint_union_of = MenuItem\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAxiom &lt;|-- DisjointUnion\nDisjointUnion --&gt; \"1\" ClassExpression : first\nDisjointUnion --&gt; \"*\" ClassExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DisjointUnion(Axiom):\n    \"\"\"\n    A disjoint-union axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class Food(Thing):\n        pass\n\n    class Beverage(Thing):\n        pass\n\n    class MenuItem(Thing):\n        pass\n\n    __axioms__ = [ DisjointUnion(MenuItem, Food, Beverage) ]\n    ```\n\n    Sometimes, the more Frame-style equivalent is preferred:\n\n    ```python\n    class Food(Thing):\n        pass\n\n    class Beverage(Thing):\n        disjoint_union_of = MenuItem\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- DisjointUnion\n    DisjointUnion --&gt; \"1\" ClassExpression : first\n    DisjointUnion --&gt; \"*\" ClassExpression : operands\n    ```\n    \"\"\"\n\n    first: Class\n    operands: Tuple[ClassExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, first: Class, *operands: ClassExpression):\n        self.first = first\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        eq = Forall([I], Iff(instance_of(I, self.first), Or(*[instance_of(I, op) for op in self.operands])))\n        num_ops = len(self.operands)\n        disj: List[Sentence] = []\n        for i in range(num_ops - 1):\n            for j in range(i + 1, num_ops):\n                disj.append(Not(And(instance_of(I, self.operands[i]), instance_of(I, self.operands[j]))))\n        return And(eq, Not(Exists([I], Or(*disj))))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.AnonymousClassExpression","title":"<code>AnonymousClassExpression</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An base class for anonymous class expressions.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass AnonymousClassExpression(ABC):\n    \"\"\"\n    An base class for anonymous class expressions.\n    \"\"\"\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        raise NotImplementedError(f\"{self} Must implement as_fol method\")\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.InverseObjectProperty","title":"<code>InverseObjectProperty</code>  <code>dataclass</code>","text":"<p>An inverse object property expression.</p>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.InverseObjectProperty--example","title":"Example:","text":"<pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n    range = Person\n\nclass HasChild(TopObjectProperty):\n    '''A property that relates a person to their child'''\n\n__axioms__ = [ EquivalentObjectProperties(HasParent, InverseObjectProperty(HasChild)) ]\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nInverseObjectProperty --&gt; \"1\" ObjectPropertyExpression : property</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass InverseObjectProperty:\n    \"\"\"\n    An inverse object property expression.\n\n    Example:\n    -------\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n        range = Person\n\n    class HasChild(TopObjectProperty):\n        '''A property that relates a person to their child'''\n\n    __axioms__ = [ EquivalentObjectProperties(HasParent, InverseObjectProperty(HasChild)) ]\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    InverseObjectProperty --&gt; \"1\" ObjectPropertyExpression : property\n    ```\n\n    \"\"\"\n\n    property: ObjectProperty\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        raise AssertionError(\"Not to be called directly\")\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectIntersectionOf","title":"<code>ObjectIntersectionOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression that is the intersection of a list of ClassExpressions.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Pizza(Thing):\n    pass\n\nclass Cheesy(Thing):\n    pass\n\nclass CheesyPizza(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(CheesyPizza, ObjectIntersectionOf(Pizza, Cheesy)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class CheesyPizza(Thing):\n    equivalent_to = ObjectIntersectionOf(Pizza, Cheesy)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectIntersectionOf\nObjectIntersectionOf --&gt; \"*\" ClassExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectIntersectionOf(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression that is the intersection of a list of ClassExpressions.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class Pizza(Thing):\n        pass\n\n    class Cheesy(Thing):\n        pass\n\n    class CheesyPizza(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(CheesyPizza, ObjectIntersectionOf(Pizza, Cheesy)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class CheesyPizza(Thing):\n        equivalent_to = ObjectIntersectionOf(Pizza, Cheesy)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectIntersectionOf\n    ObjectIntersectionOf --&gt; \"*\" ClassExpression : operands\n    ```\n\n    \"\"\"\n\n    operands: Tuple[ClassExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: ClassExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Sentence:\n        return And(*[instance_of(I, op) for op in self.operands])\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectUnionOf","title":"<code>ObjectUnionOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression that is the union of a list of ClassExpressions.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Pizza(Thing):\n    pass\n\nclass CheeseOnToast(Thing):\n    pass\n\nclass Pizzaesque(Thing)\n    pass\n\n__axioms__ = [ EquivalentClasses(Pizzaesque, ObjectUnionOf(Pizza, CheeseOnToast)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions</p> <pre><code>class Pizzaesque(Thing):\n    equivalent_to = ObjectUnionOf(Pizza, CheeseOnToast)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectUnionOf\nObjectUnionOf --&gt; \"*\" ClassExpression : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectUnionOf(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression that is the union of a list of ClassExpressions.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class Pizza(Thing):\n        pass\n\n    class CheeseOnToast(Thing):\n        pass\n\n    class Pizzaesque(Thing)\n        pass\n\n    __axioms__ = [ EquivalentClasses(Pizzaesque, ObjectUnionOf(Pizza, CheeseOnToast)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions\n\n    ```python\n    class Pizzaesque(Thing):\n        equivalent_to = ObjectUnionOf(Pizza, CheeseOnToast)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectUnionOf\n    ObjectUnionOf --&gt; \"*\" ClassExpression : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[ClassExpression, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: ClassExpression):\n        self.operands = operands\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Or(*[instance_of(I, op) for op in self.operands])\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectComplementOf","title":"<code>ObjectComplementOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression that is the complement of a ClassExpression.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Pizza(Thing):\n    pass\n\nclass MeatPizza(Thing):\n    pass\n\nclass VegetarianPizza(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(VegetarianPizza, ObjectIntersectionOf(Pizza, ObjectComplementOf(MeatPizza))) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions</p> <pre><code>class VegetarianPizza(Thing):\n    equivalent_to = ObjectIntersectionOf(Pizza, ObjectComplementOf(MeatPizza))\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectComplementOf\nObjectComplementOf --&gt; \"1\" ClassExpression : first</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectComplementOf(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression that is the complement of a ClassExpression.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class Pizza(Thing):\n        pass\n\n    class MeatPizza(Thing):\n        pass\n\n    class VegetarianPizza(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(VegetarianPizza, ObjectIntersectionOf(Pizza, ObjectComplementOf(MeatPizza))) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions\n\n    ```python\n    class VegetarianPizza(Thing):\n        equivalent_to = ObjectIntersectionOf(Pizza, ObjectComplementOf(MeatPizza))\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectComplementOf\n    ObjectComplementOf --&gt; \"1\" ClassExpression : first\n    ```\n    \"\"\"\n\n    first: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Not(instance_of(I, self.first))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectOneOf","title":"<code>ObjectOneOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression that is the set of individuals.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Unit(Thing):\n    pass\n\ninch = Unit(\"inch\")\ncm = Unit(\"cm\")\nm = Unit(\"m\")\n\nclass LengthUnit(Unit):\n    pass\n\n__axioms__ = [ EquivalentClasses(LengthUnit, ObjectOneOf(inch, cm, m)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions</p> <pre><code>class LengthUnit(Unit):\n    equivalent_to = ObjectOneOf(inch, cm, m)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectOneOf\nObjectOneOf --&gt; \"*\" Individual : operands</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectOneOf(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression that is the set of individuals.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class Unit(Thing):\n        pass\n\n    inch = Unit(\"inch\")\n    cm = Unit(\"cm\")\n    m = Unit(\"m\")\n\n    class LengthUnit(Unit):\n        pass\n\n    __axioms__ = [ EquivalentClasses(LengthUnit, ObjectOneOf(inch, cm, m)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions\n\n    ```python\n    class LengthUnit(Unit):\n        equivalent_to = ObjectOneOf(inch, cm, m)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectOneOf\n    ObjectOneOf --&gt; \"*\" Individual : operands\n    ```\n    \"\"\"\n\n    operands: Tuple[Individual, ...] = field(default_factory=tuple)\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Or(*[Term(\"eq\", I, ind) for ind in self.operands])\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectSomeValuesFrom","title":"<code>ObjectSomeValuesFrom</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing an existential restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class HasChil(TopObjectProperty):\n    '''A property that relates a person to their child'''\n    domain = Person\n    range = Person\n\nclass Parent(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(Parent, ObjectSomeValuesFrom(HasChild, Person)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class Parent(Thing):\n    equivalent_to = ObjectSomeValuesFrom(HasChild, Person)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectSomeValuesFrom\nObjectSomeValuesFrom --&gt; \"1\" ObjectPropertyExpression : ope\nObjectSomeValuesFrom --&gt; \"1\" ClassExpression : bce</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectSomeValuesFrom(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing an existential restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class HasChil(TopObjectProperty):\n        '''A property that relates a person to their child'''\n        domain = Person\n        range = Person\n\n    class Parent(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(Parent, ObjectSomeValuesFrom(HasChild, Person)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class Parent(Thing):\n        equivalent_to = ObjectSomeValuesFrom(HasChild, Person)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectSomeValuesFrom\n    ObjectSomeValuesFrom --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectSomeValuesFrom --&gt; \"1\" ClassExpression : bce\n    ```\n\n    \"\"\"\n\n    ope: ObjectPropertyExpression\n    bce: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Exists([J], And(instance_of_op(I, J, self.ope), instance_of(J, self.bce)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectAllValuesFrom","title":"<code>ObjectAllValuesFrom</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing a universal restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Pizza(Thing):\n    pass\n\nclass Eats(TopObjectProperty):\n    domain = Person\n    range = Thing\n\nclass Pizzavore(TopObjectProperty):\n    pass\n\n__axioms__ = [ EquivalentClasses(Pizzavore, ObjectAllValuesFrom(Eats, Pizza)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions</p> <pre><code>class Pizzavore(Thing):\n    equivalent_to = ObjectAllValuesFrom(Eats, Pizza)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectAllValuesFrom\nObjectAllValuesFrom --&gt; \"1\" ObjectPropertyExpression : ope\nObjectAllValuesFrom --&gt; \"1\" ClassExpression : bce</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectAllValuesFrom(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing a universal restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class Pizza(Thing):\n        pass\n\n    class Eats(TopObjectProperty):\n        domain = Person\n        range = Thing\n\n    class Pizzavore(TopObjectProperty):\n        pass\n\n    __axioms__ = [ EquivalentClasses(Pizzavore, ObjectAllValuesFrom(Eats, Pizza)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions\n\n    ```python\n    class Pizzavore(Thing):\n        equivalent_to = ObjectAllValuesFrom(Eats, Pizza)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectAllValuesFrom\n    ObjectAllValuesFrom --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectAllValuesFrom --&gt; \"1\" ClassExpression : bce\n    ```\n\n    \"\"\"\n\n    ope: ObjectPropertyExpression\n    bce: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([J], Implies(instance_of_op(I, J, self.ope), instance_of(J, self.bce)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectHasValue","title":"<code>ObjectHasValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing a value restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Topping(Thing):\n    pass\n\nclass Pizza(Thing):\n    pass\n\nclass ToppedWith(TopObjectProperty):\n    domain = Pizza\n    range = Topping\n\nclass MushroomPizza(Topping):\n    pass\n\n__axioms__ = [ EquivalentClasses(MushroomPizza, ObjectHasValue(ToppedWith, Topping(\"mushroom\")) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class MushroomPizza(Topping):\n    equivalent_to = ObjectHasValue(ToppedWith, Topping(\"mushroom\"))\n</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectHasValue(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing a value restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n\n    class Topping(Thing):\n        pass\n\n    class Pizza(Thing):\n        pass\n\n    class ToppedWith(TopObjectProperty):\n        domain = Pizza\n        range = Topping\n\n    class MushroomPizza(Topping):\n        pass\n\n    __axioms__ = [ EquivalentClasses(MushroomPizza, ObjectHasValue(ToppedWith, Topping(\"mushroom\")) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class MushroomPizza(Topping):\n        equivalent_to = ObjectHasValue(ToppedWith, Topping(\"mushroom\"))\n    ```\n\n    \"\"\"\n\n    ope: ObjectPropertyExpression\n    i: Individual\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Exists([J], And(instance_of_op(I, J, self.ope), Term(\"eq\", J, self.i)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectHasSelf","title":"<code>ObjectHasSelf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing a self restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class Person(Thing):\n    pass\n\nclass Loves(TopObjectProperty):\n    domain = Person\n    range = Thing\n\nclass Narcissist(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(Narcissist, ObjectHasSelf(Loves)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class Narcissist(Thing):\n    equivalent_to = ObjectHasSelf(Loves)\n</code></pre> <p>UML:</p> <p>```mermaid classDiagram AnonymousClassExpression &lt;|-- ObjectHasSelf ObjectHasSelf --&gt; \"1\" ObjectPropertyExpression :</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectHasSelf(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing a self restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class Person(Thing):\n        pass\n\n    class Loves(TopObjectProperty):\n        domain = Person\n        range = Thing\n\n    class Narcissist(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(Narcissist, ObjectHasSelf(Loves)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class Narcissist(Thing):\n        equivalent_to = ObjectHasSelf(Loves)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectHasSelf\n    ObjectHasSelf --&gt; \"1\" ObjectPropertyExpression :\n\n    \"\"\"\n\n    ope: ObjectPropertyExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return instance_of_op(I, I, self.ope)\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectMinCardinality","title":"<code>ObjectMinCardinality</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing a minimum cardinality restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class HasChild(TopObjectProperty):\n    '''A property that relates a person to their child'''\n    domain = Person\n    range = Person\n\nclass ParentOfTwoPlus(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(ParentOfTwoPlus, ObjectMinCardinality(2, HasChild, Person)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class ParentOfTwoPlus(Thing):\n    equivalent_to = ObjectMinCardinality(2, HasChild, Person)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectMinCardinality\nObjectMinCardinality --&gt; \"1\" int : n\nObjectMinCardinality --&gt; \"1\" ObjectPropertyExpression : ope\nObjectMinCardinality --&gt; \"1\" ClassExpression : bce</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectMinCardinality(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing a minimum cardinality restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class HasChild(TopObjectProperty):\n        '''A property that relates a person to their child'''\n        domain = Person\n        range = Person\n\n    class ParentOfTwoPlus(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(ParentOfTwoPlus, ObjectMinCardinality(2, HasChild, Person)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class ParentOfTwoPlus(Thing):\n        equivalent_to = ObjectMinCardinality(2, HasChild, Person)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectMinCardinality\n    ObjectMinCardinality --&gt; \"1\" int : n\n    ObjectMinCardinality --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectMinCardinality --&gt; \"1\" ClassExpression : bce\n    ```\n\n    \"\"\"\n\n    n: int\n    ope: ObjectPropertyExpression\n    bce: ClassExpression\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectMaxCardinality","title":"<code>ObjectMaxCardinality</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing a maximum cardinality restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class HasChild(TopObjectProperty):\n    '''A property that relates a person to their child'''\n    domain = Person\n    range = Person\n\nclass ParentOfOne(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(ParentOfOne, ObjectMinCardinality(0, HasChild, Person) &amp; ObjectMaxCardinality(1, HasChild, Person)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class ParentOfOne(Thing):\n    equivalent_to = ObjectMinCardinality(0, HasChild, Person) &amp; ObjectMaxCardinality(1, HasChild, Person)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectMaxCardinality\nObjectMaxCardinality --&gt; \"1\" int : n\nObjectMaxCardinality --&gt; \"1\" ObjectPropertyExpression : ope\nObjectMaxCardinality --&gt; \"1\" ClassExpression : bce</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectMaxCardinality(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing a maximum cardinality restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class HasChild(TopObjectProperty):\n        '''A property that relates a person to their child'''\n        domain = Person\n        range = Person\n\n    class ParentOfOne(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(ParentOfOne, ObjectMinCardinality(0, HasChild, Person) &amp; ObjectMaxCardinality(1, HasChild, Person)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class ParentOfOne(Thing):\n        equivalent_to = ObjectMinCardinality(0, HasChild, Person) &amp; ObjectMaxCardinality(1, HasChild, Person)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectMaxCardinality\n    ObjectMaxCardinality --&gt; \"1\" int : n\n    ObjectMaxCardinality --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectMaxCardinality --&gt; \"1\" ClassExpression : bce\n    ```\n\n    \"\"\"\n\n    n: int\n    ope: ObjectPropertyExpression\n    bce: ClassExpression\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectExactCardinality","title":"<code>ObjectExactCardinality</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousClassExpression</code></p> <p>A ClassExpression representing an exact cardinality restriction.</p> <p>Example of explicit axiom declaration:</p> <pre><code>class HasChild(TopObjectProperty):\n    '''A property that relates a person to their child'''\n    domain = Person\n    range = Person\n\nclass ParentOfOne(Thing):\n    pass\n\n__axioms__ = [ EquivalentClasses(ParentOfOne, ObjectExactCardinality(1, HasChild, Person)) ]\n</code></pre> <p>It is more idiomatic to declare axioms implicitly in Frame-style class definitions:</p> <pre><code>class ParentOfOne(Thing):\n    equivalent_to = ObjectExactCardinality(1, HasChild, Person)\n</code></pre> <p>UML:</p> <pre><code>classDiagram\nAnonymousClassExpression &lt;|-- ObjectExactCardinality\nObjectExactCardinality --&gt; \"1\" int : n\nObjectExactCardinality --&gt; \"1\" ObjectPropertyExpression : ope\nObjectExactCardinality --&gt; \"1\" ClassExpression : bce</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectExactCardinality(AnonymousClassExpression):\n    \"\"\"\n    A ClassExpression representing an exact cardinality restriction.\n\n    Example of explicit axiom declaration:\n\n    ```python\n    class HasChild(TopObjectProperty):\n        '''A property that relates a person to their child'''\n        domain = Person\n        range = Person\n\n    class ParentOfOne(Thing):\n        pass\n\n    __axioms__ = [ EquivalentClasses(ParentOfOne, ObjectExactCardinality(1, HasChild, Person)) ]\n    ```\n\n    It is more idiomatic to declare axioms implicitly in Frame-style class definitions:\n\n    ```python\n    class ParentOfOne(Thing):\n        equivalent_to = ObjectExactCardinality(1, HasChild, Person)\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    AnonymousClassExpression &lt;|-- ObjectExactCardinality\n    ObjectExactCardinality --&gt; \"1\" int : n\n    ObjectExactCardinality --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectExactCardinality --&gt; \"1\" ClassExpression : bce\n    ```\n\n    \"\"\"\n\n    n: int\n    ope: ObjectPropertyExpression\n    bce: ClassExpression\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.AnonymousDataRange","title":"<code>AnonymousDataRange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An base class for anonymous data ranges.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass AnonymousDataRange(ABC):\n    \"\"\"\n    An base class for anonymous data ranges.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DatatypeDefinition","title":"<code>DatatypeDefinition</code>  <code>dataclass</code>","text":"<p>A datatype definition.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DatatypeDefinition:\n    \"\"\"\n    A datatype definition.\n    \"\"\"\n\n    dt: Datatype\n    dr: DataRange\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataIntersectionOf","title":"<code>DataIntersectionOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousDataRange</code></p> <p>A DataRange that is the conjunction of DataRanges.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataIntersectionOf(AnonymousDataRange):\n    \"\"\"\n    A DataRange that is the conjunction of DataRanges.\n    \"\"\"\n\n    operands: Tuple[DataRange, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: DataRange):\n        self.operands = operands\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataUnionOf","title":"<code>DataUnionOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousDataRange</code></p> <p>A DataRange that is the disjunction of DataRanges.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataUnionOf(AnonymousDataRange):\n    \"\"\"\n    A DataRange that is the disjunction of DataRanges.\n    \"\"\"\n\n    operands: Tuple[DataRange, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: DataRange):\n        self.operands = operands\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataComplementOf","title":"<code>DataComplementOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousDataRange</code></p> <p>A DataRange that is the complement of a DataRange.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataComplementOf(AnonymousDataRange):\n    \"\"\"\n    A DataRange that is the complement of a DataRange.\n    \"\"\"\n\n    first: DataRange\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataOneOf","title":"<code>DataOneOf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousDataRange</code></p> <p>A DataRange that is the set of literals</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataOneOf(AnonymousDataRange):\n    \"\"\"\n    A DataRange that is the set of literals\n    \"\"\"\n\n    operands: Tuple[Literal, ...] = field(default_factory=tuple)\n\n    def __init__(self, *operands: Literal):\n        self.operands = operands\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataSomeValuesFrom","title":"<code>DataSomeValuesFrom</code>  <code>dataclass</code>","text":"<p>               Bases: <code>AnonymousDataRange</code></p> <p>A DataRange representing an existential restriction.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataSomeValuesFrom(AnonymousDataRange):\n    \"\"\"\n    A DataRange representing an existential restriction.\n    \"\"\"\n\n    dpe: DataPropertyExpression\n    dr: DataRange\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectPropertyDomain","title":"<code>ObjectPropertyDomain</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An object-property-domain axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n\nclass Person(Thing):\n    pass\n\n__axioms__ = [ ObjectPropertyDomain(HasParent, Person) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    domain = Person\n</code></pre> <p>UML:</p> <p><code>`mermaid classDiagram Axiom &lt;|-- ObjectPropertyDomain ObjectPropertyDomain --&gt; \"1\" ObjectPropertyExpression : ope ObjectPropertyDomain --&gt; \"1\" ClassExpression : ce</code></p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectPropertyDomain(Axiom):\n    \"\"\"\n    An object-property-domain axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n\n    class Person(Thing):\n        pass\n\n    __axioms__ = [ ObjectPropertyDomain(HasParent, Person) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        domain = Person\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- ObjectPropertyDomain\n    ObjectPropertyDomain --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectPropertyDomain --&gt; \"1\" ClassExpression : ce\n    ``\n    \"\"\"\n\n    ope: ObjectPropertyExpression\n    ce: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J], Implies(instance_of_op(I, J, self.ope), instance_of(I, self.ce)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataPropertyDomain","title":"<code>DataPropertyDomain</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A data-property-domain axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n\nclass Person(Thing):\n    pass\n\n__axioms__ = [ DataPropertyDomain(HasAge, int) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    domain = Person\n</code></pre> <p>UML:</p> <p><code>`mermaid classDiagram Axiom &lt;|-- DataPropertyDomain DataPropertyDomain --&gt; \"1\" DataPropertyExpression : dpe DataPropertyDomain --&gt; \"1\" ClassExpression : ce</code></p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataPropertyDomain(Axiom):\n    \"\"\"\n    A data-property-domain axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n\n    class Person(Thing):\n        pass\n\n    __axioms__ = [ DataPropertyDomain(HasAge, int) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        domain = Person\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- DataPropertyDomain\n    DataPropertyDomain --&gt; \"1\" DataPropertyExpression : dpe\n    DataPropertyDomain --&gt; \"1\" ClassExpression : ce\n    ``\n    \"\"\"\n\n    dpe: DataPropertyExpression\n    ce: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J], Implies(instance_of_dp(I, J, self.dpe), instance_of(I, self.ce)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.ObjectPropertyRange","title":"<code>ObjectPropertyRange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>An object-property-range axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n\nclass Person(Thing):\n    pass\n\n__axioms__ = [ ObjectPropertyRange(HasParent, Person) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasParent(TopObjectProperty):\n    '''A property that relates a person to their parent'''\n    range = Person\n</code></pre> <p>UML:</p> <p><code>`mermaid classDiagram Axiom &lt;|-- ObjectPropertyRange ObjectPropertyRange --&gt; \"1\" ObjectPropertyExpression : ope ObjectPropertyRange --&gt; \"1\" ClassExpression : ce</code></p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass ObjectPropertyRange(Axiom):\n    \"\"\"\n    An object-property-range axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n\n    class Person(Thing):\n        pass\n\n    __axioms__ = [ ObjectPropertyRange(HasParent, Person) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasParent(TopObjectProperty):\n        '''A property that relates a person to their parent'''\n        range = Person\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- ObjectPropertyRange\n    ObjectPropertyRange --&gt; \"1\" ObjectPropertyExpression : ope\n    ObjectPropertyRange --&gt; \"1\" ClassExpression : ce\n    ``\n    \"\"\"\n\n    ope: ObjectPropertyExpression\n    ce: ClassExpression\n\n    def as_fol(self) -&gt; Optional[Sentence]:\n        return Forall([I, J], Implies(instance_of_op(I, J, self.ope), instance_of(J, self.ce)))\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.DataPropertyRange","title":"<code>DataPropertyRange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Axiom</code></p> <p>A data-property-range axiom.</p> <p>Example of explicit declaration:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n\nclass Person(Thing):\n    pass\n\n__axioms__ = [ DataPropertyRange(HasAge, int) ]\n</code></pre> <p>Normally, the more Frame-style equivalent is preferred:</p> <pre><code>class HasAge(TopDataProperty):\n    '''A property that relates a person to their age'''\n    range = int\n</code></pre> <p>UML:</p> <p><code>`mermaid classDiagram Axiom &lt;|-- DataPropertyRange DataPropertyRange --&gt; \"1\" DataPropertyExpression : dpe DataPropertyRange --&gt; \"1\" DataRange : dr</code></p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass\nclass DataPropertyRange(Axiom):\n    \"\"\"\n    A data-property-range axiom.\n\n    Example of explicit declaration:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n\n    class Person(Thing):\n        pass\n\n    __axioms__ = [ DataPropertyRange(HasAge, int) ]\n    ```\n\n    Normally, the more Frame-style equivalent is preferred:\n\n    ```python\n    class HasAge(TopDataProperty):\n        '''A property that relates a person to their age'''\n        range = int\n    ```\n\n    UML:\n\n    ```mermaid\n    classDiagram\n    Axiom &lt;|-- DataPropertyRange\n    DataPropertyRange --&gt; \"1\" DataPropertyExpression : dpe\n    DataPropertyRange --&gt; \"1\" DataRange : dr\n    ``\n    \"\"\"\n\n    dpe: DataPropertyExpression\n    dr: DataRange\n</code></pre>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.Ontology","title":"<code>Ontology</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Fact</code></p> <p>An ontology.</p> <p>Note that an explicit declaration of an ontology is optional, as an ontology is inferred to be present in any python modules that contain declarations.</p>"},{"location":"integrations/frameworks/owldl/owltop/#typedlogic.integrations.frameworks.owldl.owltop.Ontology--example","title":"Example:","text":"<pre><code>class Animal(Thing):\n    pass\n\nclass Cat(Animal):\n    pass\n\nclass MyOntology(Ontology):\n    iri = \"http://example.org/ontology\"\n    axioms = [SubClassOf(Cat, Animal)]\n</code></pre> Source code in <code>src/typedlogic/integrations/frameworks/owldl/owltop.py</code> <pre><code>@dataclass(frozen=True)\nclass Ontology(Fact):\n    \"\"\"\n    An ontology.\n\n    Note that an explicit declaration of an ontology is optional, as an ontology\n    is inferred to be present in any python modules that contain declarations.\n\n    Example:\n    -------\n    ```python\n    class Animal(Thing):\n        pass\n\n    class Cat(Animal):\n        pass\n\n    class MyOntology(Ontology):\n        iri = \"http://example.org/ontology\"\n        axioms = [SubClassOf(Cat, Animal)]\n    ```\n\n    \"\"\"\n\n    axioms: ClassVar[Optional[List[\"Axiom\"]]] = None\n\n    @classmethod\n    def to_sentences(cls) -&gt; List[Sentence]:\n        return [a for a in [axiom.as_fol() for axiom in cls.axioms or []] if a is not None]\n</code></pre>"},{"location":"integrations/frameworks/owldl/reasoner/","title":"OWL Reasoner","text":""},{"location":"integrations/frameworks/owldl/reasoner/#typedlogic.integrations.frameworks.owldl.reasoner.OWLReasoner","title":"<code>OWLReasoner</code>  <code>dataclass</code>","text":"<p>A reasoner for OWL-DL ontologies</p> <p>The reasoner is initialized with a theory, which can be loaded from a file or built up programmatically.</p> <p>Let's start with a simple data model. Note our data model must be heavily normalized to be visible to OWL-DL. All individuals are represented as subclasses of Thing. These can't (yet) have properties of their own, these must be represented as separate relationships, which are subclasses of TopObjectProperty.</p> <p>Our model will have a class for representing people, and a relationship for representing who knows who.</p> <pre><code>&gt;&gt;&gt; class Person(Thing):\n...     pass\n&gt;&gt;&gt; class Knows(TopObjectProperty):\n...     domain = Person\n...     range = Person\n...     symmetric = True\n</code></pre> <p>We can now create an OWL reasoner:</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.owldl.reasoner import OWLReasoner\n&gt;&gt;&gt; r = OWLReasoner()\n&gt;&gt;&gt; r.init_axioms()\n</code></pre> <p>And add some facts. These are standard python objects:</p> <pre><code>&gt;&gt;&gt; r.add(Knows(\"p1\", \"p2\"))\n</code></pre> <p>We can now reason with the model:</p> <pre><code>&gt;&gt;&gt; assert r.coherent()\n&gt;&gt;&gt; model = r.model()\n&gt;&gt;&gt; for fact in model.iter_retrieve(\"knows\"):\n...     print(fact)\nknows(p1, p2)\nknows(p2, p1)\n</code></pre> <p>Note that because we declared the relationship as symmetric, the reasoner inferred the reverse relationship.</p> <p>By default, the reasoner uses the Clingo solver. This can be changed by setting the <code>solver_class</code> attribute.</p> Source code in <code>src/typedlogic/integrations/frameworks/owldl/reasoner.py</code> <pre><code>@dataclass\nclass OWLReasoner:\n    \"\"\"\n    A reasoner for OWL-DL ontologies\n\n    The reasoner is initialized with a theory, which can be loaded from a file or built up programmatically.\n\n    Let's start with a simple data model. Note our data model must be heavily *normalized* to be visible\n    to OWL-DL. All individuals are represented as subclasses of Thing. These can't (yet) have properties\n    of their own, these must be represented as separate relationships, which are subclasses of TopObjectProperty.\n\n    Our model will have a class for representing people, and a relationship for representing who knows who.\n\n        &gt;&gt;&gt; class Person(Thing):\n        ...     pass\n        &gt;&gt;&gt; class Knows(TopObjectProperty):\n        ...     domain = Person\n        ...     range = Person\n        ...     symmetric = True\n\n    We can now create an OWL reasoner:\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.owldl.reasoner import OWLReasoner\n        &gt;&gt;&gt; r = OWLReasoner()\n        &gt;&gt;&gt; r.init_axioms()\n\n    And add some facts. These are standard python objects:\n\n        &gt;&gt;&gt; r.add(Knows(\"p1\", \"p2\"))\n\n    We can now reason with the model:\n\n        &gt;&gt;&gt; assert r.coherent()\n        &gt;&gt;&gt; model = r.model()\n        &gt;&gt;&gt; for fact in model.iter_retrieve(\"knows\"):\n        ...     print(fact)\n        knows(p1, p2)\n        knows(p2, p1)\n\n    Note that because we declared the relationship as symmetric, the reasoner inferred the reverse relationship.\n\n    By default, the reasoner uses the Clingo solver. This can be changed by setting the `solver_class` attribute.\n\n    \"\"\"\n\n    solver_class: Type[Solver] = ClingoSolver\n    theory: Optional[Theory] = None\n    solver: Optional[Solver] = None\n\n    def set_solver_class(self, solver_class: Type[Solver]):\n        self.solver_class = solver_class\n        self.solver = None\n\n    def init_from_file(self, source: Union[str, Path]):\n        p = PythonParser()\n        f = open(source)\n        self.theory = p.parse(f)\n        python_txt = open(source).read()\n        module = compile_python(python_txt, name=None, package_path=str(source))\n        # module = importlib.import_module(str(source))\n        self.theory.source_module_name = module.__name__\n        # TODO: ensure loaded\n        self._axioms_from_classes()\n\n    def init_axioms(self):\n        self.theory = Theory()\n        pp = PythonParser()\n        import typedlogic.integrations.frameworks.owldl.owltop as owltop\n        self.theory = pp.parse(Path(owltop.__file__))\n        # Do not restrict to imports closure\n        self.theory.source_module_name = None\n        self._axioms_from_classes()\n\n\n    def _axioms_from_classes(self):\n\n        # find all subclasses of Thing\n        class_classes = get_all_subclasses(Thing)\n        op_classes = get_all_subclasses(TopObjectProperty)\n        dp_classes = get_all_subclasses(TopDataProperty)\n        ont_classes = get_all_subclasses(Ontology)\n        all_classes = class_classes.union(op_classes).union(dp_classes).union(ont_classes)\n        source_module_name = self.theory.source_module_name\n        if source_module_name:\n            import_closure = compute_import_closure(source_module_name)\n            all_classes = [c for c in all_classes if c.__module__ in import_closure]\n        for cls in all_classes:\n            sentences = cls.to_sentences()\n            for s in sentences:\n                self.theory.add(s)\n\n        for cls in all_classes:\n            # Get the module where the class is defined\n            module = inspect.getmodule(cls)\n\n            if module:\n                module_name = module.__name__\n\n                # Check if __axioms__ is defined in the module\n                if hasattr(module, '__axioms__'):\n                    axioms = module.__axioms__\n                    if not isinstance(axioms, list):\n                        axioms = [axioms]\n                    for axiom in axioms:\n                        fol = axiom.as_fol()\n                        if fol:\n                            self.theory.add(fol)\n\n    def add(self, sentence: Union[Sentence, List[Sentence]]):\n        \"\"\"\n        Add a sentence to the reasoner\n\n        :param sentence:\n        :return:\n        \"\"\"\n        self.solver = None  # solver's state is invalidated\n        if isinstance(sentence, list):\n            for s in sentence:\n                if s is None:\n                    raise ValueError(f\"Got empty sentence in {sentence}\")\n                self.add(s)\n            return\n        if self.theory is None:\n            self.theory = Theory()\n        self.theory.add(sentence)\n\n    def register(self, cls: Type):\n        \"\"\"\n        Register a python class with the reasoner\n\n        :param cls:\n        :return:\n        \"\"\"\n        if not self.theory:\n            self.theory = Theory()\n        pd_map = {pd.predicate: pd for pd in self.theory.predicate_definitions or []}\n        pd = None\n        for mc in [Thing, TopObjectProperty, TopDataProperty]:\n            if issubclass(cls, mc):\n                pd = PredicateDefinition(cls.__name__,\n                                         pd_map[mc.__name__].arguments)\n        if not pd:\n            raise ValueError(f\"Class {cls} is not a recognized OWL-DL class\")\n        self.theory.predicate_definitions.append(pd)\n        sentences = cls.to_sentences()\n        for s in sentences:\n            self.add(s)\n\n    def remove(self, sentence: Union[Sentence, List[Sentence]]):\n        self.solver = None  # solver's state is invalidated\n        if isinstance(sentence, list):\n            for s in sentence:\n                self.remove(s)\n            return\n        if self.theory is None:\n            raise ValueError(\"No theory to remove from\")\n        self.theory.remove(sentence)\n\n    def reason(self) -&gt; None:\n        self.solver = self.solver_class()\n        if not self.theory:\n            raise ValueError(\"No theory to reason with\")\n        self.solver.add_theory(self.theory)\n\n    def model(self) -&gt; Model:\n        if not self.solver:\n            self.reason()\n        if not self.solver:\n            raise ValueError(\"No solver to reason with\")\n        solver = self.solver\n        return solver.model()\n\n    def model_iter(self) -&gt; Iterator[Model]:\n        if not self.solver:\n            self.reason()\n        if not self.solver:\n            raise ValueError(\"No solver to reason with\")\n        solver = self.solver\n        yield from solver.models()\n\n    def coherent(self) -&gt; bool:\n        if not self.solver:\n            self.reason()\n        if not self.solver:\n            raise ValueError(\"No solver to reason with\")\n        solver = self.solver\n        return solver.check().satisfiable is not False\n</code></pre>"},{"location":"integrations/frameworks/owldl/reasoner/#typedlogic.integrations.frameworks.owldl.reasoner.OWLReasoner.add","title":"<code>add(sentence)</code>","text":"<p>Add a sentence to the reasoner</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Union[Sentence, List[Sentence]]</code> required <p>Returns:</p> Type Description Source code in <code>src/typedlogic/integrations/frameworks/owldl/reasoner.py</code> <pre><code>def add(self, sentence: Union[Sentence, List[Sentence]]):\n    \"\"\"\n    Add a sentence to the reasoner\n\n    :param sentence:\n    :return:\n    \"\"\"\n    self.solver = None  # solver's state is invalidated\n    if isinstance(sentence, list):\n        for s in sentence:\n            if s is None:\n                raise ValueError(f\"Got empty sentence in {sentence}\")\n            self.add(s)\n        return\n    if self.theory is None:\n        self.theory = Theory()\n    self.theory.add(sentence)\n</code></pre>"},{"location":"integrations/frameworks/owldl/reasoner/#typedlogic.integrations.frameworks.owldl.reasoner.OWLReasoner.register","title":"<code>register(cls)</code>","text":"<p>Register a python class with the reasoner</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type</code> required <p>Returns:</p> Type Description Source code in <code>src/typedlogic/integrations/frameworks/owldl/reasoner.py</code> <pre><code>def register(self, cls: Type):\n    \"\"\"\n    Register a python class with the reasoner\n\n    :param cls:\n    :return:\n    \"\"\"\n    if not self.theory:\n        self.theory = Theory()\n    pd_map = {pd.predicate: pd for pd in self.theory.predicate_definitions or []}\n    pd = None\n    for mc in [Thing, TopObjectProperty, TopDataProperty]:\n        if issubclass(cls, mc):\n            pd = PredicateDefinition(cls.__name__,\n                                     pd_map[mc.__name__].arguments)\n    if not pd:\n        raise ValueError(f\"Class {cls} is not a recognized OWL-DL class\")\n    self.theory.predicate_definitions.append(pd)\n    sentences = cls.to_sentences()\n    for s in sentences:\n        self.add(s)\n</code></pre>"},{"location":"integrations/solvers/","title":"Solvers","text":"<p>               Bases: <code>ABC</code></p> <p>A solver is a class that can check a set of axioms for consistency, satisfiability, or some other property.</p> <p>This is an abstract class that defines the interface for a solver.</p> <p>You can retrieve a specific solver with the <code>get_solver</code> function:</p> <pre><code>&gt;&gt;&gt; from typedlogic.registry import get_solver\n&gt;&gt;&gt; solver = get_solver(\"clingo\")\n</code></pre> <p>Once you has a solver, you can can add theories, or individual sentences to it:</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n&gt;&gt;&gt; from typedlogic import Term, Variable\n&gt;&gt;&gt; x = Variable(\"x\")\n&gt;&gt;&gt; y = Variable(\"y\")\n&gt;&gt;&gt; z = Variable(\"z\")\n&gt;&gt;&gt; solver.add( (Term(\"AncestorOf\", x, z) &amp; Term(\"AncestorOf\", z, y)) &gt;&gt; Term(\"AncestorOf\", x, y))\n</code></pre> <p>And facts:</p> <pre><code>&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n&gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n&gt;&gt;&gt; solver.add_sentence_group(aa)\n</code></pre> <p>The <code>check</code> method ensures the theory and ground terms (data) are consistent:</p> <pre><code>&gt;&gt;&gt; soln = solver.check()\n&gt;&gt;&gt; soln.satisfiable\nTrue\n</code></pre> <p>You can then query for models:</p> <pre><code>&gt;&gt;&gt; model = solver.model()\n&gt;&gt;&gt; for t in model.ground_terms:\n...     print(t)\nAncestorOf(p1, p1a)\nAncestorOf(p1a, p1aa)\nAncestorOf(p1, p1aa)\n</code></pre> Source code in <code>src/typedlogic/solver.py</code> <pre><code>@dataclass\nclass Solver(ABC):\n    \"\"\"\n    A solver is a class that can check a set of axioms for consistency, satisfiability, or some other property.\n\n    This is an abstract class that defines the interface for a solver.\n\n    You can retrieve a specific solver with the `get_solver` function:\n\n        &gt;&gt;&gt; from typedlogic.registry import get_solver\n        &gt;&gt;&gt; solver = get_solver(\"clingo\")\n\n    Once you has a solver, you can can add theories, or individual sentences to it:\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n        &gt;&gt;&gt; from typedlogic import Term, Variable\n        &gt;&gt;&gt; x = Variable(\"x\")\n        &gt;&gt;&gt; y = Variable(\"y\")\n        &gt;&gt;&gt; z = Variable(\"z\")\n        &gt;&gt;&gt; solver.add( (Term(\"AncestorOf\", x, z) &amp; Term(\"AncestorOf\", z, y)) &gt;&gt; Term(\"AncestorOf\", x, y))\n\n    And facts:\n\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n        &gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n        &gt;&gt;&gt; solver.add_sentence_group(aa)\n\n    The `check` method ensures the theory and ground terms (data) are consistent:\n\n        &gt;&gt;&gt; soln = solver.check()\n        &gt;&gt;&gt; soln.satisfiable\n        True\n\n    You can then query for models:\n\n        &gt;&gt;&gt; model = solver.model()\n        &gt;&gt;&gt; for t in model.ground_terms:\n        ...     print(t)\n        AncestorOf(p1, p1a)\n        AncestorOf(p1a, p1aa)\n        AncestorOf(p1, p1aa)\n\n    \"\"\"\n    strict: bool = False\n    method_name: Optional[str] = None\n    methods_supported: ClassVar[Optional[List[Method]]] = None\n    profile: ClassVar[Profile] = UnspecifiedProfile()\n    assume_closed_world: bool = False\n\n    # TODO: move towards this\n    base_theory: Theory = field(default_factory=Theory)\n\n    predicate_definitions: Optional[Dict[str, PredicateDefinition]] = None\n    type_definitions: Dict[str, str] = field(default_factory=dict)\n    constants: Dict[str, Any] = field(default_factory=dict)\n    goals: Optional[List[SentenceGroup]] = None\n\n    @property\n    def method(self) -&gt; Method:\n        if self.methods_supported is None:\n            raise NotImplementedError(\"Solver must define methods_supported\")\n        for m in self.methods_supported:\n            if self.method_name is None and m.is_default:\n                return m\n            if m.name == self.method_name:\n                return m\n        raise ValueError(f\"Method {self.method_name} not supported\")\n\n    @abstractmethod\n    def check(self) -&gt; Solution:\n        pass\n\n    def model(self) -&gt; Model:\n        return next(self.models())\n\n    @abstractmethod\n    def models(self) -&gt; Iterator[Model]:\n        pass\n\n    def prove_goals(self, strict=True) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        if not self.check().satisfiable:\n            raise ValueError(\"Cannot prove goals for unsatisfiable theory\")\n        if not self.goals:\n            raise ValueError(\"No goals to prove\")\n        for goal_group in self.goals:\n            if not goal_group.sentences:\n                raise ValueError(f\"Goal group {goal_group.name} has no sentences\")\n            for sentence in goal_group.sentences:\n                provable = self.prove(sentence)\n                if not provable and strict:\n                    raise ValueError(f\"Goal {sentence} not provable\")\n                yield sentence, provable\n\n    def prove_multiple(self, sentences: List[Sentence]) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        if self.check().satisfiable is False:\n            raise ValueError(\"Cannot prove goals for unsatisfiable theory\")\n        if not sentences:\n            raise ValueError(\"No goals to prove\")\n        for sentence in sentences:\n            provable = self.prove(sentence)\n            yield sentence, provable\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        \"\"\"\n        Prove a sentence.\n\n        :param sentence:\n        :return:\n        \"\"\"\n        if isinstance(sentence, Term):\n            # Note: the default implementation may be highly ineffecient.\n            # it is recommended to override this method in a subclass.\n            has_vars = sentence.variables\n            cls = type(self)\n            new_solver = cls()\n            new_solver.add(self.base_theory)\n            model = self.model()\n            for t in model.iter_retrieve(sentence.predicate):\n                if t == sentence:\n                    return True\n                if has_vars:\n                    if t.predicate == sentence.predicate:\n                        is_match = True\n                        for i in range(len(sentence.values)):\n                            arg_val = sentence.values[i]\n                            if isinstance(arg_val, Variable):\n                                # auto-match (assume existential over whole domain)\n                                continue\n                            if arg_val != t.values[i]:\n                                is_match = False\n                                break\n                        if is_match:\n                            return True\n            return False\n        if isinstance(sentence, Exists):\n            inner = sentence.sentence\n            if isinstance(inner, Term):\n                return self.prove(inner)\n        return None\n\n    def load(self, source: Union[str, Path, TextIO, ModuleType]) -&gt; None:\n        \"\"\"\n        Load a theory from a file.\n\n        :param source:\n        :return:\n        \"\"\"\n        parser = PythonParser()\n        if isinstance(source, ModuleType):\n            theory = parser.transform(source)\n        else:\n            theory = parser.parse(source)\n        self.add(theory)\n\n\n    def add(self, element: Union[ELEMENT, Iterable[ELEMENT]]) -&gt; None:\n        if isinstance(element, (list, abc.Iterator)):\n            for e in element:\n                self.add(e)\n            return\n        if isinstance(element, FactMixin):\n            self.add_fact(element)\n        elif isinstance(element, SentenceGroup):\n            self.add_sentence_group(element)\n        elif isinstance(element, Theory):\n            self.add_theory(element)\n        elif isinstance(element, PredicateDefinition):\n            self.add_predicate_definition(element)\n        elif isinstance(element, Sentence):\n            self.add_sentence(element)\n        else:\n            raise ValueError(f\"Unsupported axiom type: {type(element)}\")\n\n    def add_fact(self, fact: FactMixin):\n        self.base_theory.ground_terms.append(fact_to_term(fact))\n\n    def add_sentence_group(self, sentence_group: SentenceGroup) -&gt; None:\n        self.base_theory.sentence_groups.append(sentence_group)\n        if sentence_group.group_type == SentenceGroupType.GOAL:\n            if not self.goals:\n                self.goals = []\n            self.goals.append(sentence_group)\n        if sentence_group.sentences:\n            for sentence in sentence_group.sentences:\n                self.add_sentence(sentence)\n\n    def add_sentence(self, sentence: Sentence) -&gt; None:\n        if sentence not in self.base_theory.sentences:\n            self.base_theory.sentence_groups.append(SentenceGroup(name=\"dynamic\",\n                                                                  sentences=[sentence]))\n\n    def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n        \"\"\"\n        Add a predicate definition to the solver.\n\n        Some solvers do not need predicate definitions (for example, classic prolog systems, as well\n        as pure FOL solvers). However, many solvers need some kind of typing information.\n\n        :param predicate_definition:\n        :return:\n        \"\"\"\n        self.base_theory.predicate_definitions.append(predicate_definition)\n\n    def add_theory(self, theory: Theory) -&gt; None:\n        if theory.constants:\n            for k, v in theory.constants.items():\n                self.constants[k] = v\n                self.base_theory.constants[k] = v\n        if theory.type_definitions:\n            for k, v in theory.type_definitions.items():\n                self.type_definitions[k] = v\n                self.base_theory.type_definitions[k] = v\n        if theory.predicate_definitions:\n            for p in theory.predicate_definitions:\n                self.add_predicate_definition(p)\n        if theory.sentence_groups:\n            for aa in theory.sentence_groups:\n                self.add_sentence_group(aa)\n        if theory.ground_terms:\n            for t in theory.ground_terms:\n                self.add(t)\n\n\n    def dump(self) -&gt; str:\n        \"\"\"\n        Dump the internal state of the solver as a string.\n\n        :return:\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"integrations/solvers/#typedlogic.solver.Solver.prove","title":"<code>prove(sentence)</code>","text":"<p>Prove a sentence.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> required <p>Returns:</p> Type Description <code>Optional[bool]</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n    \"\"\"\n    Prove a sentence.\n\n    :param sentence:\n    :return:\n    \"\"\"\n    if isinstance(sentence, Term):\n        # Note: the default implementation may be highly ineffecient.\n        # it is recommended to override this method in a subclass.\n        has_vars = sentence.variables\n        cls = type(self)\n        new_solver = cls()\n        new_solver.add(self.base_theory)\n        model = self.model()\n        for t in model.iter_retrieve(sentence.predicate):\n            if t == sentence:\n                return True\n            if has_vars:\n                if t.predicate == sentence.predicate:\n                    is_match = True\n                    for i in range(len(sentence.values)):\n                        arg_val = sentence.values[i]\n                        if isinstance(arg_val, Variable):\n                            # auto-match (assume existential over whole domain)\n                            continue\n                        if arg_val != t.values[i]:\n                            is_match = False\n                            break\n                    if is_match:\n                        return True\n        return False\n    if isinstance(sentence, Exists):\n        inner = sentence.sentence\n        if isinstance(inner, Term):\n            return self.prove(inner)\n    return None\n</code></pre>"},{"location":"integrations/solvers/#typedlogic.solver.Solver.load","title":"<code>load(source)</code>","text":"<p>Load a theory from a file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path, TextIO, ModuleType]</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def load(self, source: Union[str, Path, TextIO, ModuleType]) -&gt; None:\n    \"\"\"\n    Load a theory from a file.\n\n    :param source:\n    :return:\n    \"\"\"\n    parser = PythonParser()\n    if isinstance(source, ModuleType):\n        theory = parser.transform(source)\n    else:\n        theory = parser.parse(source)\n    self.add(theory)\n</code></pre>"},{"location":"integrations/solvers/#typedlogic.solver.Solver.add_predicate_definition","title":"<code>add_predicate_definition(predicate_definition)</code>","text":"<p>Add a predicate definition to the solver.</p> <p>Some solvers do not need predicate definitions (for example, classic prolog systems, as well as pure FOL solvers). However, many solvers need some kind of typing information.</p> <p>Parameters:</p> Name Type Description Default <code>predicate_definition</code> <code>PredicateDefinition</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n    \"\"\"\n    Add a predicate definition to the solver.\n\n    Some solvers do not need predicate definitions (for example, classic prolog systems, as well\n    as pure FOL solvers). However, many solvers need some kind of typing information.\n\n    :param predicate_definition:\n    :return:\n    \"\"\"\n    self.base_theory.predicate_definitions.append(predicate_definition)\n</code></pre>"},{"location":"integrations/solvers/#typedlogic.solver.Solver.dump","title":"<code>dump()</code>","text":"<p>Dump the internal state of the solver as a string.</p> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/typedlogic/solver.py</code> <pre><code>def dump(self) -&gt; str:\n    \"\"\"\n    Dump the internal state of the solver as a string.\n\n    :return:\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"integrations/solvers/clingo/","title":"Clingo Integrations","text":"<p>               Bases: <code>Solver</code></p> <p>A solver that uses clingo.</p> <p>clingo is an ASP system to ground and solve logic programs, it is part of the Potsdam Answer Set Solving Collection (Potassco; potassco.org/).</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n &gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n&gt;&gt;&gt; solver = ClingoSolver()\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n\n&gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n&gt;&gt;&gt; solver.add_sentence_group(aa)\n&gt;&gt;&gt; soln = solver.check()\n</code></pre> <p>This solver does not implement the open-world assumption.</p> <pre><code>&gt;&gt;&gt; from typedlogic.profiles import OpenWorld\n&gt;&gt;&gt; solver.profile.impl(OpenWorld)\nFalse\n</code></pre> Source code in <code>src/typedlogic/integrations/solvers/clingo/clingo_solver.py</code> <pre><code>@dataclass\nclass ClingoSolver(Solver):\n    \"\"\"\n    A solver that uses clingo.\n\n    [clingo](https://potassco.org/clingo/) is an ASP system to ground and solve logic programs, it is\n    part of the Potsdam Answer Set Solving Collection (Potassco; [potassco.org/](https://potassco.org/)).\n\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n         &gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n        &gt;&gt;&gt; solver = ClingoSolver()\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n\n        &gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n        &gt;&gt;&gt; solver.add_sentence_group(aa)\n        &gt;&gt;&gt; soln = solver.check()\n\n    This solver does not implement the open-world assumption.\n\n        &gt;&gt;&gt; from typedlogic.profiles import OpenWorld\n        &gt;&gt;&gt; solver.profile.impl(OpenWorld)\n        False\n\n    \"\"\"\n\n    exec_name: str = field(default=\"clingo\")\n    profile: ClassVar[Profile] = MixedProfile(AnswerSetProgramming(), AllowsComparisonTerms(), MultipleModelSemantics())\n    ctl : Optional[Control] = None\n\n\n    def _clauses(self) -&gt; Iterator[str]:\n        negation_symbol = \"not\" if self.assume_closed_world else \"-\"\n        prolog_config = PrologConfig(disjunctive_datalog=True, double_quote_strings=True, negation_symbol=negation_symbol, allow_nesting=False)\n        for sentence in self.base_theory.sentences + self.base_theory.ground_terms:\n            if not isinstance(sentence, Sentence):\n                raise ValueError(f\"Expected Sentence, got {sentence}\")\n            rules = []\n            try:\n                for rule in to_horn_rules(sentence, allow_disjunctions_in_head=True, allow_goal_clauses=True):\n                    rules.append(rule)\n                    # yield as_prolog(rule, config=prolog_config)\n            except NotInProfileError as e:\n                logger.info(f\"Skipping sentence {sentence} due to {e}\")\n            for rule in rules:\n                try:\n                    yield as_prolog(rule, config=prolog_config)\n                except NotInProfileError as e:\n                    logger.info(f\"Skipping sentence {sentence} due to {e}\")\n\n\n\n    def models(self) -&gt; Iterator[Model]:\n        ctl = Control([\"0\"])\n        predicate_name_map = {pd.predicate.lower(): pd.predicate for pd in self.base_theory.predicate_definitions}\n        for clause in self._clauses():\n            ctl.add(clause)\n\n        # Ground the program\n        ctl.ground([(\"base\", [])])\n        # Solve the program\n        with ctl.solve(yield_=True) as handle:\n            for clingo_model in handle:\n                facts = []\n                for atom in clingo_model.symbols(shown=True):\n                    p = predicate_name_map.get(atom.name, atom.name)\n                    def _v(sym: clingo.Symbol) -&gt; Any:\n                        if sym.type == SymbolType.String:\n                            return str(sym.string)\n                        if sym.type == SymbolType.Number:\n                            return sym.number\n                        return sym\n                    term = Term(p, *[_v(a) for a in atom.arguments])\n                    if not atom.positive:\n                        term = ~term\n                    facts.append(term)\n\n                model = Model(ground_terms=facts)\n                yield model\n\n    def check(self) -&gt; Solution:\n        models = list(self.models())\n        sat = len(models) &gt; 0\n        return Solution(satisfiable=sat)\n\n    def dump(self) -&gt; str:\n        s = \"\"\n        for clause in self._clauses():\n            s += f\"{clause}\\n\"\n        return s\n</code></pre>"},{"location":"integrations/solvers/llm/","title":"LLM Integrations","text":"<p>               Bases: <code>Solver</code></p> <p>A solver that uses an LLM.</p> <p>This is for research purposes only. LLM output can be reliable, slow, and expensive, and should not be used as a replacement for a deterministic logic-based solver.</p> Source code in <code>src/typedlogic/integrations/solvers/llm/llm_solver.py</code> <pre><code>@dataclass\nclass LLMSolver(Solver):\n    \"\"\"\n    A solver that uses an LLM.\n\n    This is for research purposes only. LLM output can be reliable, slow, and expensive,\n    and should not be used as a replacement for a deterministic logic-based solver.\n\n    \"\"\"\n\n    model_name: str = field(default=\"gpt-4o\")\n    fol_syntax: str = field(default=\"fol\")\n    profile: ClassVar[Profile] = MixedProfile(Unrestricted(), OpenWorld())\n\n    def models(self) -&gt; Iterator[Model]:\n        r = self.check()\n        if r.satisfiable:\n            yield Model()\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        results = list(self.prove_multiple([sentence]))\n        return results[0][1]\n\n    def prove_multiple(self, sentences: List[Sentence]) -&gt; Iterable[Tuple[Sentence, Optional[bool]]]:\n        compiler = get_compiler(self.fol_syntax)\n        program = compiler.compile(self.base_theory)\n        model = llm.get_model(self.model_name)\n        enumerated_goals = dict(enumerate(sentences, 1))\n        enumerated_goals_compiled = {i: compiler.compile_sentence(s) for i, s in enumerated_goals.items()}\n        goals = \"\\n\".join([f\"{i}: {s}\" for i, s in enumerated_goals_compiled.items()])\n        prompt = TEMPLATE.format(program=program, goals=goals)\n        #print(f\"SYSTEM={SYSTEM}\")\n        #print(f\"PROMPT={prompt}\")\n        response = model.prompt(prompt, system=SYSTEM)\n        print(f\"RESPONSE={response.text()}\")\n        obj = self.parse_response(response.text())\n        for i in obj[\"provable\"]:\n            yield enumerated_goals[int(i)], True\n        for i in obj[\"not_provable\"]:\n            yield enumerated_goals[int(i)], False\n\n    def parse_response(self, text: str) -&gt; Any:\n        if \"```\" in text:\n            text = text.split(\"```\")[1].strip()\n            if text.startswith(\"yaml\"):\n                text = text[5:].strip()\n        return yaml.safe_load(text)\n\n\n    def check(self) -&gt; Solution:\n        return Solution(satisfiable=None)\n</code></pre>"},{"location":"integrations/solvers/prover9/","title":"Prover9 Integrations","text":"<p>               Bases: <code>Solver</code></p> <p>A solver that uses Prover9.</p> <p>Prover9 is an automated theorem prover for first-order and equational logic</p> <p>See The Prover9 site</p> <p>Note that in order to use this integration, you need to install Prover9 and have it on your path.</p>"},{"location":"integrations/solvers/prover9/#typedlogic.integrations.solvers.prover9.prover9_solver.Prover9Solver--example","title":"Example:","text":"<pre><code>&gt;&gt;&gt; from typedlogic.integrations.solvers.prover9 import Prover9Solver\n&gt;&gt;&gt; from typedlogic.parsers.pyparser import PythonParser\n&gt;&gt;&gt; import tests.theorems.simple_contradiction as sc\n&gt;&gt;&gt; solver = Prover9Solver()\n&gt;&gt;&gt; solver.load(sc)\n&gt;&gt;&gt; r = solver.check()\n&gt;&gt;&gt; r.satisfiable\nFalse\n</code></pre> <p>This solver does implements the open-world assumption.</p> Source code in <code>src/typedlogic/integrations/solvers/prover9/prover9_solver.py</code> <pre><code>@dataclass\nclass Prover9Solver(Solver):\n    \"\"\"\n    A solver that uses Prover9.\n\n    Prover9 is an automated theorem prover for first-order and equational logic\n\n    See [The Prover9 site](https://www.cs.unm.edu/~mccune/prover9/)\n\n    Note that in order to use this integration, you need to [install Prover9](https://www.cs.unm.edu/~mccune/prover9/)\n    and have it on your path.\n\n    Example:\n    -------\n        &gt;&gt;&gt; from typedlogic.integrations.solvers.prover9 import Prover9Solver\n        &gt;&gt;&gt; from typedlogic.parsers.pyparser import PythonParser\n        &gt;&gt;&gt; import tests.theorems.simple_contradiction as sc\n        &gt;&gt;&gt; solver = Prover9Solver()\n        &gt;&gt;&gt; solver.load(sc)\n        &gt;&gt;&gt; r = solver.check()\n        &gt;&gt;&gt; r.satisfiable\n        False\n\n\n    This solver does implements the open-world assumption.\n\n    \"\"\"\n\n    exec_name: str = field(default=\"prover9\")\n    profile: ClassVar[Profile] = MixedProfile(Unrestricted(), OpenWorld())\n\n    def models(self) -&gt; Iterator[Model]:\n        r = self.check()\n        if r.satisfiable:\n            yield Model()\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        proved = self._run(goals=[sentence])\n        return proved\n\n    def _run(self, goals: Optional[List[Sentence]] = None) -&gt; bool:\n        compiler = Prover9Compiler()\n        #print(f\"THEORY; n_sentences: {len(self.base_theory.sentences)}\")\n        program = compiler.compile(self.base_theory, goals=goals)\n\n        #print(program)\n\n        with tempfile.NamedTemporaryFile(suffix=\".prover9\", mode=\"w\") as fp:\n            fp.write(program)\n            fp.flush()\n            res = subprocess.run([self.exec_name, \"-f\", fp.name], capture_output=True)\n            if res.returncode not in (0, 2):\n                logger.error(res.stdout.decode())\n                raise ValueError(f\"Prover9 failed with return code {res.returncode}\")\n\n            if \"THEOREM PROVED\" in res.stdout.decode():\n                return True\n            else:\n                return False\n\n    def check(self) -&gt; Solution:\n        proved = self._run()\n        unsat = not self.base_theory.goals and not proved\n        return Solution(satisfiable=unsat)\n\n    def dump(self) -&gt; str:\n        compiler = Prover9Compiler()\n        return compiler.compile(self.base_theory)\n</code></pre>"},{"location":"integrations/solvers/snakelog/","title":"SnakeLog Integrations","text":"<p>               Bases: <code>Solver</code></p> <p>A solver that uses snakelog.</p> <p>Snakelog is a lightweight Datalog engine that uses SQLite as a backend, for more details see this blog post.</p> <p>While Snakelog is only supports a limited subset of Datalog, it has the advantage of being fast and requiring no additional dependencies. It is well suited for simple traversal-style logic programming problems, such as the one below.</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; from typedlogic import Implies, And, Variable\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n&gt;&gt;&gt; class ParentOf(FactBaseModel):\n...     parent: str\n...     child: str\n&gt;&gt;&gt; solver = SnakeLogSolver(strict=True)\n &gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"ParentOf\", arguments={'parent': str, 'child': str}))\n&gt;&gt;&gt; solver.add_fact(ParentOf(parent='p1', child='p1a'))\n&gt;&gt;&gt; solver.add_fact(ParentOf(parent='p1a', child='p1aa'))\n&gt;&gt;&gt; X = Variable(\"X\")\n&gt;&gt;&gt; Y = Variable(\"Y\")\n&gt;&gt;&gt; Z = Variable(\"Z\")\n&gt;&gt;&gt; solver.add_sentence(Implies(Term(ParentOf.__name__, X, Y), Term(AncestorOf.__name__, X, Y)))\n&gt;&gt;&gt; solver.add_sentence(Implies(And(Term(AncestorOf.__name__, X, Z),\n...                                 Term(AncestorOf.__name__, Z, Y)),\n...                             Term(AncestorOf.__name__, X, Y)))\n&gt;&gt;&gt; model = solver.model()\n&gt;&gt;&gt; facts = [str(f) for f in model.ground_terms]\n&gt;&gt;&gt; for f in sorted(facts):\n...     print(f)\nAncestorOf(p1, p1a)\nAncestorOf(p1, p1aa)\nAncestorOf(p1a, p1aa)\nParentOf(p1, p1a)\nParentOf(p1a, p1aa)\n</code></pre> <p>This solver does not implement the open-world assumption.</p> <pre><code>&gt;&gt;&gt; from typedlogic.profiles import OpenWorld\n&gt;&gt;&gt; solver.profile.impl(OpenWorld)\nFalse\n</code></pre> Source code in <code>src/typedlogic/integrations/solvers/snakelog/snakelog_solver.py</code> <pre><code>@dataclass\nclass SnakeLogSolver(Solver):\n    \"\"\"\n    A solver that uses snakelog.\n\n    Snakelog is a lightweight Datalog engine that uses SQLite as a backend,\n    for more details see [this blog post](https://www.philipzucker.com/snakelog-post/).\n\n    While Snakelog is only supports a limited subset of Datalog, it has the advantage of being\n    **fast** and requiring no additional dependencies. It is well suited for simple traversal-style\n    logic programming problems, such as the one below.\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; from typedlogic import Implies, And, Variable\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n        &gt;&gt;&gt; class ParentOf(FactBaseModel):\n        ...     parent: str\n        ...     child: str\n        &gt;&gt;&gt; solver = SnakeLogSolver(strict=True)\n         &gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"ParentOf\", arguments={'parent': str, 'child': str}))\n        &gt;&gt;&gt; solver.add_fact(ParentOf(parent='p1', child='p1a'))\n        &gt;&gt;&gt; solver.add_fact(ParentOf(parent='p1a', child='p1aa'))\n        &gt;&gt;&gt; X = Variable(\"X\")\n        &gt;&gt;&gt; Y = Variable(\"Y\")\n        &gt;&gt;&gt; Z = Variable(\"Z\")\n        &gt;&gt;&gt; solver.add_sentence(Implies(Term(ParentOf.__name__, X, Y), Term(AncestorOf.__name__, X, Y)))\n        &gt;&gt;&gt; solver.add_sentence(Implies(And(Term(AncestorOf.__name__, X, Z),\n        ...                                 Term(AncestorOf.__name__, Z, Y)),\n        ...                             Term(AncestorOf.__name__, X, Y)))\n        &gt;&gt;&gt; model = solver.model()\n        &gt;&gt;&gt; facts = [str(f) for f in model.ground_terms]\n        &gt;&gt;&gt; for f in sorted(facts):\n        ...     print(f)\n        AncestorOf(p1, p1a)\n        AncestorOf(p1, p1aa)\n        AncestorOf(p1a, p1aa)\n        ParentOf(p1, p1a)\n        ParentOf(p1a, p1aa)\n\n    This solver does not implement the open-world assumption.\n\n        &gt;&gt;&gt; from typedlogic.profiles import OpenWorld\n        &gt;&gt;&gt; solver.profile.impl(OpenWorld)\n        False\n    \"\"\"\n\n    _wrapped_solver: Optional[snakelog.BaseSolver] = None\n    predicate_map: Optional[Dict[str, PredicateDefinition]] = None\n    sentences: List[Sentence] = field(default_factory=list)\n\n    profile: ClassVar[Profile] = MixedProfile(ClassicDatalog(), UnsortedLogic(), ExcludedProfile(PropositionalLogic()))\n\n    methods_supported: ClassVar[List[Method]] = [\n        Method(name=\"litelog\", impl_class=litelog.Solver, is_default=True),\n        Method(name=\"souffle\", impl_class=SouffleSolver),\n    ]\n\n    @property\n    def wrapped_solver(self) -&gt; snakelog.BaseSolver:\n        if self._wrapped_solver is None:\n            impl_class = self.method.impl_class\n            if impl_class is None:\n                raise ValueError(\"No implementation class defined\")\n            self._wrapped_solver = impl_class()\n        return self._wrapped_solver\n\n    def check(self) -&gt; Solution:\n        return Solution(satisfiable=None)\n\n    def models(self) -&gt; Iterator[Model]:\n        s = self.wrapped_solver\n        s.run()\n\n        facts = []\n        if not self.predicate_map:\n            raise ValueError(\"Predicates have not been defined\")\n        for p, pd in self.predicate_map.items():\n            tbl = self.to_predicate(p)\n            try:\n                res = s.con.execute(f\"SELECT * FROM {tbl}\")\n                for fact in res.fetchall():\n                    bindings = dict(zip(pd.arguments.keys(), fact[0:], strict=False))\n                    fact = Term(p, bindings)\n                    facts.append(fact)\n            except sqlite3.OperationalError:\n                # TODO: better way to detect zero implications\n                pass\n        m = Model(\n            source_object=s,\n            ground_terms=facts\n        )\n        yield m\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        return super().prove(sentence)\n\n    def add_fact(self, fact: FactMixin) -&gt; None:\n        p = self.to_predicate(fact_predicate(fact))\n        atom = litelog.Atom(p, list(fact_arg_values(fact)))\n        self.wrapped_solver.add(atom)\n        self.sentences.append(fact)\n\n    def add_sentence(self, sentence: Sentence) -&gt; None:\n        try:\n            for sentence in to_horn_rules(sentence):\n                for snakelog_expr in self.to_clauses(sentence):\n                    self.wrapped_solver.add(snakelog_expr)\n                    self.sentences.append(sentence)\n        except NotInProfileError as e:\n            logger.info(f\"SKIPPING: {sentence} // {e}\")\n            if self.strict:\n                raise e\n\n    def _string_type(self) -&gt; str:\n        # TODO: remove after the following is fixed\n        # https://github.com/philzook58/snakelog/issues/4\n        if self.method_name == \"souffle\":\n            return \"symbol\"\n        return \"TEXT\"\n\n    def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n        if not self.predicate_map:\n            self.predicate_map = {}\n        s = self.wrapped_solver\n        string_type = self._string_type()\n        arg_types = [string_type for _ in predicate_definition.arguments.keys()]\n        sig = [self.to_predicate(predicate_definition.predicate)] + arg_types\n        s.Relation(*sig)\n        self.predicate_map[predicate_definition.predicate] = predicate_definition\n\n    def to_predicate(self, predicate: str) -&gt; str:\n        return predicate.lower()\n\n    def to_clauses(self, sentence: Sentence) -&gt; List[Union[litelog.Clause, litelog.Atom]]:\n        if isinstance(sentence, tlog.Forall):\n            return self.to_clauses(sentence.sentence)\n        if isinstance(sentence, tlog.Implied):\n            return self.to_clauses(tlog.Implies(sentence.operands[1], sentence.operands[0]))\n        if isinstance(sentence, tlog.Iff):\n            return self.to_clauses(tlog.And(tlog.Implies(sentence.left, sentence.right),\n                                            tlog.Implies(sentence.right, sentence.left)))\n        if isinstance(sentence, tlog.And):\n            sentences = []\n            for s in sentence.operands:\n                sentences.extend(self.to_clauses(s))\n            return sentences\n        return [self.to_clause(sentence)]\n\n    def to_clause(self, sentence: Sentence) -&gt; Union[litelog.Clause, litelog.Atom]:\n        if isinstance(sentence, tlog.Forall):\n            return self.to_clause(sentence.sentence)\n        if isinstance(sentence, tlog.Implies):\n            head = self.to_atom(sentence.consequent)\n            body = self.to_body(sentence.antecedent)\n            return litelog.Clause(head, body)\n        if isinstance(sentence, tlog.Term):\n            # unit clause\n            return self.to_atom(sentence)\n        raise NotInProfileError(f\"Unknown clause type {type(sentence)} :: {sentence}\")\n\n    def to_atom(self, sentence: Sentence) -&gt; litelog.Atom:\n        if isinstance(sentence, tlog.Term):\n            def _render_arg(arg):\n                if arg is None:\n                    return None\n                if isinstance(arg, tlog.Variable):\n                    # TODO: this should be the norm after normalization\n                    arg = arg.name\n                    return Var(arg.upper())\n                else:\n                    if isinstance(arg, PRIMITIVE_TYPES):\n                        return arg\n                    else:\n                        return str(arg)\n            return litelog.Atom(self.to_predicate(sentence.predicate), [_render_arg(a) for a in sentence.bindings.values()])\n        if isinstance(sentence, typedlogic.pybridge.FactMixin):\n            def _render_arg(arg):\n                if arg is None:\n                    return None\n                return Var(arg.upper())\n            p = self.to_predicate(fact_predicate(sentence))\n            return litelog.Atom(p, [_render_arg(a) for a in fact_arg_values(sentence)])\n        raise NotInProfileError(f\"Unknown atom type {type(sentence)} :: {sentence}\")\n\n    def to_body(self, sentence: Sentence) -&gt; litelog.Body:\n        if isinstance(sentence, tlog.And):\n            atoms = [self.to_atom(s) for s in sentence.operands]\n            return litelog.Body(atoms)\n        if isinstance(sentence, (tlog.Term, typedlogic.pybridge.FactMixin)):\n            return litelog.Body([self.to_atom(sentence)])\n        raise NotInProfileError(f\"Unknown body type {type(sentence)} :: {sentence}\")\n\n\n\n    def dump(self) -&gt; str:\n        return str(self.wrapped_solver)\n</code></pre>"},{"location":"integrations/solvers/souffle/","title":"Souffle Integrations","text":"<p>               Bases: <code>Solver</code></p> <p>A solver that uses Souffl\u00e9.</p> <p>Souffl\u00e9 is a logic programming language inspired by Datalog. For more details, see The Souffle site.</p> <p>Note that in order to use this integration, you need to install Souffle and have it on your path.</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n&gt;&gt;&gt; solver = SouffleSolver()\n&gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n&gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n&gt;&gt;&gt; solver.add_sentence_group(aa)\n&gt;&gt;&gt; soln = solver.check()\n</code></pre> <p>This solver does not implement the open-world assumption.</p> <pre><code>&gt;&gt;&gt; from typedlogic.profiles import OpenWorld\n&gt;&gt;&gt; solver.profile.impl(OpenWorld)\nFalse\n</code></pre> Source code in <code>src/typedlogic/integrations/solvers/souffle/souffle_solver.py</code> <pre><code>@dataclass\nclass SouffleSolver(Solver):\n    \"\"\"\n    A solver that uses Souffl\u00e9.\n\n    Souffl\u00e9 is a logic programming language inspired by Datalog. For more details,\n    see [The Souffle site](https://souffle-lang.github.io/).\n\n    Note that in order to use this integration, you need to [install Souffle](https://souffle-lang.github.io/install)\n    and have it on your path.\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n        &gt;&gt;&gt; solver = SouffleSolver()\n        &gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': str, 'descendant': str}))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n        &gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n        &gt;&gt;&gt; solver.add_sentence_group(aa)\n        &gt;&gt;&gt; soln = solver.check()\n\n    This solver does not implement the open-world assumption.\n\n        &gt;&gt;&gt; from typedlogic.profiles import OpenWorld\n        &gt;&gt;&gt; solver.profile.impl(OpenWorld)\n        False\n\n    \"\"\"\n\n    exec_name: str = field(default=\"souffle\")\n    profile: ClassVar[Profile] = MixedProfile(ClassicDatalog(), SortedLogic(), AllowsComparisonTerms(), SingleModelSemantics())\n\n    def models(self) -&gt; Iterator[Model]:\n        compiler = SouffleCompiler()\n        program = compiler.compile(self.base_theory)\n        pdmap = {}\n\n        facts = []\n        with tempfile.TemporaryDirectory() as temp_dir:\n            # Create output directives for each predicate\n            output_files = {}\n            input_files = {}\n            for pd in self.base_theory.predicate_definitions:\n                pred = pd.predicate\n                pdmap[pred] = pd\n                output_file = Path(temp_dir) / f\"{pred}.csv\"\n                output_files[pred] = str(output_file)\n                program += f'\\n.output {pred}(IO=file, filename=\"{output_file}\")\\n'\n                input_file = Path(temp_dir) / f\"{pred}__in.csv\"\n                input_files[pred] = str(input_file)\n                program += f'\\n.input {pred}(IO=file, filename=\"{input_file}\")\\n'\n                with open(input_file, 'w', encoding=\"utf-8\") as csvfile:\n                    writer = csv.writer(csvfile, delimiter=\"\\t\")\n                    for term in self.base_theory.ground_terms:\n                        if term.predicate == pred:\n                            writer.writerow(term.bindings.values())\n\n            with tempfile.NamedTemporaryFile(suffix=\".dl\", mode=\"w\") as fp:\n                fp.write(program)\n                fp.flush()\n                res = subprocess.run([self.exec_name, fp.name], capture_output=True)\n                if res.stderr:\n                    msg = res.stderr.decode()\n                    import re\n                    if re.match(r\".*Variable (\\S+) only occurs once.*\", msg):\n                        logger.info(msg)\n                    else:\n                        logger.error(msg)\n\n\n            for pred, filename in output_files.items():\n                if not Path(filename).exists():\n                    continue\n                pd = pdmap[pred]\n                rows = []\n                with open(filename, 'r') as csvfile:\n                    reader = csv.reader(csvfile, delimiter=\"\\t\")\n                    for row in reader:\n                        rows.append(row)\n                facts.extend(make_terms(rows, pd))\n\n        model = Model(\n            source_object=self,\n            ground_terms=facts\n        )\n        yield model\n\n\n    def check(self) -&gt; Solution:\n        return Solution(satisfiable=None)\n\n    def dump(self) -&gt; str:\n        compiler = SouffleCompiler()\n        return compiler.compile(self.base_theory)\n</code></pre>"},{"location":"integrations/solvers/z3/","title":"Z3 Integrations","text":"<p>               Bases: <code>Solver</code></p> <p>A solver that uses Z3.</p> <pre><code>&gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n&gt;&gt;&gt; class AncestorOf(FactBaseModel):\n...     ancestor: str\n...     descendant: str\n&gt;&gt;&gt; solver = Z3Solver()\n&gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': \"str\", 'descendant': \"str\"}))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n&gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n&gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n&gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n&gt;&gt;&gt; solver.add_sentence_group(aa)\n&gt;&gt;&gt; soln = solver.check()\n</code></pre> Source code in <code>src/typedlogic/integrations/solvers/z3/z3_solver.py</code> <pre><code>@dataclass\nclass Z3Solver(Solver):\n    \"\"\"\n    A solver that uses Z3.\n\n        &gt;&gt;&gt; from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n        &gt;&gt;&gt; class AncestorOf(FactBaseModel):\n        ...     ancestor: str\n        ...     descendant: str\n        &gt;&gt;&gt; solver = Z3Solver()\n        &gt;&gt;&gt; solver.add_predicate_definition(PredicateDefinition(predicate=\"AncestorOf\", arguments={'ancestor': \"str\", 'descendant': \"str\"}))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1', descendant='p1a'))\n        &gt;&gt;&gt; solver.add_fact(AncestorOf(ancestor='p1a', descendant='p1aa'))\n        &gt;&gt;&gt; from typedlogic import SentenceGroup, PredicateDefinition\n        &gt;&gt;&gt; aa = SentenceGroup(name=\"transitivity-of-ancestor-of\")\n        &gt;&gt;&gt; solver.add_sentence_group(aa)\n        &gt;&gt;&gt; soln = solver.check()\n\n    \"\"\"\n\n    _wrapped_solver: Optional[z3.Solver] = None\n    profile: ClassVar[Profile] = MixedProfile(Unrestricted(), SortedLogic(), MultipleModelSemantics(), OpenWorld(), AllowsComparisonTerms())\n    max_models: int = field(default=5)\n\n    # TODO: rename this\n    predicate_map: Optional[Dict[str, z3.FuncDecl]] = None\n\n    def __post_init__(self):\n        if self._wrapped_solver is None:\n            self._wrapped_solver = z3.Solver()\n\n    @property\n    def wrapped_solver(self) -&gt; z3.Solver:\n        if self._wrapped_solver is None:\n            self._wrapped_solver = z3.Solver()\n        return self._wrapped_solver\n\n    def check(self) -&gt; Solution:\n        result = self.wrapped_solver.check()\n        return Solution(satisfiable=result == z3.sat)\n\n    def models(self) -&gt; Iterator[Model]:\n        results = get_models(self.wrapped_solver, self.max_models)\n        if not results:\n            raise ValueError(\"Not satisfiable\")\n        for wmodel in results:\n            rmodel = Model(description=str(wmodel),\n                           source_object=wmodel,\n                           ground_terms=[],\n                           )\n            yield rmodel\n        return\n\n    def prove(self, sentence: Sentence) -&gt; Optional[bool]:\n        s = self.wrapped_solver\n        s.push()\n        s.add(z3.Not(self.translate(sentence)))\n        result = s.check()\n        s.pop()\n        return result == z3.unsat\n\n    def _unroll_type(self, typ: DefinedType) -&gt; Set[str]:\n        \"\"\"\n        Unroll a defined type into its components\n\n        :param typ:\n        :return:\n        \"\"\"\n        if isinstance(typ, str):\n            if typ in self.type_definitions:\n                return self._unroll_type(self.base_theory.type_definitions[typ])\n            return {typ}\n        if isinstance(typ, list):\n            ts: List[str] = []\n            for t in typ:\n                ts.extend(self._unroll_type(t))\n            return set(ts)\n        raise ValueError(f\"Unknown type {typ}\")\n\n    def _sort(self, typ: Optional[str] = None) -&gt; Union[Callable, Type[z3.SortRef]]:\n        # TODO: change this to return instantiated sort, not the sort class\n        if not typ:\n            return z3.StringSort\n        typs = self._unroll_type(typ)\n        repl_map = {\n            \"Decimal\": \"float\",\n        }\n        typs = {repl_map.get(t, t) for t in typs}\n        if \"float\" in typs and \"int\" in typs:\n            typs = typs.difference({\"int\"})\n        if len(typs) &gt; 1:\n            # unions not directly supported\n            # TODO: add constraints\n            return lambda: z3.DeclareSort(typ)\n        typ = list(typs)[0]\n        if not isinstance(typ, str):\n            # TODO - we should ensure types are strings\n            typ = typ.__name__\n        return SORT_MAP.get(typ, z3.StringSort)\n\n    def _const(self, value: Any, typ: str) -&gt; z3.Const:\n        sort = self._sort(typ)\n        return z3.Const(value, sort())\n\n    def _func(self, name: str, *args) -&gt; z3.FuncDecl:\n        args = tuple([args] + [z3.BoolSort()])\n        return z3.Function(name, *args)\n\n    def _tr(self, var: Any, bindings: dict) -&gt; z3.ExprRef:\n        if var is None:\n            return z3.StringVal(\"None\")\n        if isinstance(var, Variable):\n            if var.name not in bindings:\n                if var.name in self.constants:\n                    pf_arg = self.constants[var.name]\n                else:\n                    raise ValueError(f\"Variable {var.name} not bound in {bindings} or {self.constants}\")\n            else:\n                pf_arg = bindings[var.name]\n            return pf_arg\n        py_typ = type(var).__name__\n        z3_typ = self._sort(py_typ)\n        t2m_map = {\n            z3.StringSort: z3.StringVal,\n            z3.IntSort: z3.IntVal,\n            z3.BoolSort: z3.BoolVal,\n            z3.RealSort: z3.RealVal,\n        }\n        z3_valf = t2m_map.get(z3_typ, z3.StringVal)\n        return z3_valf(var)\n\n    def add_fact(self, fact: FactMixin) -&gt; None:\n        return self.add_sentence(fact)\n\n    def add_sentence(self, sentence: Sentence) -&gt; None:\n        # normalize_variables(sentence)\n        z3_expr = self.translate(sentence)\n        self.wrapped_solver.add(z3_expr)\n\n\n    def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n        \"\"\"\n        Add a predicate definition to the solver.\n\n        E.g. `` Function('AncestorOf', StringSort(), StringSort(), BoolSort())``\n\n        :param predicate_definition:\n        :return:\n        \"\"\"\n        args = [self._sort(a)() for a in predicate_definition.arguments.values()]\n        args += [z3.BoolSort()]\n        p = z3.Function(predicate_definition.predicate, *args)\n        if not self.predicate_map:\n            self.predicate_map = {}\n        self.predicate_map[predicate_definition.predicate] = p\n        if not self.predicate_definitions:\n            self.predicate_definitions = {}\n        self.predicate_definitions[predicate_definition.predicate] = predicate_definition\n\n    def translate(self, sentence: Sentence, bindings: Optional[Dict[str, z3.SortRef]] = None) -&gt; z3.ExprRef:\n        \"\"\"\n        Translate a Sentence to a Z3 expression.\n\n        :param sentence: The Sentence to translate\n        :param bindings: local bindings of variable names to Z3 Sorts\n        :return: The Z3 expression\n        \"\"\"\n        if isinstance(sentence, tlog.And):\n            return z3.And(*[self.translate(op, bindings) for op in sentence.operands])\n        if isinstance(sentence, tlog.Or):\n            return z3.Or(*[self.translate(op, bindings) for op in sentence.operands])\n        if isinstance(sentence, tlog.Xor):\n            return z3.Xor(*[self.translate(op, bindings) for op in sentence.operands])\n        if isinstance(sentence, tlog.ExactlyOne):\n            disj = []\n            for a in sentence.operands:\n                disj.append(z3.And(self.translate(a, bindings),\n                                   *[z3.Not(self.translate(b, bindings)) for b in sentence.operands if b != a]))\n            return z3.Or(*disj)\n        if isinstance(sentence, tlog.Not):\n            return z3.Not(self.translate(sentence.operands[0], bindings))\n        if isinstance(sentence, tlog.Iff):\n            # rewrite\n            lhs = sentence.left\n            rhs = sentence.right\n            rewritten = tlog.And(tlog.Implies(lhs, rhs), tlog.Implies(rhs, lhs))\n            return self.translate(rewritten, bindings)\n        if isinstance(sentence, tlog.Implied):\n            # rewrite\n            lhs = sentence.operands[0]\n            rhs = sentence.operands[1]\n            return self.translate(tlog.Implies(rhs, lhs), bindings)\n        if isinstance(sentence, tlog.Implies):\n            lhs = self.translate(sentence.operands[0], bindings)\n            rhs = self.translate(sentence.operands[1], bindings)\n            return z3.Implies(lhs, rhs)\n        if isinstance(sentence, (tlog.Forall, tlog.Exists)):\n            if not bindings:\n                bindings = {}\n            args = []\n            for v in sentence.variables:\n                var_name = v.name\n                domain = v.domain\n                s = self._sort(domain)\n                arg = z3.Const(var_name, s())  ## TODO\n                bindings[var_name] = arg\n                args.append(arg)\n            inner_sentence = self.translate(sentence.sentence, bindings)\n            if isinstance(sentence, tlog.Exists):\n                return z3.Exists(args, inner_sentence)\n            else:\n                return z3.ForAll(args, inner_sentence)\n        if isinstance(sentence, (tlog.Term, typedlogic.pybridge.FactMixin)): # TODO: use Expression\n            if isinstance(sentence, typedlogic.pybridge.FactMixin):\n                sentence = tlog.Term(fact_predicate(sentence), fact_arg_map(sentence))\n            if not self.predicate_map or not self.predicate_definitions:\n                raise ValueError(\"You must add predicate definitions before adding facts\")\n            pd = self.predicate_definitions.get(sentence.predicate)\n            pf = self.predicate_map.get(sentence.predicate)\n            if pf is None and sentence.predicate in NUMERIC_BUILTINS:\n                pf = NUMERIC_BUILTINS[sentence.predicate]\n            elif pf is None or pd is None:\n                raise ValueError(f\"Predicate {sentence.predicate} not found in {self.predicate_map}\\n\"\n                                 \"Did you remember to declare these as predicates?\")\n            elif sentence.positional:\n                # TODO: more elegant way to do this\n                sentence = copy(sentence)\n                sentence.make_keyword_indexed(list(pd.arguments.keys()))\n            pf_args = []\n            for arg_name, var in sentence.bindings.items():\n                if not bindings:\n                    bindings = {}\n                if isinstance(var, Variable):\n                    if var.name not in bindings:\n                        if var.name in self.constants:\n                            pf_arg = self.constants[var.name]\n                        else:\n                            raise ValueError(f\"Variable {var.name} not bound in {bindings} or {self.constants}\")\n                    else:\n                        pf_arg = bindings[var.name]\n                    pf_args.append(pf_arg)\n                elif isinstance(var, Term):\n                    args = [self._tr(a, bindings) for a in var.values]\n                    p = var.predicate\n                    if p == \"add\":\n                        pf_args.append(args[0] + args[1])\n                    elif p == \"gt\":\n                        pf_args.append(args[0] &gt; args[1])\n                    else:\n                        raise NotImplementedError(f\"Term not implemented: {var}\")\n                elif var is None:\n                    pf_args.append(z3.StringVal(\"None\"))\n                else:\n                    py_typ = type(var).__name__\n                    z3_typ = self._sort(py_typ)\n                    t2m_map = {\n                        z3.StringSort: z3.StringVal,\n                        z3.IntSort: z3.IntVal,\n                        z3.BoolSort: z3.BoolVal,\n                        z3.RealSort: z3.RealVal,\n                    }\n                    z3_valf = t2m_map.get(z3_typ, z3.StringVal)\n                    pf_arg = z3_valf(var)\n                    pf_args.append(pf_arg)\n            try:\n                z3_expr = pf(*pf_args)\n            except Exception as e:\n                raise ValueError(f\"Error translating {sentence} args: {pf_args} to Z3 using {pf}:\\n{e}\")\n            return z3_expr\n        raise NotImplementedError(f'Not implemented:{type(sentence)} :: {sentence}')\n\n    def dump(self) -&gt; str:\n        return str(self.wrapped_solver)\n</code></pre>"},{"location":"integrations/solvers/z3/#typedlogic.integrations.solvers.z3.Z3Solver.add_predicate_definition","title":"<code>add_predicate_definition(predicate_definition)</code>","text":"<p>Add a predicate definition to the solver.</p> <p>E.g. <code>Function('AncestorOf', StringSort(), StringSort(), BoolSort())</code></p> <p>Parameters:</p> Name Type Description Default <code>predicate_definition</code> <code>PredicateDefinition</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/typedlogic/integrations/solvers/z3/z3_solver.py</code> <pre><code>def add_predicate_definition(self, predicate_definition: PredicateDefinition) -&gt; None:\n    \"\"\"\n    Add a predicate definition to the solver.\n\n    E.g. `` Function('AncestorOf', StringSort(), StringSort(), BoolSort())``\n\n    :param predicate_definition:\n    :return:\n    \"\"\"\n    args = [self._sort(a)() for a in predicate_definition.arguments.values()]\n    args += [z3.BoolSort()]\n    p = z3.Function(predicate_definition.predicate, *args)\n    if not self.predicate_map:\n        self.predicate_map = {}\n    self.predicate_map[predicate_definition.predicate] = p\n    if not self.predicate_definitions:\n        self.predicate_definitions = {}\n    self.predicate_definitions[predicate_definition.predicate] = predicate_definition\n</code></pre>"},{"location":"integrations/solvers/z3/#typedlogic.integrations.solvers.z3.Z3Solver.translate","title":"<code>translate(sentence, bindings=None)</code>","text":"<p>Translate a Sentence to a Z3 expression.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>Sentence</code> <p>The Sentence to translate</p> required <code>bindings</code> <code>Optional[Dict[str, SortRef]]</code> <p>local bindings of variable names to Z3 Sorts</p> <code>None</code> <p>Returns:</p> Type Description <code>ExprRef</code> <p>The Z3 expression</p> Source code in <code>src/typedlogic/integrations/solvers/z3/z3_solver.py</code> <pre><code>def translate(self, sentence: Sentence, bindings: Optional[Dict[str, z3.SortRef]] = None) -&gt; z3.ExprRef:\n    \"\"\"\n    Translate a Sentence to a Z3 expression.\n\n    :param sentence: The Sentence to translate\n    :param bindings: local bindings of variable names to Z3 Sorts\n    :return: The Z3 expression\n    \"\"\"\n    if isinstance(sentence, tlog.And):\n        return z3.And(*[self.translate(op, bindings) for op in sentence.operands])\n    if isinstance(sentence, tlog.Or):\n        return z3.Or(*[self.translate(op, bindings) for op in sentence.operands])\n    if isinstance(sentence, tlog.Xor):\n        return z3.Xor(*[self.translate(op, bindings) for op in sentence.operands])\n    if isinstance(sentence, tlog.ExactlyOne):\n        disj = []\n        for a in sentence.operands:\n            disj.append(z3.And(self.translate(a, bindings),\n                               *[z3.Not(self.translate(b, bindings)) for b in sentence.operands if b != a]))\n        return z3.Or(*disj)\n    if isinstance(sentence, tlog.Not):\n        return z3.Not(self.translate(sentence.operands[0], bindings))\n    if isinstance(sentence, tlog.Iff):\n        # rewrite\n        lhs = sentence.left\n        rhs = sentence.right\n        rewritten = tlog.And(tlog.Implies(lhs, rhs), tlog.Implies(rhs, lhs))\n        return self.translate(rewritten, bindings)\n    if isinstance(sentence, tlog.Implied):\n        # rewrite\n        lhs = sentence.operands[0]\n        rhs = sentence.operands[1]\n        return self.translate(tlog.Implies(rhs, lhs), bindings)\n    if isinstance(sentence, tlog.Implies):\n        lhs = self.translate(sentence.operands[0], bindings)\n        rhs = self.translate(sentence.operands[1], bindings)\n        return z3.Implies(lhs, rhs)\n    if isinstance(sentence, (tlog.Forall, tlog.Exists)):\n        if not bindings:\n            bindings = {}\n        args = []\n        for v in sentence.variables:\n            var_name = v.name\n            domain = v.domain\n            s = self._sort(domain)\n            arg = z3.Const(var_name, s())  ## TODO\n            bindings[var_name] = arg\n            args.append(arg)\n        inner_sentence = self.translate(sentence.sentence, bindings)\n        if isinstance(sentence, tlog.Exists):\n            return z3.Exists(args, inner_sentence)\n        else:\n            return z3.ForAll(args, inner_sentence)\n    if isinstance(sentence, (tlog.Term, typedlogic.pybridge.FactMixin)): # TODO: use Expression\n        if isinstance(sentence, typedlogic.pybridge.FactMixin):\n            sentence = tlog.Term(fact_predicate(sentence), fact_arg_map(sentence))\n        if not self.predicate_map or not self.predicate_definitions:\n            raise ValueError(\"You must add predicate definitions before adding facts\")\n        pd = self.predicate_definitions.get(sentence.predicate)\n        pf = self.predicate_map.get(sentence.predicate)\n        if pf is None and sentence.predicate in NUMERIC_BUILTINS:\n            pf = NUMERIC_BUILTINS[sentence.predicate]\n        elif pf is None or pd is None:\n            raise ValueError(f\"Predicate {sentence.predicate} not found in {self.predicate_map}\\n\"\n                             \"Did you remember to declare these as predicates?\")\n        elif sentence.positional:\n            # TODO: more elegant way to do this\n            sentence = copy(sentence)\n            sentence.make_keyword_indexed(list(pd.arguments.keys()))\n        pf_args = []\n        for arg_name, var in sentence.bindings.items():\n            if not bindings:\n                bindings = {}\n            if isinstance(var, Variable):\n                if var.name not in bindings:\n                    if var.name in self.constants:\n                        pf_arg = self.constants[var.name]\n                    else:\n                        raise ValueError(f\"Variable {var.name} not bound in {bindings} or {self.constants}\")\n                else:\n                    pf_arg = bindings[var.name]\n                pf_args.append(pf_arg)\n            elif isinstance(var, Term):\n                args = [self._tr(a, bindings) for a in var.values]\n                p = var.predicate\n                if p == \"add\":\n                    pf_args.append(args[0] + args[1])\n                elif p == \"gt\":\n                    pf_args.append(args[0] &gt; args[1])\n                else:\n                    raise NotImplementedError(f\"Term not implemented: {var}\")\n            elif var is None:\n                pf_args.append(z3.StringVal(\"None\"))\n            else:\n                py_typ = type(var).__name__\n                z3_typ = self._sort(py_typ)\n                t2m_map = {\n                    z3.StringSort: z3.StringVal,\n                    z3.IntSort: z3.IntVal,\n                    z3.BoolSort: z3.BoolVal,\n                    z3.RealSort: z3.RealVal,\n                }\n                z3_valf = t2m_map.get(z3_typ, z3.StringVal)\n                pf_arg = z3_valf(var)\n                pf_args.append(pf_arg)\n        try:\n            z3_expr = pf(*pf_args)\n        except Exception as e:\n            raise ValueError(f\"Error translating {sentence} args: {pf_args} to Z3 using {pf}:\\n{e}\")\n        return z3_expr\n    raise NotImplementedError(f'Not implemented:{type(sentence)} :: {sentence}')\n</code></pre>"},{"location":"learning/multiple-models/","title":"Multiple models","text":"<pre><code>from typing import Union\nfrom pydantic import BaseModel\n\nclass Organization(BaseModel):\n    name: str\n    address: str\n\nclass Person(BaseModel):\n    name: str\n    address: str\n    year_of_birth: int\n\n\n\nclass Device(BaseModel):\n    name: str\n    manufactured_by: Union[Person, Organization]\n</code></pre> <pre><code>my_device = Device(name=\"my_device\", manufactured_by={\"name\": \"John Doe\", \"address\": \"123 Main St.\", \"year_of_birth\": 1980})\ntype(my_device.manufactured_by)\n</code></pre> <pre>\n<code>__main__.Person</code>\n</pre> <pre><code>my_device = Device(name=\"my_device\", manufactured_by={\"name\": \"John Doe\", \"address\": \"123 Main St.\"})\ntype(my_device.manufactured_by)\n</code></pre> <pre>\n<code>__main__.Organization</code>\n</pre> <pre><code>try:\n    my_device.manufactured_by.year_of_birth = 1980\nexcept ValueError as e:\n    print(e)\n</code></pre> <pre>\n<code>\"Organization\" object has no field \"year_of_birth\"\n</code>\n</pre> <pre><code>my_device_dict = my_device.model_dump()\nmy_device_dict\n</code></pre> <pre>\n<code>{'name': 'my_device',\n 'manufactured_by': {'name': 'John Doe', 'address': '123 Main St.'}}</code>\n</pre> <pre><code>import typedlogic.theories.jsonlog.loader as jsonlog_loader\n\nfacts = list(jsonlog_loader.generate_from_object(my_device_dict))\n</code></pre> <pre><code>facts\n</code></pre> <pre>\n<code>[NodeIsObject(loc='/'),\n ObjectNodeLookup(loc='/', key='name', member='/name/'),\n NodeIsLiteral(loc='/name/'),\n NodeStringValue(loc='/name/', value='my_device'),\n ObjectNodeLookup(loc='/', key='manufactured_by', member='/manufactured_by/'),\n NodeIsObject(loc='/manufactured_by/'),\n ObjectNodeLookup(loc='/manufactured_by/', key='name', member='/manufactured_by/name/'),\n NodeIsLiteral(loc='/manufactured_by/name/'),\n NodeStringValue(loc='/manufactured_by/name/', value='John Doe'),\n ObjectNodeLookup(loc='/manufactured_by/', key='address', member='/manufactured_by/address/'),\n NodeIsLiteral(loc='/manufactured_by/address/'),\n NodeStringValue(loc='/manufactured_by/address/', value='123 Main St.')]</code>\n</pre> <pre><code>\n</code></pre>"},{"location":"tutorial/01-first-program/","title":"01 first program","text":"<pre><code># convenience function for running in a notebook\nfrom utils import show\nshow(\"paths/model.py\")\n</code></pre> <pre>from typedlogic.integrations.frameworks.pydantic import FactBaseModel\n\nID = str\n\nclass Link(FactBaseModel):\n    source: ID\n    target: ID\n\nclass Path(FactBaseModel):\n    source: ID\n    target: ID\n</pre> <p>We can use this just as we would any other Pydantic schema. Here we will import it, and create instances of the <code>Link</code> class, representing direct connections between US states. For our purposes here, we will consider these directed.</p> <pre><code>from paths.model import Link\n</code></pre> <pre><code>data = [(\"CA\", \"NV\"), (\"NV\", \"AZ\"), (\"AZ\", \"UT\"), (\"CA\", \"OR\"), (\"OR\", \"WA\"), (\"WA\", \"ID\"), (\"ID\", \"MT\")]\nlinks = [Link(source=source, target=target) for source, target in data]\nlinks[0:2]\n</code></pre> <pre>\n<code>[Link(source='CA', target='NV'), Link(source='NV', target='AZ')]</code>\n</pre> <p>Because we chose to use Pydantic, we get excellent runtime validation on object creation. Our schema so far has minimal constraints, but we have declared that the types of the two fields are <code>strings</code>. This means that we will get a validation error if we try to create a <code>Link</code> with non-string values.</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    new_link = Link(1,2)\nexcept ValidationError as e:\n    print(\"We got a validation error!\")\n    print(\"** Don't worry, this is expected **\")\n    print(e)\n</code></pre> <pre>\n<code>We got a validation error!\n** Don't worry, this is expected **\n2 validation errors for Link\nsource\n  Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    For further information visit https://errors.pydantic.dev/2.9/v/string_type\ntarget\n  Input should be a valid string [type=string_type, input_value=2, input_type=int]\n    For further information visit https://errors.pydantic.dev/2.9/v/string_type\n</code>\n</pre> <p>So far everything we have done in standard Pydantic! Now, onto so unique typedlogic features:</p> <pre><code>show(\"paths/axioms.py\")\n</code></pre> <pre>from paths.model import Link, Path, ID\nfrom typedlogic.decorators import axiom\n\n@axiom\ndef link_implies_path(x: ID, y: ID):\n    \"\"\"\n    The presence of a link implies the existence of a (one-hop) path.\n    \"\"\"\n    if Link(source=x, target=y):\n        assert Path(source=x, target=y)\n\n@axiom\ndef transitivity(x: ID, y: ID, z: ID):\n    \"\"\"\n    If there is a path from x to y and a path from y to z,\n    then there is a path from x to z.\n    \"\"\"\n    if Path(source=x, target=y) and Path(source=y, target=z):\n        assert Path(source=x, target=z)\n</pre> <p>Note that typedlogic is based in Python, we can take advantage of python constructs like <code>import</code> to modularize our theory.</p> <p>This uses the <code>@axiom</code> decorator to define the rules. These may look a little unusual at first - they are not intended to be executed directly, instead they provide a declarative specification of the rules of our system.</p> <p>If you are familiar with first-order logic, you can read each decorated function as a \"forall\" (universal quantifier) statement, where the arguments are the (typed) variables in the quantifier. If you are not, don't worry for now. You can just read each of the axioms as a simple rule.</p> <pre><code>import paths.axioms as paths_axioms\nfrom typedlogic.integrations.solvers.snakelog import SnakeLogSolver\nsolver = SnakeLogSolver()\nsolver.load(paths_axioms)\n</code></pre> <p>Next we'll add our data to the solver. In this case, we'll add the <code>Link</code> objects we created earlier.</p> <pre><code>for link in links:\n    solver.add(link)\n</code></pre> <p>Now we will ask the solver for a model.</p> <p>Note the term \"model\" is a bit ambiguous. If you are coming from a data modeling and Pydantic background, \"model\" means schema or data model. The use in formal systems and \"model theory\" is a bit different. For now you can think of it as representing a universe of things that might possibly be true.</p> <p>We'll get onto what it would mean for there to be multiple models later, but our simple snakelog solver (like many datalog systems) will just yield a single model, so we'll get that.</p> <pre><code>model = solver.model()\n</code></pre> <p>We can ask the model to retrieve all ground terms (or facts) that can be proved and are consistent in that model.</p> <p>Here we use <code>iter_retrieve</code> to get all the <code>Path</code> objects that can be derived from the axioms</p> <pre><code>for path in model.iter_retrieve(\"Path\"):\n    print(path)\n</code></pre> <pre>\n<code>Path(AZ, UT)\nPath(CA, AZ)\nPath(CA, ID)\nPath(CA, MT)\nPath(CA, NV)\nPath(CA, OR)\nPath(CA, UT)\nPath(CA, WA)\nPath(ID, MT)\nPath(NV, AZ)\nPath(NV, UT)\nPath(OR, ID)\nPath(OR, MT)\nPath(OR, WA)\nPath(WA, ID)\nPath(WA, MT)\n</code>\n</pre> <p>We can see it has given us all transitive / multi-hop paths that can be derived from the starting facts.</p> <p>We can also derive the one-hop links, but this is not very interesting, corresponding to the initial database (because we provided no axioms to entail new links).</p> <p>Let's check this:</p> <pre><code>original_links = {(link.source, link.target) for link in links}\nentailed_links = {term.values for term in model.iter_retrieve(\"Link\")}\nassert original_links == entailed_links\n</code></pre> <p>We can encode more complex inference rules, using predicates with more arguments, encoding the complexity of our domain. We will return to some examples later.</p> <p>For now, let's switch to a different use case, checking our data and our data models.</p> <pre><code>\n</code></pre> <pre><code>from typedlogic.integrations.solvers.z3 import Z3Solver\n\nsolver = Z3Solver()\nsolver.load(paths_axioms)\nfor link in links:\n    solver.add(link)\nsolver.check()\n</code></pre> <pre>\n<code>Solution(satisfiable=True)</code>\n</pre> <p>So far so good! Our data and theory is consistent and satisfiable. But this is not surprising as we have not specified any axioms involving negation.</p> <p>Let's add an axiom that says that there are no cycles, i.e there is no path that leads back to itself. We can write this in FOL as:</p> <p>$$ \\forall x. \\neg Path(x, x) $$</p> <p>But here we will write this in Python syntax using the <code>@axiom</code> decorator:</p> <pre><code>@axiom\ndef acyclicity(x: ID, y: ID):\n    assert not (Path(source=y, target=x) and Path(source=x, target=y))\n</code></pre> <p>Here is what our modified program looks like:</p> <pre><code>show(\"paths/axioms_strict.py\")\n</code></pre> <pre>from paths.model import Link, Path, ID\nfrom typedlogic.decorators import axiom\n\n@axiom\ndef link_implies_path(x: ID, y: ID):\n    \"\"\"Same as before\"\"\"\n    if Link(source=x, target=y):\n        assert Path(source=x, target=y)\n\n@axiom\ndef transitivity(x: ID, y: ID, z: ID):\n    \"\"\"Same as before\"\"\"\n    if Path(source=x, target=y) and Path(source=y, target=z):\n        assert Path(source=x, target=z)\n\n@axiom\ndef acyclicity(x: ID, y: ID):\n    \"\"\"No path should lead from a node back to itself\"\"\"\n    assert not (Path(source=y, target=x) and Path(source=x, target=y))\n</pre> <p>Now let's set up the solver with the new axioms and check for satisfiability again. We will also add a link that creates a cycle.</p> <pre><code>solver = Z3Solver()\nimport paths.axioms_strict as paths_axioms_strict\nsolver.load(paths_axioms_strict)\nfor link in links:\n    solver.add(link)\nsolver.add(Link(source=\"MT\", target=\"CA\"))\nsolver.check().satisfiable\n</code></pre> <pre>\n<code>False</code>\n</pre> <p>Hurrah! As expected, the solver has found that the data is not satisfiable, because we have added a cycle.</p> <p>Currently there is no single easy way to see an explanation, but this will be provided in the future.</p> <pre><code>from typedlogic.integrations.solvers.clingo import ClingoSolver\nsolver = ClingoSolver()\nimport paths.axioms_strict as paths_axioms_strict\nsolver.load(paths_axioms_strict)\nfor link in links:\n    solver.add(link)\n</code></pre> <p>Next we'll add uncertainly using the <code>ExactlyOne</code> boolean sentence type:</p> <pre><code>from typedlogic import ExactlyOne\nsolver.add(ExactlyOne(Link(\"MT\", \"ND\"), Link(\"MT\", \"SD\")))\n</code></pre> <p>We'll check this gives two worlds:</p> <pre><code>models = list(solver.models())\nassert len(models) == 2\n</code></pre> <p>Next we will explore which paths are present in each world:</p> <pre><code>for n, model in enumerate(models):\n    print(f\"Model: {n}\")\n    for t in model.iter_retrieve(\"Path\", \"CA\", \"ND\"):\n        print(f\" has path CA to ND: {t}\")\n    for t in model.iter_retrieve(\"Path\", \"CA\", \"SD\"):\n        print(f\" has path CA to SD: {t}\")\n</code></pre> <pre>\n<code>Model: 0\n has path CA to SD: Path(CA, SD)\nModel: 1\n has path CA to ND: Path(CA, ND)\n</code>\n</pre> <p>As expected there is one world with a path from CA to SD, and another with a path from CA to ND.</p> <p>We can collapse the number of universes by ruling out a path. So far we have only asserted the base one-hop links, but there is nothing to stop us making assertions about multi-hop paths. We can do this by adding a negation of a path to the solver, here stating there is no path from CA to ND:</p> <pre><code>from paths.model import Path\nsolver.add(~Path(\"CA\", \"ND\"))\n</code></pre> <p>This will collapse the number of models to one:</p> <pre><code>models = list(solver.models())\nassert len(models) == 1\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorial/01-first-program/#py-typedlogic-tutorial","title":"py-typedlogic tutorial","text":"<p>This tutorial walks you through some of the basic features of the <code>typedlogic</code> library, and how to define logical formulae for Python data structures and programs.</p> <p>The tutorial makes use of a simple database of <code>Link</code> structures, which represent direct steps in a path through different US states. We will define a predicate <code>Path</code> that represents the transitive closure of the Link predicate.</p> <p>For example, if we have <code>Link</code>s:</p> <ul> <li><code>CA -&gt; NV</code></li> <li><code>NV -&gt; AZ</code></li> <li><code>AZ -&gt; UT</code></li> </ul> <p>Then have 3 paths of length 1 (corresponding to the links), as well as paths of length 2 from <code>CA</code> to <code>AZ</code> and <code>NV</code> to <code>UT</code>, and a path of length 3 from <code>CA</code> to <code>UT</code>.</p>"},{"location":"tutorial/01-first-program/#installation","title":"Installation","text":"<p>To install:</p> <pre><code>pip install typedlogic\n</code></pre> <p>This tutorial makes use of the Snakelog and Z3 integrations, so you would need the Z3 extra:</p> <pre><code>pip install 'typedlogic[snakelog,z3]'\n</code></pre> <p>This tutorial is also a Jupyter notebook, which can be executed interactively.</p>"},{"location":"tutorial/01-first-program/#defining-our-core-data-structures","title":"Defining our core data structures","text":"<p>You can define your data model through a different mechanisms. Currently the recommended ways are</p> <ul> <li>Pydantic classes</li> <li>Python dataclasses</li> </ul> <p>Support for other mechanisms (e.g SQLModels, Pandera) is planned.</p> <p>For this tutorial, we will use a ready-made pydantic file containing the definition of our data model, which will consist of two classes:</p> <ul> <li><code>Link</code>, representing a direct edge between two entities</li> <li><code>Path</code>, representing a path of one or more edges</li> </ul> <p>(For the purposes of this tutorial, we will use a <code>show</code> function to display the contents of our program, but this step is not necessary for everyday use).</p> <p>We will use this to show the contents of the paths/model.py file.</p>"},{"location":"tutorial/01-first-program/#adding-axioms","title":"Adding axioms","text":"<p>Next we want to define logical axioms that determine what inferences to expect from our data model. In particular, we want to define axioms (in this case, simple rules) that</p> <ol> <li>Derives one-hop <code>Path</code>s from the <code>Link</code> predicate.</li> <li>Derives multi-hop <code>Path</code>s from the transitive closure of the one-hop <code>Path</code> predicate.</li> </ol> <p>We have a ready made program for doing this:</p>"},{"location":"tutorial/01-first-program/#solvers","title":"Solvers","text":"<p>The rules are not executed directly - instead they are used as inputs for solvers. Different solvers will operate differently, but broadly they can be thought of as fulfilling two roles:</p> <ol> <li>Finding new facts: Given a set of rules and a set of facts, the solver can derive new facts that are logically entailed by the rules and the facts.</li> <li>Checking whether a set of facts is consistent with the rules, or whether the rules themselves are consistent.</li> </ol> <p>Not all solvers are capable of fulfilling both roles, and solvers may vary in what expressions they understand and how fast they run. py-typedlogic provides as easy bridge onto a number of different solvers, through its integrations mechanism.</p> <p>We will start with a simple pure python builtin solver called SnakeLog. This implements only a subset of logic (formally, it is a small subset of datalog), but it has the advantage of requiring no additional installation steps, and being fast for large datasets.</p> <p>First we'll create the solver object, and load the axioms into it.</p>"},{"location":"tutorial/01-first-program/#satisfiability-checking","title":"Satisfiability Checking","text":"<p>For this we're going to switch to a more expressive solver, the Z3 Prover. You will need to install this as an extra, either:</p> <pre><code>pip install 'typedlogic[z3]'\n</code></pre> <p>We will set up the solver in the same way.</p> <p>This time we won't ask for a model, we will instead run <code>check</code> which checks for satisfiability.</p>"},{"location":"tutorial/01-first-program/#multiple-models","title":"Multiple Models","text":"<p>Next we will explore what happens when we add sentences that lead to multiple possible worlds in which all sentences are true. These separate \"worlds\" are typically called \"models\" in formal logic.</p> <p>We will use the Clingo solver, which is based on Answer Set Programming (ASP) which allows for enumeration of these models.</p> <p>We will set up our base knowledge base as before:</p>"},{"location":"tutorial/02-using-python-data-model/","title":"02 using python data model","text":"<pre><code>from typedlogic import Theory\n\ntheory = Theory(\"my theory\")\n</code></pre> <pre><code>theory.type_definitions = {\n    \"ID\": \"str\",\n    \"PersonID\": \"ID\",\n    \"PetID\": \"ID\",\n    \"SpeciesEnum\": \"str\",\n    \"Age\": [\"int\", \"float\"]\n}\n</code></pre> <p>Here we added some identifier types, as well as a type for stroing ages which is a union of <code>int</code> and <code>float</code></p> <pre><code>from typedlogic import PredicateDefinition\n\n\nPerson = PredicateDefinition(\"Person\", {\"name\": \"PersonID\", \"age\": \"Age\"})\nPet = PredicateDefinition(\"Pet\", {\"name\": \"PetID\", \"owner\": \"PersonID\", \"species\": \"SpeciesEnum\"})\ntheory.predicate_definitions = [Person, Pet]\n</code></pre> <p>Here we added predicate definitions for two predicates, <code>Person/2</code>, and <code>Pet/3</code> (the <code>/</code> nomenclature is often used to denote the number of arguments).</p> <p>Next we will show what happens when we compile this to an alternative representation (here, Souffle)</p> <pre><code>from typedlogic.registry import get_compiler, get_solver\n\ncompiler = get_compiler(\"souffle\")\nprint(compiler.compile(theory))\n</code></pre> <pre>\n<code>.type Id = symbol\n.type Personid = symbol\n.type Petid = symbol\n.type Speciesenum = symbol\n.type Age = number | number\n.decl Person(name: Personid, age: Age)\n.decl Pet(name: Petid, owner: Personid, species: Speciesenum)\n</code>\n</pre> <pre><code>CatOwner = PredicateDefinition(\"CatOwner\", {\"name\": \"PersonID\"})\ntheory.predicate_definitions.append(CatOwner)\n</code></pre> <pre><code>from typedlogic import Term, Variable, Forall\nx = Variable(\"x\")\ny = Variable(\"y\")\ntheory.add(\n    Forall([x, y],\n            Term(\"Pet\", x, y, \"CAT\") &amp;gt;&amp;gt; Term(\"CatOwner\", y)\n           )\n)\n</code></pre> <p>Here the <code>&gt;&gt;</code> is syntactic sugar for Implies.</p> <p>The Term represents the \"atomic\" unit of sentences.</p> <p>Let's see what this looks like in Souffle syntax:</p> <pre><code>print(compiler.compile(theory))\n</code></pre> <pre>\n<code>.type Id = symbol\n.type Personid = symbol\n.type Petid = symbol\n.type Speciesenum = symbol\n.type Age = number | number\n.decl Person(name: Personid, age: Age)\n.decl Pet(name: Petid, owner: Personid, species: Speciesenum)\n.decl CatOwner(name: Personid)\nCatOwner(y) :- Pet(x, y, \"CAT\").\n</code>\n</pre> <pre><code>theory.add(Term(\"Person\", \"Freddy\", 22))\ntheory.add(Term(\"Pet\", \"Mr Tickles\", \"Freddy\", \"CAT\"))\n</code></pre> <pre><code>from typedlogic.registry import get_solver\nsolver = get_solver(\"souffle\")\nsolver.add(theory)\n</code></pre> <pre><code>model = solver.model()\nn = 0\nfor t in model.iter_retrieve(\"CatOwner\"):\n    print(t)\n    n += 1\n</code></pre> <pre>\n<code>CatOwner(Freddy)\n</code>\n</pre> <pre><code>assert n == 1\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorial/02-using-python-data-model/#using-the-python-api-to-create-theories-directly","title":"Using the Python API to create theories directly","text":"<p>In the previous tutorial we say how to write theories as Python programs. This allows for management of logical sentences as Python programs.</p> <p>It is possible to bypass this step as use the Python data models directly, without any need for parsing from Python.</p>"},{"location":"tutorial/02-using-python-data-model/#creating-a-theory-object","title":"Creating a Theory object","text":"<p>The top-level holder for logical sentences is a Theory object. Minimally a theory object can hold a number of logical sentences, as well as predicate definitions.</p> <p>We'll create a Theory object with minimal metadata:</p>"},{"location":"tutorial/02-using-python-data-model/#adding-type-definitions","title":"Adding type definitions","text":"<p>Next we will add some definitions of types. This step is optional, as you can simply use base types like <code>str</code>, <code>int</code> - or even leave your arguments untyped.</p> <p>But adding custom types can help make the program more understandable, and can help catch common errors, as well as help work better with frameworks like Souffle that expect typing information.</p>"},{"location":"tutorial/02-using-python-data-model/#adding-predicate-definitions","title":"Adding predicate definitions","text":"<p>Next we need to add PredicateDefinitions. These are the equivalent to the python classes we declared in the previous tutorial. Minimally, they describe the arguments (attributes, in Python speak) which predicates (classes) can take.</p>"},{"location":"tutorial/02-using-python-data-model/#adding-logical-sentences","title":"Adding logical sentences","text":"<p>Here we will define a new predicate <code>CatOwner/1</code> and a rule-type axiom to infer membership.</p>"},{"location":"tutorial/02-using-python-data-model/#adding-ground-terms-facts","title":"Adding ground terms (facts)","text":"<p>Next we will add ground terms (or simply instances in Python speak). We will use Term objects again, but these are ground terms (no variables).</p>"},{"location":"tutorial/02-using-python-data-model/#using-a-solver","title":"Using a Solver","text":"<p>Next we will use a Solver to reason over our theory plus ground terms. We will use the Souffle solver</p>"}]}